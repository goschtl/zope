"""
.. :doctest:

Detailed tests for dependencychecker:

    >>> from z3c.dependencychecker import dependencychecker


Filtering out missing requirements
----------------------------------

Empty lists, no problems:

    >>> dependencychecker.filter_missing(set(), set())
    set([])

Exact matching lists result in an empty list:

    >>> dependencychecker.filter_missing(set(['a']), set(['a']))
    set([])

A missing import is reported:

    >>> imports = set(['flup'])
    >>> required = set()
    >>> dependencychecker.filter_missing(imports, required)
    set(['flup'])

A requirement for some.thing is assumed to be enough for some.thing.else:

    >>> imports = set(['some.thing.else'])
    >>> required = set(['some.thing'])
    >>> dependencychecker.filter_missing(imports, required)
    set([])
    >>> required = set(['Some.Thing']) # case insensitive
    >>> dependencychecker.filter_missing(imports, required)
    set([])
    >>> required = set(['Some'])
    >>> dependencychecker.filter_missing(imports, required)
    set([])

But a requirement that is more specific than the import fails:

    >>> imports = set(['some.thing'])
    >>> required = set(['some.thing.else'])
    >>> dependencychecker.filter_missing(imports, required)
    set(['some.thing'])

Watch out with similar names:

    >>> imports = set(['zope.app.securitypolicy'])
    >>> required = set(['zope.app.security'])
    >>> dependencychecker.filter_missing(imports, required)
    set(['zope.app.securitypolicy'])

An oft-occurring example is a an import like ``from zope import interface``,
and a requirement for ``zope.interface``.  zope is picked up by the
importchecker mechanism (not zope.interface!), so we get the following problem:

    >>> imports = set(['zope'])
    >>> required = set(['zope.interface'])
    >>> dependencychecker.filter_missing(imports, required)
    set(['zope'])


Filter out unneeded requirements
--------------------------------

Empty lists, no problems:

    >>> dependencychecker.filter_unneeded(set(), set())
    set([])

Exact matches are fine:

    >>> imports = set(['zope.interface'])
    >>> required = set(['zope.interface'])
    >>> dependencychecker.filter_unneeded(imports, required)
    set([])

Too-specific requirements are reported:

    >>> imports = set(['zope'])
    >>> required = set(['zope.interface'])
    >>> dependencychecker.filter_unneeded(imports, required)
    set(['zope.interface'])


Testing the regexes
-------------------

Finding package="" in zcml files:

#     >>> import re
#     >>> input = ''
#     >>> re.findall(dependencychecker.ZCML_PACKAGE_PATTERN, input)
#     []
#     >>> input = '<bla\npackage="zope.interface"/>'
#     >>> re.findall(dependencychecker.ZCML_PACKAGE_PATTERN, input)
#     ['zope.interface']

Finding imports in doctests:

#     >>> input = ''
#     >>> re.findall(dependencychecker.DOCTEST_IMPORT, input)
#     []
#     >>> input = '    >>> print 7'
#     >>> re.findall(dependencychecker.DOCTEST_IMPORT, input)
#     []
#     >>> input = '    >>> import zope.interface'
#     >>> re.findall(dependencychecker.DOCTEST_IMPORT, input)
#     ['zope.interface']
#     >>> input = '    >>> #import zope.interface'
#     >>> re.findall(dependencychecker.DOCTEST_IMPORT, input)
#     []

Finding from-imports in doctests:

#     >>> input = ''
#     >>> re.findall(dependencychecker.DOCTEST_FROM_IMPORT, input)
#     []
#     >>> input = '    >>> print 7'
#     >>> re.findall(dependencychecker.DOCTEST_FROM_IMPORT, input)
#     []
#     >>> input = '    >>> from zope import interface'
#     >>> re.findall(dependencychecker.DOCTEST_FROM_IMPORT, input)
#     [('zope', 'interface')]
#     >>> input = '    >>> from zope import interface, component'
#     >>> re.findall(dependencychecker.DOCTEST_FROM_IMPORT, input)
#     [('zope', 'interface, component')]
#     >>> input = '    >>> #from zope import interface'
#     >>> re.findall(dependencychecker.DOCTEST_FROM_IMPORT, input)
#     []


Grabbing the name from setup.py
-------------------------------

Mock that we print our name (provided that we're called with ``--name`` of
course):

    >>> import os
    >>> import sys
    >>> import tempfile
    >>> newtempdir = tempfile.mkdtemp(prefix='depcheck')
    >>> setup_py = os.path.join(newtempdir, 'setup.py')
    >>> open(setup_py, 'w').write('\n'.join([
    ...     "import sys",
    ...     "assert '--name' in sys.argv",
    ...     "print 'my_name'"]))
    >>> os.chdir(newtempdir)

Grab the name:

    >>> dependencychecker.name_from_setup()
    'my_name'

Mock that something goes wrong:

    >>> open(setup_py, 'w').write("raise UserError('raargh')")

Grab the name, which results in a (mocked) sys.exit():

    >>> dependencychecker.name_from_setup()
    Traceback (most recent call last):
    ...
    MockExitException: 1


Corner case: egg info contents and location
-------------------------------------------

We're in a temp dir.  First restore the setup.py:

    >>> open(setup_py, 'w').write('\n'.join([
    ...     "import sys",
    ...     "assert '--name' in sys.argv",
    ...     "print 'my_name'"]))

The normal ``src/xyz.egg-info`` case is already handled by the main example.
Here we create the egg info dir directly in the directory itself.  Not the
common case, but we support the lack of ``src/`` dir.

    >>> os.mkdir('my_name.egg-info')

If we grab the requirements now, we hit two corner cases:

- The egg-info dir is here, not in src.

- The requires.txt file is missing.

Grab it and watch the fireworks:

    >>> dependencychecker.existing_requirements()
    Traceback (most recent call last):
    ...
    MockExitException: 1


Determining the path
--------------------

The default case ("just pick src/ in the current dir") is tested by the main
flow.  Here we test corner cases.

Pass the path on the command line:

    >>> args = [newtempdir]
    >>> dependencychecker.determine_path(args) == newtempdir
    True

Pass a non-existing path:

    >>> args = ['/does/not/exist']
    >>> dependencychecker.determine_path(args)
    Traceback (most recent call last):
    ...
    MockExitException: 1

Pass a file instead of a directory:

    >>> args = [setup_py]
    >>> dependencychecker.determine_path(args)
    Traceback (most recent call last):
    ...
    MockExitException: 1


Clean up the tempdir, btw:

    >>> import shutil
    >>> shutil.rmtree(newtempdir)

"""
