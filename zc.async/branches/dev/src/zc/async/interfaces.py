import zope.interface
import zope.interface.common.mapping
import zope.interface.common.sequence
import zope.component.interfaces
import zc.queue.interfaces
from zc.async.i18n import _

KEY = 'zc.async'

NEW = _('new-status', 'New')
PENDING = _('pending-status', 'Pending')
ASSIGNED = _('assigned-status', 'Assigned')
ACTIVE = _('active-status', 'Active')
CALLBACKS = _('callback-status', 'Performing Callbacks')
COMPLETED = _('completed-status', 'Completed')


class IObjectEvent(zope.interface.Interface):
    """Event happened to object"""
    
    object = zope.interface.Attribute('the object')

class AbstractObjectEvent(object):
    def __init__(self, object):
        self.object = object

class IDispatcherRegistered(IObjectEvent):
    """Dispatcher was registered"""

class DispatcherRegistered(AbstractObjectEvent):
    zope.interface.implements(IDispatcherRegistered)

class IDispatcherUnregistered(IObjectEvent):
    """Dispatcher was unregistered"""

class DispatcherUnregistered(AbstractObjectEvent):
    zope.interface.implements(IDispatcherUnregistered)

class IDispatcherActivated(IObjectEvent):
    """Dispatcher was activated"""

class DispatcherActivated(AbstractObjectEvent):
    zope.interface.implements(IDispatcherActivated)

class IDispatcherDeactivated(IObjectEvent):
    """Dispatcher was deactivated"""

class DispatcherDeactivated(AbstractObjectEvent):
    zope.interface.implements(IDispatcherDeactivated)

class AbortedError(Exception):
    """An explicit abort, as generated by the default behavior of
    IJob.fail"""


class BadStatusError(Exception):
    """The job is not in the status it should be for the call being made.
    This is almost certainly a programmer error."""


class IJob(zope.interface.Interface):

    parent = zope.interface.Attribute(
        """The current canonical location of the job""")

    callable = zope.interface.Attribute(
        """The callable object that should be called with *IJob.args and
        **IJob.kwargs when the IJob is called.  Mutable.""")

    args = zope.interface.Attribute(
        """a peristent list of the args that should be applied to self.call.
        May include persistent objects (though note that, if passing a method
        is desired, it will typicall need to be wrapped in an IJob).""")

    kwargs = zope.interface.Attribute(
        """a persistent mapping of the kwargs that should be applied to
        self.call.  May include persistent objects (though note that, if
        passing a method is desired, it will typicall need to be wrapped
        in an IJob).""")

    status = zope.interface.Attribute(
        """One of constants defined in zc.async.interfaces:
        NEW, PENDING, ASSIGNED, ACTIVE, CALLBACKS, COMPLETED.

        NEW means not added to a queue and not yet called.        
        PENDING means addded to a queue but not an agent, and not yet called.
        ASSIGNED means added to an agent and not yet called.
        ACTIVE means in the process of being called.
        CALLBACKS means in the process of calling callbacks.
        COMPLETED means called.""")

    result = zope.interface.Attribute(
        """The result of the call.  When state equals PENDING or ACTIVE, will
        be None.  When COMPLETED, will be a twisted.python.failure.Failure
        describing the call failure or the successful result.""")

    callbacks = zope.interface.Attribute(
        """A mutable persistent list of the callback jobs added by
        addCallbacks.""")

    annotations = zope.interface.Attribute(
        """An OOBTree that is available for metadata use.""")

    def addCallbacks(success=None, failure=None):
        """if success or failure is not None, adds a callback job to
        self.callbacks and returns the job.  Otherwise returns self.
        success and failure must be None or adaptable to IJob.
        addCallbacks may be called multiple times.  Each will be called
        with the result of this job.  If callback is already in COMPLETED
        state then the callback will be performed immediately."""

    def addCallback(callback):
        """callback will receive result (independent of whether it is a
        success or a failure).  callback must be adaptable to IJob.
        addCallback may be called multiple times.  Each will be called
        with the result of this job.  If callback is already in
        COMPLETED state then the callback will be performed immediately."""

    def __call__(*args, **kwargs):
        """call the callable.  Any given args are effectively appended to
        self.args for the call, and any kwargs effectively update self.kwargs
        for the call."""

    def fail(e=AbortedError):
        """Fail this job, with option error e.  May only be called when
        job is in PENDING or ACTIVE states, or else raises BadStatusError.
        If e is not provided,"""

    def resumeCallbacks():
        """Make all callbacks remaining for this job.  Any callbacks
        that are in PENDING state should be called normally; any callbacks
        in ACTIVE state should be `fail`ed; any callbacks in CALLBACKS state
        should `resumeCallback`; and any callbacks in COMPLETED state should
        be untouched.  May only be called when job is in CALLBACKS state.
        State will be COMPLETED after this call."""


class IAgent(zope.interface.common.sequence.IFiniteSequence):
    """Responsible for picking jobs and keeping track of them.
    
    An agent is a persistent object in a queue that is associated with a
    dispatcher and is responsible for picking jobs and keeping track of
    them. Zero or more agents within a queue can be associated with a
    dispatcher. 
    
    Each agent for a given dispatcher is identified uniquely with a
    name.  A fully (universally) unique identifier for the agent can be
    obtained by combining the key of the agent's queue in the main queue
    mapping at the ZODB root; the UUID of the agent's dispatcher; and
    the agent's name.
    """
    
    size = zope.interface.Attribute(
        """The maximum number of jobs this agent should have active at a time.
        """)

    name = zope.interface.Attribute(
        """The name for this agent.  Unique within its dispatcher's jobs for
        its queue.  Can be used to obtain agent with 
        queue.dispatchers[*dispatcher UUID*][*name*].""")

    completed = zope.interface.Attribute(
        """an ICompleted of recent completed jobs.""")

    parent = zope.interface.Attribute(
        """a link to parent: an IDispatcherAgents container.""")

    def get():
        """get a new item, obtained from queue; or None if there are no
        items in the queue that this agent wants to take, or the agent is
        full.  If an item is returned, it has also been added to the agent.
        """

    def remove(item):
        """remove item, or raise ValueError if item is not in queue"""

    def __delitem__(index):
        """delete item at index"""

    def index(item):
        """return index, or raise ValueError if item is not in queue"""


class IQueuedJob(IJob):
    """An async job with all the necessary knobs to by put in a
    datamanager."""

    workerUUID = zope.interface.Attribute(
        """The UUID of the IWorker who is, or was, responsible for this
        job.  None initially.  Should be assigned by
        IWorker.[reactor|thread].put.""")

    assignerUUID = zope.interface.Attribute(
        """The UUID of the software instance that was in charge when the
        IJob was put in an IJobQueue.  Should be assigned by
        IJobQueue.put.""")

    selectedUUIDs = zope.interface.Attribute(
        """a set of selected worker UUIDs.  If it is empty, it is
        interpreted as the set of all available workerUUIDs.  Only
        workers with UUIDs in the set may perform it.

        If a worker would have selected this job for a run, but the
        difference of selected_workerUUIDs and excluded_workerUUIDs
        stopped it, it is responsible for verifying that the effective
        set of workerUUIDs intersects with the available workers; if the
        intersection contains no possible workers, the worker should
        call job.fail().""")

    begin_after = zope.interface.Attribute(
        """A datetime.datetime in UTC of the first time when the
        job may run.  Cannot be set after job gets a data_manager.
        """)

    begin_by = zope.interface.Attribute(
        """A datetime.timedelta of the duration after the begin_after
        value after which the job will fail, if it has not already
        begun.  Cannot be set after job has begun.""")

class IQueue(zc.queue.interfaces.IQueue):

    parent = zope.interface.Attribute(
        """the IDataManager of which this is a part.""")

    def put(item, begin_after=None, begin_by=None):
        """Put an IJob adapted from item into the queue.  Returns IJob.

        Rememeber that IJobs are not guaranteed to be run in order
        added to a queue.  If you need sequencing, use
        IJob.addCallbacks.
        
        item must be an IJob, or be adaptable to that interface.
        begin_after must be None (to leave the job's current value) or a 
        datetime.datetime.  begin_by must be None (to leave it alone) or a
        datetime.timedelta of the duration after the begin_after.

        If item.begin_after is None and begin_after is None, begin_after will
        effectively be now.  If item.begin_by is None and begin_by is None,
        begin_by will effectively be datetime.timedelta(hours=1).

        datetime.datetimes are suggested to be in UTC.  Timezone-naive
        datetimes will be interpreted as in UTC.  Timezone-aware datetimes
        will be converted to UTC, and errors because of this (such as
        pytz ambiguity errors) will be raised.

        When an IJob is put in the queue, the queue puts the
        begin_after time and begin_by duration on the job,
        and the UUID of the Zope instance that put the job in the
        queue on the `assignerUUID`.
        """

    def claim(filter=None, default=None):
        """returns first due job that is available for the given filter,
        removing it from the queue as appropriate; or None, if none are
        available. Responsible for including jobs to fail expired
        jobs."""

class IDispatcherAgents(zope.interface.common.mapping.IMapping):
    """holds agents.  contained agents get a ``name`` and ``parent``
    associated with this mapping."""

class IDispatchers(zope.interface.common.mapping.IEnumerableMapping):

    def register(UUID):
        "register UUID"

    def unregister(UUID):
        "unregister UUID"

    def ping(UUID):
        """responsible for setting ping time if necessary for this
        dispatcher agent, and for decomissioning dead dispatchers for
        the next highest dispatcher (sorted by UUID) if its (last_ping +
        ping_interval + ping_death_interval) < now.  If this is the
        highest dispatcher UUID, cycles around to lowest."""

class IQuota(zope.interface.common.mapping.IEnumerableMapping):
    def clean():
        ''
    filled = zope.interface.Attribute(
        "")
    def add(item):
        "add a job"
    name = zope.interface.Attribute(
        "")
    parent = zope.interface.Attribute(
        "")


class IDataManager(zope.interface.Interface):
    """Note that jobs added to queues are not guaranteed to run in
    the order added.  For sequencing, use IJob.addCallbacks."""

    thread = zope.interface.Attribute(
        """An IJobQueue of IJobs that should be run in a thread.""")

    reactor = zope.interface.Attribute(
        """An IJobQueue of IJobs that should be run in the main
        loop (e.g., Twisted's main reactor loop).""")

    workers = zope.interface.Attribute(
        """An IWorkers of registered IWorker objects for this data manager;
        these objects represent processes that are responsible for claiming
        and performing the IJobs in the data manager.""")

    def checkSibling(uuid):
        """check the next sibling of uuid to see if it is dead, according
        to its last_poll, and remove the engineUUID and schedule removal of its
        jobs if it is dead."""

class IDataManagerAvailableEvent(zope.component.interfaces.IObjectEvent):
    """object is data manager"""

class DataManagerAvailable(zope.component.interfaces.ObjectEvent):
    zope.interface.implements(IDataManagerAvailableEvent)

class FullError(Exception):
    """Container is full.
    """

class ISizedSequence(zope.interface.common.sequence.IFiniteSequence):
    size = zope.interface.Attribute(
        """an integer.  If the queue's len >= size, put will raise
        FullError""")

    def add(item):
        """same contract as IQueue.put, except if queue's len >= size, put will
        raise FullError, and all objects get __parent__ set to the queue;
        and it will only store jobs."""

    __parent__ = zope.interface.Attribute(
        """a link to parent: an IWorker""")

    def remove(item):
        """remove item, or raise ValueError if item is not in queue"""

    def __delitem__(index):
        """delete item at index"""

    def index(item):
        """return index, or raise ValueError if item is not in queue"""

class ICompletedCollection(zope.interface.Interface):
    def __iter__():
        """Iterate over jobs in collection, from most recent `begin_after`
        to oldest"""

    def iter(start=None, stop=None):
        """Iterate over jobs in collection, starting and stopping with
        given timezone-aware datetime values reasonably efficiently."""

    def __len__():
        """Return number of jobs in collection"""

    def add(job):
        """Add job to collection and set __parent__ to the collection."""

    __parent__ = zope.interface.Attribute(
        """an IAgent""")

    def first(start=None):
        """Return the first (most recent) job in the collection, starting
        with optional timezone-aware datetime."""

    def last(stop=None):
        """Return the last (oldest) job in the collection, stopping
        with optional timezone-aware datetime."""

    def __nonzero__():
        "whether collection contains any jobs"

class IWorker(zope.interface.Interface):

    reactor = zope.interface.Attribute(
        """An ISizedQueue of reactor jobs currently being worked on by this
        worker.""")

    thread = zope.interface.Attribute(
        """An ISizedQueue of thread jobs currently being worked on by this
        worker.""")

    UUID = zope.interface.Attribute(
        """The uuid.UUID that identifies this worker (where one instance ==
        one process == one worker == one UUID).""")

    engineUUID = zope.interface.Attribute(
        """The uuid.UUID of the engine that is running this worker, or None.""")

    last_ping = zope.interface.Attribute(
        """the datetime.datetime in the pytz.UTC timezone of the last ping.
        This date should be updated anytime a worker accepts a job in a
        reactor or thread queue; and whenever, during a poll,
        (last_ping + ping_interval) <= now.""")

    poll_seconds = zope.interface.Attribute(
        """The number of seconds between the end of one worker poll and the
        start of the next.""")

    ping_interval = zope.interface.Attribute(
        """The approximate maximum datetime.timedelta between pings before
        a new last_ping should be recorded.""")

    ping_death_interval = zope.interface.Attribute(
        """the datetime.timedelta after the last_ping + ping_interval that
        signifies the workers death.  That is, if (last_ping + ping_interval +
        ping_death_interval) < now, the worker should be regarded as dead.
        """)

    completed = zope.interface.Attribute(
        """The most recent jobs completed by this worker, in the order
        from most recent `begin_after` to oldest.  ICompletedCollection.""")

class IUUID(zope.interface.Interface):
    """A marker interface for the API of Ka-Ping Yee's uuid.UUID class.
    See http://zesty.ca/python/uuid.html """
