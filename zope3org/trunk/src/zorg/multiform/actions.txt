===================
 Multiform Actions
===================

The multiform package defines a new type of action called
ParentAction. A parent action is rendered only one time in the parent
multiform, but applied to all subforms.

In this example we create a specialized item form class, which defines
a new parent action called ``Save``. Additionally two standard actions
are defined in the multiform (parent) class called ``Edit`` and
``Cancel```.

    >>> from multiform.multiform import ItemFormBase,MultiFormBase
    >>> from zope.app.form.interfaces import IInputWidget
    >>> from zope.formlib import form
    >>> from multiform import multiform
    >>> from zope.publisher.browser import TestRequest
    >>> from zope import interface, schema
    >>> class IOrder(interface.Interface):
    ...     identifier = schema.Int(title=u"Identifier", readonly=True)
    ...     name = schema.TextLine(title=u"Name")
    >>> class Order:
    ...     interface.implements(IOrder)
    ...
    ...     def __init__(self, identifier, name=''):
    ...         self.identifier = identifier
    ...         self.name = name

    >>> orderMapping = dict([(str(k),Order(k,name='n%s'%k)) for k in range(2)])

    >>> class OrderForm(ItemFormBase):
    ...     inputMode=False
    ...     
    ...     def __init__(self,context,request,parentForm):
    ...         super(OrderForm,self).__init__(context,request,parentForm)
    ...         self.form_fields = form.Fields(IOrder,omit_readonly=False,
    ...         render_context=True)
    ...         
    ...     @multiform.parentAction(u"Save",
    ...     condition=multiform.isParentFormInputMode,inputMode=True)
    ...     def handle_save_action(self, action, data):
    ...         form.applyChanges(self.context, self.form_fields,
    ...         data, self.adapters)
    ...         self.parentForm.newInputMode=False
    ...         
    ...     def template(self):
    ...         return '\n<div>%s</div>\n' % '</div><div>'.join([w() for w in
    ...     self.widgets])


    >>> class OrdersForm(MultiFormBase):
    ...     itemFormFactory=OrderForm
    ...     def template(self):
    ...         res = u''
    ...         names = sorted(self.subForms.keys())
    ...         for name in names:
    ...             res += '<div>%s</div>\n' % self.subForms[name].render()
    ...         return res
    ...     
    ...     @form.action('Edit',condition=multiform.isFormDisplayMode)
    ...     def handle_edit_action(self, action, data):
    ...         self.newInputMode=True
    ...         
    ...     @form.action('Cancel',condition=multiform.isFormInputMode)
    ...     def handle_cancel_action(self, action, data):
    ...         self.newInputMode=False


So in our new form all widgets are display widgets per default

    >>> request = TestRequest()
    >>> pf = OrdersForm(orderMapping,request)
    >>> print pf()
    <div>
    <div>0</div><div>n0</div>
    </div>
    <div>
    <div>1</div><div>n1</div>
    </div>

And the save action should not be available, due to the reason that there
are no input widgets in the sub forms.

    >>> pf.subActionNames
    []
    >>> [action.__name__ for action in pf.availableActions()]
    [u'form.actions.edit']

Now let's call the edit action to set the widgets to input widgets.

    >>> request.form['form.actions.edit']=u''
    >>> pf =  OrdersForm(orderMapping,request)
    >>> print pf()
    <div>
    <div...<input class="textType" ... value="n0" ...
    </div>
    <div>
    <div...<input class="textType" ... value="n1" ...

Now the save action should be available in the subActionNames and
the cancel action in the multiform actions.

    >>> pf.subActionNames
    [u'form.actions.save']
    >>> [a.__name__ for a in pf.availableActions()]
    [u'form.actions.cancel']


Now Let us save some data.

    >>> request = TestRequest()
    >>> request.form['form.actions.save']=u''
    >>> for i in range(2):
    ...     request.form['form.%s.name' % i]='newer name %s' % i
    ...     request.form['form.%s.identifier' % i]= i
    >>> pf =  OrdersForm(orderMapping,request)
    >>> result = pf()

After the form is called, the changes are applied to the objects. 
    >>> [obj.name for obj in orderMapping.values()]
    [u'newer name 1', u'newer name 0']

Due to the reason the save handler sets the inputMode to False,
only display widgets are rendered in the results

    >>> print result
    <div>
    <div>0</div><div>newer name 0</div>
    </div>
    <div>
    <div>1</div><div>newer name 1</div>
    </div>

Now we should only have the edit action be available, which is a
multiform action, therefore not contained in the subActionNames

    >>> pf.subActionNames
    []
    >>> [a.__name__ for a in pf.availableActions()]
    [u'form.actions.edit']

Now Let us cancel the edit mode.

    >>> request = TestRequest()
    >>> request.form['form.actions.cancel']=u''
    >>> for i in range(2):
    ...     request.form['form.%s.name' % i]='next name %s' % i
    ...     request.form['form.%s.identifier' % i]= i
    >>> pf =  OrdersForm(orderMapping,request)
    >>> result = pf()

After the form is called, the objects are left unchanged. And the form
should be in display mode again.

    >>> [obj.name for obj in orderMapping.values()]
    [u'newer name 1', u'newer name 0']

    >>> print result
    <div>
    <div>0</div><div>newer name 0</div>
    </div>
    <div>
    <div>1</div><div>newer name 1</div>
    </div>

