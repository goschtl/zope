======================================
Motivation for a new Versioning Scheme
======================================

We start by testing some of the existing infrastructure from zope.app.versioncontrol
and try to apply the existing versioning to sample data. We take a simple
folder tree with the following structure as our sample :

  sample
    |--> a <--|
    |--> b    |
         |--> c
     

    >>> from versioning.tests.test_versioncontrol import buildRepository, buildDatabaseRoot
  

    >>> from zope.interface import directlyProvides
    >>> from ZODB.tests import util
    >>> import zope.app.versioncontrol.interfaces
    >>> import zope.app.traversing.interfaces
    >>> import zope.app.folder
    >>> from zope.interface import implements
    >>> from zope.app.traversing.interfaces import IPhysicallyLocatable
    >>> class TestFolder(zope.app.folder.Folder) :
    ...     implements(IPhysicallyLocatable)
    ...     def getPath(self) : return ""
    >>> sample = TestFolder()
    >>> directlyProvides(sample, zope.app.traversing.interfaces.IContainmentRoot)
    >>> a = sample["a"] = TestFolder()
    >>> b = sample["b"] = TestFolder()
    >>> c = b["c"] = TestFolder()
    >>> for x in (sample, a, b, c) :
    ...     directlyProvides(x, zope.app.versioncontrol.interfaces.IVersionable)
    >>> [x for x in sample.keys()]
    [u'a', u'b']
    >>> db_root = buildDatabaseRoot()
    >>> db_root["sample"] = sample  
    >>> repository = buildRepository(interaction=True) 
    >>> util.commit()
    
    
The interesting test case is the reference that uses references outside
the hierarchical ones, which should be naturally handled in Zope3:

    >>> c.refers_to = a
    >>> a == c.refers_to
    True

In order to show some limitations of the current implementation we use a
prebuild version control repository :

  
  
The current policy forces us to remove __parent__ and __name__. We'll do that
by specializing the standard adapter that removes nothing:

    >>> from zope.app.versioncontrol.nonversioned import StandardNonVersionedDataAdapter
    >>> class NonVersionedAdapter(StandardNonVersionedDataAdapter) :
    ...     attrs = ("__name__", "__parent__")   # remove __name__ and __parent from versioning
  
  
    >>> from zope.app.testing import ztapi
    >>> ztapi.provideAdapter(zope.app.versioncontrol.interfaces.IVersionable,
    ...                       zope.app.versioncontrol.interfaces.INonVersionedData,
    ...                       NonVersionedAdapter)
    >>> zope.app.versioncontrol.interfaces.INonVersionedData(a) is not None
    True

Now we can put our example data under version control:

    >>> repository.applyVersionControl(sample)
    >>> repository.applyVersionControl(a)
    >>> repository.applyVersionControl(b)
    >>> repository.applyVersionControl(c)
    >>> util.commit()
    >>> [zope.app.versioncontrol.interfaces.IVersioned.providedBy(x) for x in (sample, a, b, c)]
    [True, True, True, True]
    >>> [x for x in sample.keys()]
    [u'a', u'b']
  

The implementation in zope.app.versioncontrol breaks any database identity references
because a pickle version is used that ignores all references that point
outside the sub tree. In the example above this means, that the version of c loses
its reference to a because c is not contained in a. (See 
 zope.app.versioncontrol.version.cloneByPickle)

    >>> def accessVersion(repository, obj) :
    ...   info = repository.getVersionInfo(obj)
    ...   return repository.getVersionOfResource(info.history_id, 'mainline')
    >>> new_a = accessVersion(repository, a)
    >>> new_b = accessVersion(repository, b)
    >>> new_c = accessVersion(repository, c)
    >>> [x for x in sample.keys()]
    [u'a', u'b']

Now the reference from b to c is invalid ...
  
    >>> new_b["c"] == new_c
    False
  
as well as the reference from c to a :
  
    >>> new_c.refers_to == new_a
    False

  
This demonstrates that the reference to a is not preserved, which is the major
motivation for a new implementation.



A First Implementation
======================

We want to use versioning with objects other than standard zope objects that use
only the standard containment structure meachanism. In the same time some parts
of the versioning system should be pluggable, e.g. the storage for the object histories,
the locking mechanism etc.

Let's set up some initial content :

    >>> a.text = "First text version of a"
    >>> c.text = "First text version of c"

To achieve this goal we refactored the components of the versioning system.
Let's start with the basic building block, a storage that holds version histories
of several objects. Note that this implementation does not collide with the
implementation in zope.app.versioncontrol. This versioning scheme does not attach any
information to the versioned objects and keeps the necessary bookeeping information 
encapsulated in the storage of object histories.


    >>> from versioning.storage import SimpleHistoryStorage
    >>> histories = SimpleHistoryStorage()
    
The versioning system that puts object under versioning control must register
the object in the histories storage (this will be called later on by
IVersionControl.applyVersionControl) :

    >>> for x in [sample, a, b, c] :
    ...     histories.register(x) is not None
    True
    True
    True
    True
    >>> util.commit()
    >>> len(histories.values())
    4
    
The SimpleHistoryStorage.register method copies nothing. The copy process is 
managed by a multi adapter that implements a versioning policy, i.e. determines
how and what is versioned. The implementation here uses zope.app.copypastemove 
to save each version as a normal copy of the original content object.
    
    >>> import versioning.policies
    >>> def saveAsVersion(obj, histories) :       # a helper method XXX remove later
    ...     adapter = versioning.policies.ReplaceWithCopyPolicy(obj, histories)
    ...     return adapter.writeAspects()
    >>> saveAsVersion(sample, histories)
    '001'
    >>> saveAsVersion(a, histories)
    '001'
    >>> saveAsVersion(b, histories)
    '001'
    >>> saveAsVersion(c, histories)
    '001'
    >>> histories.getVersion(a, '001').data.text
    'First text version of a'
    
Add some additional content versions :

    >>> a.text = "Second text version of a"
    >>> c.text = "Second text version of c"
    >>> saveAsVersion(a, histories)
    '002'
    >>> version = histories.getVersion(a, '002')
    >>> version.data.text
    'Second text version of a'
    >>> saveAsVersion(c, histories)
    '002'
    >>> a001 = histories.getVersion(a, '001')
    >>> a001.data.text
    'First text version of a'
    >>> a002 = histories.getVersion(a, '002')
    >>> a002.data.text
    'Second text version of a'
    
    Note that after the copy process original and versions
    are all distinct object :
    
    >>> a != a001 != a002
    True
    

Now let's update the original object with versioned data. This again is a matter
of the policy. The simple implementation here replaces the original data
with a copy of the versioned data. 
    
    >>> def revertToVersionCopy(obj, histories, selector) :
    ...     adapter = versioning.policies.ReplaceWithCopyPolicy(obj, histories)
    ...     adapter.updateAspects(selector)
    >>> revertToVersionCopy(c, histories, '001')

The fact that we used copies here requires 
that we establish new references via traversal: 

    >>> new_c = b["c"]
    >>> new_c.text
    'First text version of c'

The reference to an old and untouched item is still
intact :
    
    >>> new_c.refers_to == a
    True
   
The more interesting case arises if we update the object that has
been referenced :
   
    >>> revertToVersionCopy(a, histories, '001')
    >>> new_a = sample["a"]
    >>> new_c.refers_to == a
    True
    >>> new_c.refers_to == new_a
    False

Depending on the use case this might be what you want.




A Second Implementation
=======================

A second policy uses the same copy routines to move objects into 
the storage of object histories. Therefore we need not set up the 
repository again. 

What differs is the way how to revert
the original object with versioned data. This implementation
does not replace the original with a copy but updates only all fields
with the versioned values.

    
    >>> def revertToVersionState(obj, histories, selector) :
    ...     adapter = versioning.policies.UpdateStatusPolicy(obj, histories)
    ...     adapter.updateAspects(selector)
    >>> new_a = a
    >>> a.text
    'Second text version of a'
    >>> revertToVersionState(a, histories, '001')
    >>> a.text
    'First text version of a'
    >>> a == new_a
    True
    >>> revertToVersionState(a, histories, '002')
    >>> a.text
    'Second text version of a'
    >>> a == new_a
    True
    
    Note that the versions and the objects are all different:
    
    >>> a != a001 != a002
    True
    >>> c.refers_to == a
    True
    
    








