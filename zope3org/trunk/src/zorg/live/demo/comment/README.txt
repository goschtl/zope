LiveComments Demo
=================

This demo shows how several users can observe live how they type their comments.
The comment text is broadcasted every second or so to all clients that share 
the comment page and thus give the impression of immediate group awareness.

    >>> from zorg.live.page.manager import LivePageManager
    >>> from zorg.live.page.interfaces import ILivePageManager
    >>> manager = LivePageManager()
    >>> zope.component.provideUtility(manager, ILivePageManager)

Additionally we must add a subscriber that observes Zope3 events and 
LivePageEvents :

    >>> from zorg.live.page.manager import livePageSubscriber
    >>> zope.event.subscribers.append(livePageSubscriber)

For test purposes we set the refresh interval (i.e. the interval in which
output calls are renewed) to 0.1 seconds :
    
    >>> from zorg.live.page.client import LivePageClient
    >>> LivePageClient.refreshInterval = 0.1

Now we simulate the startup of two clients. We need a shared file in order
to attach comments to the file:

    >>> from zorg.live.demo.comment.tests import buildTestFile
    >>> file = buildTestFile()

    >>> from zorg.live.demo.comment.comment import LiveComments
    
    >>> class Principal(object) :
    ...     def __init__(self, id, title) :
    ...         self.id = id
    ...         self.title = title
    
    >>> user1 = Principal('zorg.member.uwe', u'Uwe Oestmeier')
    >>> user2 = Principal('zorg.member.dominik', u'Dominik Huber')

Note that the startup is simulated by the nextClientId() call. We need
a second event handler who shows what happens :
    
    >>> def printEvent(event) :
    ...     print "Event:", event.__class__.__name__
    >>> zope.event.subscribers.append(printEvent)
    
And here is the simulated page request that starts the live session:

    >>> request = TestRequest()
    >>> request.setPrincipal(user1)
    >>> page1 = LiveComments(file, request)
    >>> page1.nextClientId()
    Event: LoginEvent
    'uuid1'
    >>> where1 = page1.getLocationId()
    
    >>> request.setPrincipal(user2)
    >>> page2 = LiveComments(file, request)
    >>> page2.nextClientId()
    Event: LoginEvent
    'uuid2'
    >>> where2 = page2.getLocationId()
    
Both users share the same group resp. context :
    
    >>> where1 == where2
    True
   
We ask the global utility to ensure that both users are online:
        
    >>> manager.whoIsOnline(where1)
    ['zorg.member.dominik', 'zorg.member.uwe']
    
This online status is also mirrored in the intial server events that are
send to the clients. Since both clients send events about changing online
states we get four events :

    >>> print page1.output('uuid1')
    update online 
    ['zorg.member.uwe']
   
    >>> print page1.output('uuid1')
    update online 
    ['zorg.member.uwe']

    >>> print page2.output('uuid2')
    update online 
    ['zorg.member.dominik', 'zorg.member.uwe']

    >>> print page2.output('uuid2')
    update online 
    ['zorg.member.dominik', 'zorg.member.uwe']

    >>> print page1.output('uuid1')
    update online 
    ['zorg.member.dominik', 'zorg.member.uwe']

    >>> print page1.output('uuid1')
    update online 
    ['zorg.member.dominik', 'zorg.member.uwe']


When the user starts typing, the Ajax textarea observer calls addComment which
broadcasts a new pending comment div that can be appended to the DOM children
of the 'comments' element of each browser client. 

The addComment call returns a key that can be used to update the text of the
new DOM element later on :

    >>> page1.addComment("Abc")
    Event: ObjectCreatedEvent
    Event: ObjectModifiedEvent
    '1'
 
 Note that the LivePageEvents are generated by a afterCommitHook. Therefore we
 must call transaction.commit() to simulate this. We must also set a 
 global request variable since the global getRequest function expects one:
 
    >>> import zorg.live.globals
    >>> zorg.live.globals.defaultRequest = request
    
    >>> import transaction
    >>> transaction.commit()

    >>> out1 = page1.output('uuid1')
    >>> print out1
    append comments scroll
    ...
    ...<p>Abc</p>...
    ...
 
    >>> out1 == page2.output('uuid2')
    True

After that the client of the first user sends updates for the text element
with the new uuid.

Clean up:

    >>> zope.event.subscribers.remove(livePageSubscriber)
    >>> zope.event.subscribers.remove(printEvent)
    >>> zope.event.subscribers = []