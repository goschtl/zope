===================
Relation Properties
===================

Relation properties allow to transparently relate objects by simple
attributes.

Let us create some content objects to demonstrate this.

  >>> from zope import schema, interface
  >>> from zope.schema.interfaces import IObject
  >>> class IImage(interface.Interface):
  ...     name = schema.TextLine(title=u'Name')

  >>> class Image(object):
  ...     interface.implements(IImage)
  ...     def __init__(self, name):
  ...         self.name = name
  ...     def __repr__(self):
  ...         return '<image %r>' % self.name

  >>> class IRelatedByDocument(interface.Interface):
  ...     """things that can be refered to by documents"""
  ...     backrefs = schema.List(title=u"Backreferences",
  ...                            value_type=schema.Object(IObject),
  ...                            required=False,
  ...                            default=[])

  >>> class IDocument(IRelatedByDocument):
  ...     teaser = schema.Object(IImage, title=u'Teaser Image')
  ...     related = schema.List(title=u"Related",
  ...                           value_type=schema.Object(IRelatedByDocument),
  ...                           required=False,
  ...                           default=[])

  >>> from zope import component
  >>> from zope.app.intid.interfaces import IIntIds
  >>> intids = component.getUtility(IIntIds)


Relation Managers
=================

Relation managers are responsible to handle all aspects of one
particular relation. This package defines a relation manager which
uses interface fields to describe a relation.

The field based manager is instanciated by providing a source and
target field, a relation type identifier and the name of a IRelations
utility registration.

Let us create the document to document relation manager.

  >>> from lovely.relation.property import FieldRelationManager
  >>> documentRelated = FieldRelationManager(IDocument['related'],
  ...                                        IRelatedByDocument['backrefs'],
  ...                                        relType='documentRelated')

and the document to teaser relation manager. Note that except of the
source, every argument to the constructor is optional. If no target
field is provided, no backreferencing property can be defined by using
this manager.

  >>> documentTeaser = FieldRelationManager(IDocument['teaser'])

If no explicit relation type is given, then a type identifier is
generated by using the fields as basis.

  >>> documentTeaser.relType
  'zope.schema._field.Object.teaser:None'


Properties
==========

Relationproperties are instanciated, with the relation manager and optionally
with a different relType. The relation manager can be provided with the
manager instance or with the name of a utility implementing
IFieldRelationManager.

For now we directly pass the manager objects to the constructor of the
properties.

  >>> from lovely.relation.property import RelationPropertyIn
  >>> from lovely.relation.property import RelationPropertyOut
  >>> class Document(object):
  ...     interface.implements(IDocument)
  ...     teaser = RelationPropertyOut(documentTeaser)
  ...     featured = RelationPropertyOut(documentTeaser, relType='featured')
  ...     related = RelationPropertyOut(documentRelated)
  ...     connected = RelationPropertyOut(documentRelated, relType='connected')
  ...     backrefs = RelationPropertyIn(documentRelated)
  ...     def __init__(self, name):
  ...         self.name = name
  ...     def __repr__(self):
  ...         return '<document %r>' % self.name

There are two types of relations properties - "In" and "Out". The
former means that the property is the source and the latter means the
property is the target of the relation.

  >>> doc1 = Document(u'Doc One')
  >>> doc2 = Document(u'Doc Two')
  >>> doc3 = Document(u'Doc Three')
  >>> img1 = Image(u'Image One')

Before we can set any relations, we have to register a special
relations utility which does one to one relations and the
relation types are defined as strings.

  >>> from lovely.relation.app import O2OStringTypeRelationships
  >>> from lovely.relation.interfaces import IO2OStringTypeRelationships
  >>> rels = O2OStringTypeRelationships()
  >>> component.provideUtility(rels, IO2OStringTypeRelationships)

We can now define a teaser on doc1. Note that we have no list here
because the field is an IObject field.

  >>> doc1.teaser is None
  True
  >>> doc1.teaser = img1
  >>> doc1.teaser
  <image u'Image One'>
  >>> doc1.teaser = None
  >>> doc1.teaser is None
  True
  >>> doc1.teaser = img1

Our featured attribute uses the same relation manager as the teaser but
defines a different relType (see the definition in the class).

  >>> featuredImage = Image(u'Featured Image')
  >>> doc1.featured = featuredImage
  >>> doc1.featured
  <image u'Featured Image'>

Our teaser is still the old one.

  >>> doc1.teaser
  <image u'Image One'>

  >>> doc1.featured = None
  >>> doc1.featured == None
  True

The related property is a list because the field is defined as schema.List.

  >>> doc1.related = [doc2, doc3]
  >>> doc1.related
  [<document u'Doc Two'>, <document u'Doc Three'>]

  >>> doc1.related = [doc3]
  >>> doc1.related
  [<document u'Doc Three'>]

Note that the order is kept. To demonstrate this we change the order
of the related documents.

  >>> doc1.related = [doc3, doc2]
  >>> doc1.related
  [<document u'Doc Three'>, <document u'Doc Two'>]

It is also possible to use intids instead of real objects.

  >>> doc2Id = intids.getId(doc2)

The backrefs are automatically updated too.

  >>> doc2.backrefs
  [<document u'Doc One'>]

  >>> doc3.related = [doc2Id]
  >>> doc3.related
  [<document u'Doc Two'>]

  >>> doc2.backrefs
  [<document u'Doc One'>, <document u'Doc Three'>]

Note that the backrefs can be sorted too.

  >>> doc2.backrefs = [doc3, doc1]
  >>> doc2.backrefs
  [<document u'Doc Three'>, <document u'Doc One'>]

But the order of the forwardrefes still is kept.

  >>> doc1.related
  [<document u'Doc Three'>, <document u'Doc Two'>]

We can also remove backrefs.

  >>> doc2.backrefs = [doc1]
  >>> doc2.backrefs
  [<document u'Doc One'>]

And the relations get updated. We see this here because doc3 had a
relation to doc2 before and now the relations are gone.

  >>> doc3.related
  []
  >>> doc1.related
  [<document u'Doc Three'>, <document u'Doc Two'>]

Note are different to documents. They are not allowed to change/remove backrefs.

  >>> class INote(interface.Interface):
  ...     """things that can be refered to by documents"""
  ...     backrefs = schema.List(title=u"Backreferences",
  ...                            value_type=schema.Object(IObject),
  ...                            required=False,
  ...                            readonly=True,
  ...                            default=[])

We create a new relation manager for notes.

  >>> noteRelated = FieldRelationManager(IDocument['related'],
  ...                                        INote['backrefs'],
  ...                                        relType='documentRelated')

  >>> class Note(object):
  ...     interface.implements(INote)
  ...     backrefs = RelationPropertyIn(noteRelated)
  ...     def __init__(self, name):
  ...         self.name = name
  ...     def __repr__(self):
  ...         return '<note %r>' % self.name

Create a note and relate doc 3 to the note.

  >>> n = Note(u"note")
  >>> doc3.related = [n]
  >>> doc3.related[0] is n
  True
  >>> n.backrefs[0] is doc3
  True

Try to remove the backref from the note.

  >>> n.backrefs = []
  Traceback (most recent call last):
  ...
  ValueError: ('backrefs', 'field is readonly')
  >>> n.backrefs[0] is doc3
  True

Backref to doc 3 still exists.


Use Of The Relationship Utility
-------------------------------

The relationship utility allows queries on instances on which it is not
possible to set a property on. As in our image class we have no direct way to
get the documents which refer to an image. This is only possible by using the
utility.

To get the correct realtionship utility the relation manager must be used.

  >>> relUtil = documentRelated.util

If we use the relationships utility to do queries we get all existing
relations for a document.

  >>> [t for t in relUtil.findTargets(doc1)]
  [<image u'Image One'>, <document u'Doc Three'>, <document u'Doc Two'>]

  >>> [s for s in relUtil.findSources(img1)]
  [<document u'Doc One'>]

It is also possible to do queries based on intids instead of using the object
directly.

  >>> img1Id = intids.getId(img1)

  >>> [s for s in relUtil.findSources(img1Id)]
  [<document u'Doc One'>]

To get the result for a specific relation we need to provide the relation type
to the query.

  >>> list(relUtil.findTargets(doc1, documentTeaser.relType))
  [<image u'Image One'>]


Relations Using Uids
--------------------

Providing the object of relations can be very inefficient. It is possible to
define relation properties which provide uids instead of the objects.

  >>> class UidDocument(object):
  ...     interface.implements(IDocument)
  ...     teaser = RelationPropertyOut(documentTeaser, uids=True)
  ...     related = RelationPropertyOut(documentRelated, uids=True)
  ...     backrefs = RelationPropertyIn(documentRelated)
  ...     def __init__(self, name):
  ...         self.name = name
  ...     def __repr__(self):
  ...         return '<document %r>' % self.name

  >>> doc11 = UidDocument(u'UidDoc One')
  >>> doc12 = UidDocument(u'UidDoc Two')
  >>> doc13 = UidDocument(u'UidDoc Three')
  >>> img2 = Image(u'Image Two')

  >>> doc11.teaser is None
  True
  >>> doc11.teaser = img2

We get the intid for the teaser.

  >>> intids.getObject(doc11.teaser)
  <image u'Image Two'>
  >>> doc11.teaser = None
  >>> doc11.teaser is None
  True

  >>> doc11.related = [doc12, doc13]
  >>> doc11.related == [intids.getId(doc12), intids.getId(doc13)]
  True

The backrefs provide the objects.

  >>> doc12.backrefs
  [<document u'UidDoc One'>]


More Access to relations
------------------------

To be able to do more advanced queries in relations it is possible to get the
relation manager for a property.

First we look at our teaser.

  >>> from lovely.relation.property import PropertyRelationManager
  >>> manager = PropertyRelationManager(doc1, 'teaser')
  >>> manager
  <lovely.relation.property.PropertyRelationManager object at ...>

  >>> relations = list(manager.getRelations())
  >>> relations
  [<O2OStringTypeRelationship u'...'>]
  >>> list(manager.getRelationTokens()) == [intids.getId(relations[0])]
  True

  >>> relations[0].sources, relations[0].targets
  (<document u'Doc One'>, <image u'Image One'>)

  >>> doc1.teaser = None
  >>> list(manager.getRelations())
  []

  >>> doc1.related
  [<document u'Doc Three'>, <document u'Doc Two'>]

Let's look at our related property.

  >>> manager = PropertyRelationManager(doc1, 'related')
  >>> manager
  <lovely.relation.property.PropertyRelationManager object at ...>
  >>> relations = list(manager.getRelations())
  >>> relations
  [<O2OStringTypeRelationship u'...'>, <O2OStringTypeRelationship u'...'>]
  >>> relations[0].sources, relations[0].targets
  (<document u'Doc One'>, <document u'Doc Three'>)
  >>> relations[1].sources, relations[1].targets
  (<document u'Doc One'>, <document u'Doc Two'>)

And the backrefs.

  >>> manager = PropertyRelationManager(doc2, 'backrefs')
  >>> manager
  <lovely.relation.property.PropertyRelationManager object at ...>
  >>> relations = list(manager.getRelations())
  >>> relations
  [<O2OStringTypeRelationship u'...'>]
  >>> relations[0].sources, relations[0].targets
  (<document u'Doc One'>, <document u'Doc Two'>)

A more advanced use case is the use of backrefs for different relation types
which is the case if a relation manager is used for different properties. Our
test example provides this via the "related" and the "connected" property.

  >>> manager = PropertyRelationManager(doc2, 'backrefs')

There are currently no backrefs to the relation type "connected".

  >>> [rel.sources for rel in manager.getRelations('connected')]
  []

But we have backrefs for "documentRelated" which is also the default relation
type used if no relation type is given.

  >>> [rel.sources for rel in manager.getRelations('documentRelated')]
  [<document u'Doc One'>]
  >>> [rel.sources for rel in manager.getRelations()]
  [<document u'Doc One'>]

Now we connect doc1 and doc2 to doc3.

  >>> doc3.connected = [doc2, doc1]

Now we have a backref for "connected".

  >>> [rel.sources for rel in manager.getRelations('connected')]
  [<document u'Doc Three'>]
  >>> [rel.sources for rel in manager.getRelations('documentRelated')]
  [<document u'Doc One'>]


Event Handlers
--------------

If an object containing relation properties is removed from the intid utility
an event handler removes all relationships.

  >>> from lovely.relation.event import o2oIntIdRemoved
  >>> component.provideHandler(o2oIntIdRemoved)

  >>> root['doc1'] = doc1
  >>> root['doc2'] = doc2
  >>> root['doc3'] = doc3
  >>> root['img1'] = img1

  >>> doc1.teaser = img1
  >>> doc1.teaser
  <image u'Image One'>

Deleting the image removes the teaser from the document.

  >>> del root['img1']
  >>> doc1.teaser is None
  True

Deleting a document also removes all references to it.

  >>> doc2.backrefs
  [<document u'Doc One'>]

  >>> del root['doc1']

  >>> doc2.backrefs
  []

