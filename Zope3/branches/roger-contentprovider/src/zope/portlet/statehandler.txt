=====================
Portlet Statehandlers
=====================

A state handler is an adapter to portlets that is responsible
for keeping track of the portlets' states.

It depends on the implementation of the state handler where and how
the state is stored.


Getting Started
---------------

  >>> from zope.app.testing import ztapi
  >>> from zope.app import zapi
  >>> from zope.interface import implements, directlyProvides

  >>> from zope.contentprovider.interfaces import IContentProviderType
  >>> from zope.portlet.interfaces import IStateHandler
  >>> from zope.portlet.interfaces import IPortlet

Let's start with a simple dummy state handler that stores the state
transiently in itself.
  
  >>> class SimpleStateHandler(object):
  ...     implements(IStateHandler)
  ...
  ...     def __init__(self, context):
  ...         self.context = context
  ...         self.states = {}
  ...
  ...     def setState(self, state, name):
  ...         cpType = zapi.queryType(self.context, IContentProviderType)
  ...         cpTypeName = cpType.__module__ + '.' + cpType.__name__
  ...         self.states[cpTypeName + '/' + name] = state
  ...
  ...     def getState(self, name):
  ...         cpType = zapi.queryType(self.context, IContentProviderType)
  ...         cpTypeName = cpType.__module__ + '.' + cpType.__name__
  ...         return self.states[cpTypeName + '/' + name]

We register the state handler as an adapter.

  >>> ztapi.provideAdapter(IPortlet, IStateHandler, SimpleStateHandler)

In addition we need a portlet that wants to store its state in the state
handler. We provide the portlet with an interface thats specifies itself
content provider type.

  >>> class ISpecialPortlet(IPortlet):
  ...     pass

Content provider types must be of IContentProviderType so that they can be
recognized during adapter lookup:
  
  >>> directlyProvides(ISpecialPortlet, IContentProviderType)

  >>> class Portlet(object):
  ...     implements(ISpecialPortlet)

  >>> portlet = Portlet()

Now we can retrieve a state handler and store the state for the portlet;
note that we have to provide the name of the portlet in the portlet manager.

  >>> handler = zapi.getAdapter(portlet, IStateHandler)
  >>> handler.setState('visible', name='dummy.portlet')

Now we can retrieve the state again:

  >>> handler.getState(name='dummy.portlet')
  'visible'
  

Use user preferences for portlet state storage
----------------------------------------------

  >>> from zope.portlet.statehandler import PreferenceStateHandler
  >>> from zope.publisher.browser import TestRequest
  >>> from zope.publisher.browser import IBrowserRequest

  >>> ztapi.provideAdapter(IPortlet, IStateHandler, PreferenceStateHandler)

We need a principal to store preferences with and a corresponding interaction
to find it; and we have to register a PrincipalAnnotationUtility for this.

  >>> class Principal:
  ...     def __init__(self, id):
  ...         self.id = id
  >>> principal = Principal('zope.user')

  >>> class Participation:
  ...     interaction = None
  ...     def __init__(self, principal):
  ...         self.principal = principal

  >>> participation = Participation(principal)

  >>> import zope.security.management
  >>> zope.security.management.endInteraction()
  >>> zope.security.management.newInteraction(participation)

  >>> from zope.app.principalannotation.interfaces import IPrincipalAnnotationUtility
  >>> from zope.app.principalannotation import PrincipalAnnotationUtility
  >>> ztapi.provideUtility(IPrincipalAnnotationUtility, PrincipalAnnotationUtility())

So we are ready to store the portlet's state:

  >>> handler = zapi.getAdapter(portlet, IStateHandler)
  >>> isinstance(handler, PreferenceStateHandler)
  True
  >>> handler.setState('hidden', name='dummy.portlet')

And retrieve it:
  
  >>> handler.getState(name='dummy.portlet')
  'hidden'

If we use a value for the state that is not supported by the preference state
handler we get an exception:

  >>> handler.setState('exploded', name='dummy.portlet')
  Traceback (most recent call last):
  ...
  ConstraintNotSatisfied: exploded...
  
