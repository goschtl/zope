##############################################################################
#
# Copyright (c) 2005 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Common utilities used by the different parts of WebDAV.

$Id$
"""
__docformat__ = 'restructuredtext'

from xml.dom import minidom

from zope.interface import Interface, implements, Attribute
from zope.publisher.http import status_reasons
from zope.security.proxy import removeSecurityProxy

from zope import component
from zope.app.traversing.browser.absoluteurl import absoluteURL
from zope.app.container.interfaces import IReadContainer

################################################################################
#
# Common exceptions.
#
################################################################################

class DAVError(Exception):
    # override this value
    status = None

    def __init__(self, field_name, error_message):
        self.field_name = field_name
        self.error_message = error_message


class PreConditionFailedError(DAVError):
    """ """
    status = 412


class AlreadyLockedError(DAVError):
    """ """
    status = 423


class DAVConflictError(DAVError):
    """ """
    status = 409


class UnprocessableEntityError(DAVError):
    """ """
    status = 422


class ForbiddenError(DAVError):
    """ """
    status = 403


class BadDAVRequestError(DAVError):
    status = 400

    def __init__(self, error_message):
        self.field_name = None
        self.error_message = error_message

################################################################################
#
# Helper classes for generating MultiSatus responses.
#
################################################################################

class IMultiStatus(Interface):
    """ """

    body = Attribute(u"""
    The XML DOM Document representing the currently generated by ...
    """)

    def addResponse(object, request):
        """Maybe this should be addResource
        """


class IMultiStatusResponse(Interface):
    """ """

    def addPropertyByStatus(ns, ns_prefix, property, status = 200):
        """Insert the the property element into the current response in the
        correct propstat element specified by the status.
        """

    def createEmptyElement(ns, ns_prefix, name):
        """Create an empty `name' xml element within the specific namespace
        """


class MultiStatus(object):
    implements(IMultiStatus)

    def __init__(self):
        dns = self.default_ns = 'DAV:'
        body = self.body = minidom.Document()
        ms = self.ms = body.createElementNS(dns, 'multistatus')
        ms.setAttributeNS(dns, 'xmlns', dns)
        body.appendChild(ms)

    def appendResponse(self, response):
        """
        """
        self.ms.appendChild(self.body.importNode(response, True))

    def addResponse(self, object, request):
        """Return instance of MultiStatusResponse
        """
        body = self.body
        resp = body.createElementNS(self.default_ns, 'response')
        self.ms.appendChild(resp)
        href = body.createElementNS(self.default_ns, 'href')
        resp.appendChild(href)
        resource_url = absoluteURL(object, request)
        if IReadContainer.providedBy(object):
            resource_url += '/'
        href.appendChild(body.createTextNode(resource_url))

        return MultiStatusResponse(resp, self.default_ns)


class MultiStatusResponse(object):
    """Simple utility to simplfy the creatation and modification of a
    multistatus response.
    """
    implements(IMultiStatusResponse)

    def __init__(self, resp, default_ns):
        """ resp is the current response object to manage"""
        self.status = {}
        self.response = resp
        self.default_ns = default_ns

    def addPropertyByStatus(self, ns, ns_prefix, property, status = 200):
        """
        property is a DOM element that we want to add to the response. 

        namespace is a 2-tuple of attribute name - must be of the form
        xmlns:XXXX where XXXX is a string and the uri representing the
        namespacce.

        status is a integer representing the HTTP code for this property.
        """
        if property is None:
            raise TypeError, "the property xml.dom element must not be None"

        if self.status.has_key(status):
            prop = self.status[status]
        else:
            doc = self.response.ownerDocument

            propstat = doc.createElementNS(self.default_ns, 'propstat')
            self.response.appendChild(propstat)

            prop = doc.createElementNS(self.default_ns, 'prop')
            propstat.appendChild(prop)

            sprop = doc.createElementNS(self.default_ns, 'status')
            propstat.appendChild(sprop)
            sprop.appendChild(
                doc.createTextNode('HTTP/1.1 %d %s' %(status,
                                                      status_reasons[status])))
            self.status[status] = prop

        if ns is not None and ns_prefix is not None:
            xmlns = None
            if prop.attributes is not None:
                xmlns = prop.attributes.getNamedItemNS(ns,
                                                       'xmlns:%s' % ns_prefix)

            if xmlns is None:
                prop.setAttributeNS(ns, 'xmlns:%s' % ns_prefix, ns)

        if property is not None:
            ## The DAVOpaqueNamespace adapter security proxies the returned
            ## XML DOM Element. In this case remove the security proxy.

            ## This should be fixed by using a one of the DAV Widgets for
            ## opaque properties.
            property = removeSecurityProxy(property)

            prop.appendChild(
                prop.ownerDocument.importNode(property, True))

        return prop

    def createEmptyElement(self, ns, ns_prefix, name):
        """Create an empty `name' xml element within the specific namespace
        """
        el = self.response.ownerDocument.createElementNS(ns, name)
        if ns_prefix is not None:
            el.setAttributeNS(ns, 'xmlns', ns_prefix)
        return el

################################################################################
#
# WebDAV Request and Request Factory
#
################################################################################

from zope.publisher.http import HTTPResponse, HTTPRequest
from zope.app.publication.http import HTTPPublication
from zope.app.publication.interfaces import IRequestPublicationFactory
from interfaces import IWebDAVRequest, IWebDAVRequestFactory


class WebDAVResponse(HTTPResponse):
    """
    """
    pass


class WebDAVRequest(HTTPRequest):
    implements(IWebDAVRequest)

    def _createResponse(self):
        """Create a specific WebDAV response object."""
        return WebDAVResponse()


class WebDAVPublication(HTTPPublication):
    pass


class WebDAVRequestFactory(object):
    implements(IRequestPublicationFactory)

    def canHandle(self, environment):
        return True

    def __call__(self):
        request_class = component.queryUtility(
            IWebDAVRequestFactory, default = WebDAVRequest)
        return request_class, WebDAVPublication

################################################################################
#
# WebDAV specific traversal. Needed in order to generate null resources.
#
################################################################################

from zope.app.http import traversal
from zope.app.http.put import NullResource
from zope.publisher.interfaces import NotFound
from zope.app.http.interfaces import INullResource
from zope.app.container.interfaces import IContained
from zope.app.container.contained import Contained
from persistent import Persistent


class LockNullResource(Persistent, Contained):
    implements(INullResource, IContained)

    def __init__(self, container, name):
        # container is __parent__
        # name is __name__
        pass

    @property
    def container(self):
        return self.__parent__

    @property
    def name(self):
        return self.__name__


class ContainerTraverser(traversal.ContainerTraverser):

    def nullResource(self, request, name):
        if request.getTraversalStack():
            raise NotFound(self.context, name, request)

        if request.method == 'MKCOL':
            return NullResource(self.context, name)
        elif request.method == 'LOCK':
            lnr = LockNullResource(self.context, name)
            self.context[name] = lnr
            return lnr

        raise NotFound(self.context, name, request)


################################################################################
#
# Some XML help methods
#
################################################################################

def makeDOMStandalone(element):
    """Make a DOM Element Node standalone

    The DOM tree starting at element is copied to a new DOM tree where:

    - Any prefix used for the element namespace is removed from the element 
      and all attributes and decendant nodes.
    - Any other namespaces used on in the DOM tree is explcitly declared on
      the root element.
      
    So, if the root element to be transformed is defined with a prefix, that 
    prefix is removed from the whole tree:

      >>> dom = minidom.parseString('''<?xml version="1.0"?>
      ...      <foo xmlns:bar="http://bar.com">
      ...         <bar:spam><bar:eggs /></bar:spam>
      ...      </foo>''')
      >>> element = dom.documentElement.getElementsByTagName('bar:spam')[0]
      >>> standalone = makeDOMStandalone(element)
      >>> standalone.toxml()
      u'<spam><eggs/></spam>'

    Prefixes are of course also removed from attributes:

      >>> element.setAttributeNS(element.namespaceURI, 'bar:vikings', 
      ...                        'singing')
      >>> standalone = makeDOMStandalone(element)
      >>> standalone.toxml()
      u'<spam vikings="singing"><eggs/></spam>'

    Any other namespace used will be preserved, with the prefix definitions
    for these renamed and moved to the root element:

      >>> dom = minidom.parseString('''<?xml version="1.0"?>
      ...      <foo xmlns:bar="http://bar.com" xmlns:mp="uri://montypython">
      ...         <bar:spam>
      ...           <bar:eggs mp:song="vikings" />
      ...           <mp:holygrail xmlns:c="uri://castle">
      ...             <c:camelot place="silly" />
      ...           </mp:holygrail>
      ...           <lancelot xmlns="uri://montypython" />
      ...         </bar:spam>
      ...      </foo>''')
      >>> element = dom.documentElement.getElementsByTagName('bar:spam')[0]
      >>> standalone = makeDOMStandalone(element)
      >>> print standalone.toxml()
      <spam xmlns:p0="uri://montypython" xmlns:p1="uri://castle">
                <eggs p0:song="vikings"/>
                <p0:holygrail>
                  <p1:camelot place="silly"/>
                </p0:holygrail>
                <p0:lancelot/>
              </spam>
    """

    return DOMTransformer(element).makeStandalone()


def _numberGenerator(i=0):
    while True:
        yield i
        i += 1


class DOMTransformer(object):
    def __init__(self, el):
        self.source = el
        self.ns = el.namespaceURI
        self.prefix = el.prefix
        self.doc = minidom.getDOMImplementation().createDocument(
            self.ns, el.localName, None)
        self.dest = self.doc.documentElement
        self.prefixes = {}
        self._seq = _numberGenerator()

    def seq(self): return self._seq.next()
    seq = property(seq)

    def _prefixForURI(self, uri):
        if not uri or uri == self.ns:
            return ''
        if not self.prefixes.has_key(uri):
            self.prefixes[uri] = 'p%d' % self.seq
        return self.prefixes[uri] + ':'

    def makeStandalone(self):
        self._copyElement(self.source, self.dest)
        for ns, prefix in self.prefixes.items():
            self.dest.setAttribute('xmlns:%s' % prefix, ns)
        return self.dest

    def _copyElement(self, source, dest):
        for i in range(source.attributes.length):
            attr = source.attributes.item(i)
            if attr.prefix == 'xmlns' or attr.nodeName == 'xmlns':
                continue
            ns = attr.prefix and attr.namespaceURI or source.namespaceURI
            qname = attr.localName
            if ns != dest.namespaceURI:
                qname = '%s%s' % (self._prefixForURI(ns), qname)
            dest.setAttributeNS(ns, qname, attr.value)

        for node in source.childNodes:
            if node.nodeType == node.ELEMENT_NODE:
                ns = node.namespaceURI
                qname = '%s%s' % (self._prefixForURI(ns), node.localName)
                copy = self.doc.createElementNS(ns, qname)
                self._copyElement(node, copy)
            else:
                copy = self.doc.importNode(node, True)
            dest.appendChild(copy)
