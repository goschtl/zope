Context Decorators
==================

Issues
------

* How to decide what permssions to use for new methods introduced in
  the decorator?

Consider a ZopeContainerDecorator. It has a method 'rename' that does not
appear in IContainer. What permission should guard 'rename'?
'rename' depends on 'setObject' in IContainer. Different content components
protect 'setObject' with different permissions; for example,
zope.ManageContent or zope.ManageServices.
So, we can't guard 'rename' with one hard-coded permission.

What could we do instead?

- Reorder proxies, decorator outside the security proxy.
We could somehow re-order the proxies around an object so that the decorator
goes on the outside. This is awkward, as it breaks our invariant of putting
the security proxy always on the outside. There are also efficiency issues
if the interface-related descriptors are security-proxied.

- What protects rename should be what protects setObject.
We could declare that rename is to be protected with whatever protects the
'setObject' operation on the proxied object.
That makes the zcml more complex, and special for decorators.
That also makes the checker to use for decorators more complex and special.

- Rename gets proxied by magic in the decorator.
We could declare that rename is a special "untrusted" method, and cause
its 'self' argument to be bound not to the decorator instance, but to
some special object that is like the original decorator, but which wraps
a security-proxied object.

- Register decorators to classes rather than interfaces.
Security declarations are made by class, not by interface, so it makes sense
for a decorator that needs particular security declarations to be declared
for a class, and not an interface.
It is not possible, currently, to register an adapter for a class.
If it is made possible to do this, adapters registered for classes would
always trump those registered for interfaces.

