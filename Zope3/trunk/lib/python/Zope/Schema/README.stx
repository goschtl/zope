Zope 3 Schemas

Table of contents

 Short introduction

 Long introduction

 What is a schema, how does it compare to an interface and why should you care?

 What does a Schema look like 
 
 Where Schemas make sense: Providing views from Schemas 
 
 Issues to be solved 


Short introduction

 Schemas are like interfaces, but describing properties - rather thab methods:

  - Model the public information managed by the object.

  - An interface with fields.

  - Fields define attribute types, including value constraints, and documentation.

 Fields themselves are:
 
  - They provide a validate method for validating values

  - FieldProperties can automate validation at Python level.

Long introduction

  Zope 3 schemas were born when Jim Fulton and Martijn Faassen were thinking about Formulator for Zope3 and 
  PropertySets while at the Zope3 sprint at the Zope BBQ in Berlin. They realized that forms stripped of all logic to view them look suspiciously similar to Zope 3 interfaces. And thus schemas were born.

 What is a schema, how does it compare to an interface and why should you care?

  A schema is a definition of an object's properties, while interface is a definition of an object's methods. A property is an attribute of an object that is intended to be public; it is part of the interface of the object. While properties generally look and feel like normal attributes to the Python programmer, they are often implemented with a hidden getter and setter instead. In a way interface and schema look at the object from two different viewpoints.

  To make things more clear, let's compare schemas with normal Zope 3 interfaces. What are Zope 3 interfaces used for?

   o documentation: by writing an interface, we can tell programmers what methods are available for them to use, and provide documentation on what these methods do. Similarly, a class documents itself by advertising what interfaces it is implementing. Only publically available methods (useable by the programmer as well as other components) are advertised this way.

   o error checking: interfaces can do some minimal verification to see whether a class that advertises it implements methods with these names and signatures.

   o introspection: a programmer can check whether an object implements a certain interface. This allows robust and clear introspection.

   o component architecture: Zope 3's component architecture uses these introspection facilities to plug objects together by their interfaces. The component architecture can for instance be asked to supply an object with another interface (adapters) or end-user presentation (views).

  Schemas are used in much the same way, substituting property for method. What are schemas used for?

   o documentation: by writing a schema, we can tell programmers what public properties are available for them to use (get or set), and to provide documentation on what these properties are to be used for. Classes document themselves by advertising what schemas they are implementing.

   o error checking: schemas can do some minimal verification to see whether a class actually implements it (supplies these properties).

   o introspection: a programmer can check whether an object implements a certain schema.

   o component architecture: we can look up adapters and views for schemas; we could for instance have a view for the Dublin Core schema. In some senses we can do even more here than we can do with normal interfaces; we can in fact create objects that implement a schema, as we will see later.

What does a schema look like?

  How do you define Schema, much like one would define an interface, but it has fields instead of methods (Example from programmers tutorial):

      from Interface import Interface
      from Zope.Schema import Text, TextLine

      class IContact(Interface):
       "Provides access to basic contact information."

         first = TextLine(title=u"First name")
         last = TextLine(title=u"Last name")
         email = TextLine(title=u"Electronic mail address")
         address = Text(title=u"Postal address")
         postalCode = TextLine(title=u"Postal code",
                       constraint = re.compile("\d{5,5}(-\d{4,4})?$").match)

         def  name():
         """Gets the contact name.
        
         The contact name is the first and last name"""

  Now we need a class that implements this interface:

    class Contact (Persistence.Persistent):
    __implements__ = IContact

        def __init__(self, first='', last='', email='', address='', pc=''):
            self.first = first
            self.last = last
            self.email = email
            self.address = address
            self.postalCode = pc

        def name(self): 
            return "%s %s" % (self.first, self.last)


Where Schemas make sense: Providing views from Schemas

  Schemas, Fields, Widgets and Forms form a combination that can be used to provide views automaticly by Zope machinery. Example is provided in programmers tutorial, chapter 2.
  
  
     In View's configure.zcml is said:
     
    <form:edit
    schema=".IContact."
    name="edit.html"
    label="Edit contact information"
    permission="ZopeProducts.Contact.ManageContacts" 
    />
  
    And there is corresponding Schema.
 
    class IContact(Interface):
        "Provides access to basic contact information."

        first = TextLine(title=u"First name")
        last = TextLine(title=u"Last name")
        email = TextLine(title=u"Electronic mail address")
        address = Text(title=u"Postal address")
        postalCode = TextLine(title=u"Postal code",
                constraint=re.compile("\d{5,5}(-\d{4,4})?$").match)

        def name():
            """Gets the contact name.
        
            The contact name is the first and last name"""
 
  
  

Issues to be solved

 These issues were written up at Rotterdam Sprint
 
 Internalization
 
  How internalization is done in Schemas - and how internalization is taken care while designing a schema. Title and description need to be translated - as well as validation errors that happen. Idea is that the translation would happen in views - and views would have means to get to the Schema ids.
  
  Example:
  
  Class book(Interface):
  
     author = ITextLine()
     
  And in view, while the widget or widget's messages are constructed:
  
  TranslatorService.getMessage('book.author.title','DE_DE')   

References

 Jim Fulton's Programmers Tutorial, 
 in CVS Docs/ZopeComponentArchitecture/PythonProgrammerTutorial/Chapter2




