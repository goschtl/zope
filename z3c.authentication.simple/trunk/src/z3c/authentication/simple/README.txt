=============================
Simple Authentication Utility
=============================

The Simple Authentication Utility provides a framework for authenticating 
principals and associating information with them. It uses plugins and 
subscribers to get its work done.

For a simple authentication utility to be used, it should be registered as a
utility providing the `zope.app.security.interfaces.IAuthentication` interface.

Our target is to support a handy IAuthentication utility which offers a simple
API for custom IMember implementations.


Security
--------

The SimpleAuthentication supports unique id tokens for principals. This means 
principal that get deleted and again added with the same id, login etc. do
not have the same id again. We support this by generate a user id token
generated by the host id, timestamp, a random string and the login attribute.


What's different then in PluggableAuthentication
------------------------------------------------

We use a different pattern for IAuthenticatorPlugins in this implementation 
then used in PluggableAuthentication located in zope.app.authentication. 
Beacuse the pluggable authentication is not very handy when it comes to 
implement custom principal information. The IPrincipalInfo hook supporting 
not propagate the password of a IInternalPrincipal is droped in this 
implementation.

In our implementation we offer a IFoundPrincipal and IAuthenticatedPrincipal
which are implemented as adapters for a IMember. This adapters do not offer
it's context which is the real IMember.

The SimpleAuthentication doesn't use a prefix. The usage of a prefix is only
implemented in the IMemberContainer. 

We do not use a prefix in the IMemberContainer because of the used unique user 
id tokens. This will make sure that the same principal id doesn't get used at 
a later time (Common criteria). There is a ``add`` method which creates 
this id for you based on the login. The __setitem__ should not get used 
directly for adding IMember instances anymore. We heavily restricted the
usage of this method. See the inline doc tests in __setitem__ for more info.

The ICredentialsPlugin used in the IPluggableAuthentication are 100% 
compatible with our SimpleAuthentication implementation.


Authentication
==============

The primary job of SimpleAuthentication is to authenticate principals. It uses 
two types of plug-ins in its work:

  - Credentials Plugins

  - Authenticator Plugins

Credentials plugins are responsible for extracting user credentials from a
request. A credentials plugin may in some cases issue a 'challenge' to obtain
credentials. For example, a 'session' credentials plugin reads credentials
from a session (the "extraction"). If it cannot find credentials, it will
redirect the user to a login form in order to provide them (the "challenge").

Authenticator plugins are responsible for authenticating the credentials
extracted by a credentials plugin. They are also typically able to create
principal objects for credentials they successfully authenticate.

Given a request object, the SimpleAuthentication returns a principal object, 
if it can. The SimpleAutentication utility does this by first iterateing 
through its credentials plugins to obtain a set of credentials. If it gets 
credentials, it iterates through its authenticator plugins to authenticate 
them.

If an authenticator succeeds in authenticating a set of credentials, the 
SimpleAuthentication uses the authenticator to create a principal 
corresponding to the credentials. The authenticator notifies subscribers if 
an authenticated principal is created. Subscribers are responsible for adding 
data, especially groups, to the principal. Typically, if a subscriber adds 
data, it should also add corresponding interface declarations.


Principal
---------

First we create a principal:

  >>> from z3c.authentication.simple import interfaces
  >>> from z3c.authentication.simple.member import Member
  >>> login = u'bob'
  >>> password = u'secret'
  >>> title = u'Bob'
  >>> p = Member(login, password, title)

Such a principal provides the following attributes be default

  >>> p.login
  u'bob'

  >>> p.password
  u'secret'

  >>> p.title
  u'Bob'

and IMember:

  >>> interfaces.IMember.providedBy(p)
  True


Authenticator Plugin
--------------------

First setup a MemberContainer which will store the principals:

  >>> from z3c.authentication.simple.member import MemberContainer
  >>> authPlugin = MemberContainer()
  
Now we have a MemberContainer that provides a IMemberContainer:

  >>> interfaces.IMemberContainer.providedBy(authPlugin)
  True

Now we will add the created principal to the principal container using the 
containers method ``add``:

  >>> uid, member = authPlugin.add(p)

The method returns the member id and the member object. The id get generated
by the host IP address, the time, a random string and the member login attr.
This token should be unique and guranted that it never get generated twice.
This allows us to add, delete and add the same user again without that such a 
user will inherit existing permissions. We can test this token by compare it
only with the __name__ of the object in this test since the token will 
different every testrun.

  >>> member.__name__ == uid
  True

The returned member still is our previous added IMember

  >>> member is p
  True

  >>> len(member.__name__)
  32

  >>> member.login
  u'bob'

  >>> member.password
  u'secret'

  >>> member.title
  u'Bob'

let's register the MemberContainer as a named IAuthenticatorPlugin 
utility:

  >>> import zope.component
  >>> zope.component.provideUtility(authPlugin, 
  ...     provides=interfaces.IAuthenticatorPlugin, 
  ...     name='My Authenticator Plugin')
 

Credentials Plugin
------------------

After setup the member and member container, we'll create a simple 
credentials plugin:

  >>> import zope.interface
  >>> import zope.component
  >>> from zope.app.authentication.interfaces import ICredentialsPlugin

  >>> class MyCredentialsPlugin(object):
  ...
  ...     zope.interface.implements(ICredentialsPlugin)
  ...
  ...     def extractCredentials(self, request):
  ...         return {'login':request.get('login', ''), 
  ...                 'password':request.get('password', '')}
  ...
  ...     def challenge(self, request):
  ...         pass # challenge is a no-op for this plugin
  ...
  ...     def logout(self, request):
  ...         pass # logout is a no-op for this plugin

As a plugin, MyCredentialsPlugin needs to be registered as a named utility or
it could be stored in the SimpleAuthentication attribute credentialsPlugins.
Use the first and register the plugina utility:

  >>> myCredentialsPlugin = MyCredentialsPlugin()
  >>> zope.component.provideUtility(myCredentialsPlugin, 
  ...     name='My Credentials Plugin')


AuthenticatedPrincipal and FoundPrincipal
-----------------------------------------

While authenticator plugins provide member, they are not responsible
for creating principals. This function is performed by the 
SimpleAuthentication:

  >>> from z3c.authentication.simple.principal import AuthenticatedPrincipal
  >>> from z3c.authentication.simple.principal import FoundPrincipal
  >>> zope.component.provideAdapter(AuthenticatedPrincipal, 
  ...     provides=interfaces.IAuthenticatedPrincipal)

  >>> zope.component.provideAdapter(FoundPrincipal, 
  ...     provides=interfaces.IFoundPrincipal)


Configuring SimpleAuthentication
--------------------------------

Finally, we'll create the SimpleAuthentication itself:

  >>> from z3c.authentication.simple import authentication
  >>> sau = authentication.SimpleAuthentication()

and configure it with the two plugins:

  >>> sau.credentialsPlugins = ('My Credentials Plugin', )
  >>> sau.authenticatorPlugins = ('My Authenticator Plugin', )


Authenticate
------------

We can now use the SimpleAuthentication to authenticate a sample request:

  >>> from zope.publisher.browser import TestRequest
  >>> print sau.authenticate(TestRequest())
  None

In this case, we cannot authenticate an empty request. In the same way, we
will not be able to authenticate a request with the wrong credentials:

  >>> request = TestRequest(form={'login':'let me in!', 'password':'secret'})
  >>> print sau.authenticate(request)
  None

However, if we provide the proper credentials:

  >>> request = TestRequest(form={'login':'bob', 'password':'secret'})
  >>> bob = sau.authenticate(request)
  >>> bob
  <AuthenticatedPrincipal...>

  >>> interfaces.IAuthenticatedPrincipal.providedBy(bob)
  True

we get an authenticated principal.


Change login
------------

Change the login of a principal is a allwas a critical task because such a 
login together with a password is the key to our implemenation. Let's try to
change the login and check if everything is correct. We can do this by get the
principal from the MemberContainer and change the login on the IMember
implementation:

  >>> internal = authPlugin[bob.id]
  >>> internal.login = u'bob2'

Now we should be able to login with the new login:

  >>> request = TestRequest(form={'login':'bob2', 'password':'secret'})
  >>> bob2 = sau.authenticate(request)
  >>> bob2
  <AuthenticatedPrincipal ...>

  >>> bob2.title
  u'Bob'

But not with the old one:

  >>> request = TestRequest(form={'login':'bob', 'password':'secret'})
  >>> sau.authenticate(request) == None
  True

The member bob has still the same id as bob2 since the user id token doesn't 
get changed be changing the login:

  >>> bob.id == bob2.id
  True


Events
------

Authenticate principal will create events.

  >>> from zope.component.eventtesting import getEvents
  >>> from zope.component.eventtesting import clearEvents

We can verify that the appropriate event was published:

  >>> clearEvents()
  >>> request = TestRequest(form={'login':'bob2', 'password':'secret'})
  >>> bobAgain = sau.authenticate(request)

And the principal attribute in the event provides the authenticated principal:

  >>> [event] = getEvents(interfaces.IAuthenticatedPrincipalCreated)
  >>> event.principal is bobAgain
  True

  >>> event.principal
  <AuthenticatedPrincipal ...>

  >>> event.request is request
  True

The principal has the id, title, and description.

  >>> event.principal.title
  u'Bob'

  >>> event.principal.id == uid
  True

  >>> event.principal.description
  u''

We provide subscribers to these events that can be used for doing custom 
processing. Note, the principal attibute provides a IAuthenticatedPrincipal:

  >>> def addInfo(event):
  ...     id = event.principal.id
  ...     event.principal.description = 'Description for: %s' % id

  >>> zope.component.provideHandler(addInfo, 
  ...     [interfaces.IAuthenticatedPrincipalCreated])

Now, if we authenticate a principal, its description is set:

  >>> principal = sau.authenticate(request)
  >>> principal.description
  u'Description for: ...'


Customization
-------------

Let's show you how the existing pattern can get used in a real use case. In 
the next sample we like to provide a additional email attribute for principals.
First we have to define the interfaces declaring the email attribute:

  >>> class IMyEmail(zope.interface.Interface):
  ...     email = zope.schema.TextLine(
  ...         title=u'EMail', 
  ...         description=u'The EMail')

  >>> class IMyMember(IMyEmail, interfaces.IMember):
  ...     """Custom IMember interface."""

  >>> class IMyFoundPrincipal(IMyEmail, interfaces.IFoundPrincipal):
  ...     """Custom IIMyFoundrincipal interface."""

  >>> class IMyAuthenticatedPrincipal(IMyEmail, 
  ...     interfaces.IAuthenticatedPrincipal):
  ...     """Custom IAuthenticatedPrincipal interface."""

After the schema, we define a custom principal implementation implementing 
this interface:

  >>> class MyMember(Member):
  ...     zope.interface.implements(IMyMember)
  ...     def __init__(self, login, password, title, description, email):
  ...         super(MyMember, self).__init__(login, password, title, 
  ...                                           description)
  ...         self.email = email

Now we have to define the AuthenticatedPrincipal for MyMember:

  >>> class MyAuthenticatedPrincipal(AuthenticatedPrincipal):
  ...     zope.interface.implements(IMyAuthenticatedPrincipal)
  ...     def __init__(self, principal):
  ...         super(MyAuthenticatedPrincipal, self).__init__(principal)
  ...         self.email = principal.email

And we have to define the FoundPrincipal for MyMember:

  >>> class MyFoundPrincipal(FoundPrincipal):
  ...     zope.interface.implements(IMyFoundPrincipal)
  ...     def __init__(self, principal):
  ...         super(MyFoundPrincipal, self).__init__(principal)
  ...         self.email = principal.email

Note that you can provide different attributes for the found and authenticated
principal if needed. That's up to you what you like to do with this attributes 
later.

Now we need to register our custom authenticated and found principal as 
adapters:

  >>> zope.component.provideAdapter(MyAuthenticatedPrincipal, 
  ...     provides=interfaces.IAuthenticatedPrincipal)

  >>> zope.component.provideAdapter(MyFoundPrincipal, 
  ...     provides=interfaces.IFoundPrincipal)

Now we can use them without any other event subscriber or other registration
in our principal container. Let's add a principal tho this container:

  >>> p = MyMember(u'max', u'password', u'Max', u'', u'max@foobar.com')
  >>> token, max = authPlugin.add(p)
  >>> len(token)
  32

  >>> max.__name__ == token
  True

  >>> max.password
  u'password'

  >>> max.title
  u'Max'

  >>> max.email
  u'max@foobar.com'

Let's try to authenticate...

  >>> request = TestRequest(form={'login':'max', 'password':'password'})
  >>> authenticated = sau.authenticate(request)

and check your authenticated principal:

  >>> interfaces.IAuthenticatedPrincipal.providedBy(authenticated)
  True

  >>> authenticated
  <MyAuthenticatedPrincipal ...>

  >>> authenticated.id == token
  True

  >>> authenticated.email
  u'max@foobar.com'
