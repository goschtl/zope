##############################################################################
#
# Copyright (c) 2009 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Tools for filtering a pickle opcode stream (as generated by
pickletools.genops) and reassemblying the pickle.
"""

import ZODB
import sys
import struct
import pickle
import pickletools
import StringIO

# The following functions were created on the basis of the code found in
# pickle.py. They reflect all opcodes that pickle knows about and how they get
# written to the output stream under the knowledge how pickletools.genops
# parses the opcode arguments.

packi = lambda arg:struct.pack('<i', arg)
reprn = lambda arg:repr(arg)+'\n'
strn = lambda arg:str(arg)+'\n'
fact_ref = lambda arg:arg.replace(' ','\n')+'\n'
arg_len = lambda arg:packi(len(arg))+arg
unicode_escape = lambda arg:arg.replace('\\', '\\u005c').replace('\n', '\\u000a').encode('raw-unicode-escape')+'\n'

noargs = '().NQR]abdeostu}l\x81\x85\x86\x87\x88\x89210'
generators = {
    'G': lambda arg:struct.pack('>d', arg),
    'I': lambda arg:reprn(arg) if type(arg) is int else '0%s\n' % int(arg),
    'J': packi,
    'K': chr,
    'L': reprn,
    'M': lambda arg:"%c%c" % (arg&0xff, arg>>8),
    'S': reprn,
    'T': arg_len,
    'U': lambda arg:chr(len(arg)) + arg,
    'X': lambda arg:arg_len(arg.encode('utf-8')),
    'c': fact_ref,
    'i': fact_ref,
    'h': chr,
    'j': packi,
    'p': reprn,
    'g': reprn,
    'q': chr,
    'r': packi,
    'P': strn,
    'V': unicode_escape,
    '\x80': chr,
    '\x82': chr,
    '\x83': lambda arg:"%c%c" % (arg&0xff, arg>>8),
    '\x84': packi,
    '\x8a': lambda arg:chr(len(pickle.encode_long(arg)))+pickle.encode_long(arg),
    '\x8b': lambda arg:arg_len(pickle.encode_long(arg)),
}


def to_pickle_chunk(op, arg):
    """Transform an operation and its argument into pickle format."""
    chunk = op.code
    if op.code in noargs:
        pass
    elif op.code in generators:
        generated = generators[op.code](arg)
        chunk += generated
    else:
        raise ValueError('Unknown opcode: %s')
    return chunk


def filter(f, pickle_data):
    """Apply filter function to each opcode of a pickle, return new pickle.

    Calls function for each opcode with the arguments (code, arg) as created
    by the pickletools.genops function. 

    The filter function is expected to return a new (code, arg) tuple or None
    which causes the old (code, arg) tuple to be placed into the stream again.

    """
    new = StringIO.StringIO()
    for op, arg, pos in pickletools.genops(p):
        result = f(op, arg)
        op, arg = result if result is not None else op, arg
        new.write(to_pickle_chunk(op, arg))
    return new.getvalue()
