======================
Cached Viewlet Manager
======================

We provide a viewlet manager which is able to handle the view cache of his
viewlets.

  >>> from lovely.viewcache.manager import CachedViewletManager

  >>> from zope.app.container.contained import Contained
  >>> from zope import interface
  >>> class IContent(interface.Interface):
  ...     pass
  >>> class Content(Contained):
  ...     interface.implements(IContent)
  >>> content = Content()
  >>> root[u'content'] = content

  >>> from zope.publisher.browser import TestRequest
  >>> request = TestRequest() 

  >>> from zope.publisher.interfaces.browser import IBrowserView
  >>> class View(object):
  ...     interface.implements(IBrowserView)
  ...     def __init__(self, context, request):
  ...         self.context = context
  ...         self.request = request

  >>> view = View(content, request)

We use the update/render pattern to render the manager. We get no result
because no viewlet is registered for the manager.

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> manager.render()
  u''

Now we provide a viewlet and register it for out manager.

  >>> count = 0
  >>> from lovely.viewcache.interfaces import ICachedViewletManager
  >>> from lovely.viewcache.mixin import CachableViewMixin
  >>> from zope.viewlet.viewlet import ViewletBase
  >>> class TestViewlet(ViewletBase, CachableViewMixin):
  ...     staticCachingDeps = (1,)
  ...     def render(self):
  ...         global count
  ...         count += 1
  ...         return 'From TestViewlet %s'% count
  >>> from zope.security.checker import NamesChecker, defineChecker
  >>> viewletChecker = NamesChecker(('update', 'render'))
  >>> defineChecker(TestViewlet, viewletChecker)

  >>> from zope import component
  >>> from zope.viewlet.interfaces import IViewlet
  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer
  >>> component.provideAdapter(TestViewlet,
  ...                          adapts=(IContent, IDefaultBrowserLayer,
  ...                                  IBrowserView, ICachedViewletManager),
  ...                          provides=IViewlet,
  ...                          name='test1')

Using the manager again renders the new viewlet.

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> manager.render()
  u'From TestViewlet 1'

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> manager.render()
  u'From TestViewlet 2'

We still do not get the viewlet from the cache. This is because we didn't
provide a cache for the manager. We provide a simple ram cache here.

  >>> from lovely.viewcache.ram import ViewCache
  >>> from lovely.viewcache.interfaces import IViewCache
  >>> cache = ViewCache()
  >>> component.provideUtility(cache, IViewCache)

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> manager.render()
  u'From TestViewlet 3'

Yipee, we got it.

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> manager.render()
  u'From TestViewlet 3'

  >>> component.provideAdapter(TestViewlet,
  ...                          adapts=(IContent, IDefaultBrowserLayer,
  ...                                  IBrowserView, ICachedViewletManager),
  ...                          provides=IViewlet,
  ...                          name='test2')

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  From TestViewlet 3
  From TestViewlet 4


Viewlet Providing A Key For The Cache
-------------------------------------

The viewlet can provide a key to discriminate on internal values.

  >>> class SelectiveViewlet(ViewletBase, CachableViewMixin):
  ...     @property
  ...     def key(self):
  ...         return str(self.request['selector'])
  ...     def update(self):
  ...         self.dynamicCachingDeps = (self.request['selector'],)
  ...     def render(self):
  ...         global count
  ...         count += 1
  ...         return u'%s (selector = %s)'% (count, self.request['selector'])
  >>> viewletChecker = NamesChecker(('update', 'render'))
  >>> defineChecker(SelectiveViewlet, viewletChecker)
  >>> component.provideAdapter(SelectiveViewlet,
  ...                          adapts=(IContent, IDefaultBrowserLayer,
  ...                                  IBrowserView, ICachedViewletManager),
  ...                          provides=IViewlet,
  ...                          name='selector')

  >>> request.form['selector'] = 1
  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  5 (selector = 1)
  ...

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  5 (selector = 1)
  ...

Changing the selector must render the viewlet again.

  >>> request.form['selector'] = 2
  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  6 (selector = 2)
  ...

The request with selector 1 is still in the cache.

  >>> request.form['selector'] = 1
  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  5 (selector = 1)
  ...


Invalidating Cache Entries
--------------------------

  >>> cache.invalidate(dependencies=(1,))

  >>> request.form['selector'] = 1
  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  7 (selector = 1)
  ...


Dynamically disabling the cache
-------------------------------

A view can disable caching using the 'cachingOn' property.

  >>> class CacheSwitchingViewlet(ViewletBase, CachableViewMixin):
  ...     @property
  ...     def cachingOn(self):
  ...         return 'cacheMe' in self.request
  ...     def render(self):
  ...         global count
  ...         count += 1
  ...         return u'%s (cacheMe = %s)'% (
  ...                       count, self.request.get('cacheMe', False))
  >>> viewletChecker = NamesChecker(('update', 'render'))
  >>> defineChecker(CacheSwitchingViewlet, viewletChecker)
  >>> component.provideAdapter(CacheSwitchingViewlet,
  ...                          adapts=(IContent, IDefaultBrowserLayer,
  ...                                  IBrowserView, ICachedViewletManager),
  ...                          provides=IViewlet,
  ...                          name='cacheSwitchin')

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  10 (cacheMe = False)
  ...

As long as we do not provide 'cacheMe' in the reqeust the viewlet is not
cached.

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  11 (cacheMe = False)
  ...

Now the first call with 'cacheMe' set in the reqeust will render it and stores
the render view in the cache.

  >>> request.form['cacheMe'] = 1
  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  12 (cacheMe = 1)
  ...

Now we get the cached result.

  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  12 (cacheMe = 1)
  ...

Removing the 'cacheMe' property will render the view.

  >>> del request.form['cacheMe']
  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  13 (cacheMe = False)
  ...

Setting 'cacheMe' again takes the existing cache entry.

  >>> request.form['cacheMe'] = 1
  >>> manager = CachedViewletManager(content, request, view)
  >>> manager.update()
  >>> print manager.render()
  12 (cacheMe = 1)
  ...


Configurator
------------

We also provide a configurator to register a view cache on a site.

  >>> from lovely.viewcache.configurator import RAMViewCacheConfigurator
  >>> RAMViewCacheConfigurator(root)(None)
  >>> sm = root.getSiteManager()
  >>> 'view-cache-RAM' in sm['default']
  True
  >>> component.getUtility(IViewCache) is not None
  True

