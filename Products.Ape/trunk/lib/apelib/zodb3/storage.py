##############################################################################
#
# Copyright (c) 2002 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.0 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Storage implementation that loads/stores using Ape mappers.

$Id$
"""

import md5
from cPickle import Pickler, Unpickler
from cStringIO import StringIO

from ZODB import POSException, BaseStorage

from apelib.core.io import GatewayIO
from consts import HASH0, HASH1
from interfaces import IResourceAccess


class ApeStorage(BaseStorage.BaseStorage):

    def __init__(self, conf_resource, connections, name='', clear_all=0,
                 debug_conflicts=0):
        """Initializes an ApeStorage.

        conf_resource is a resource for loading the IMapperConfiguration.
        connections is a mapping that maps names to ITPCConnections.
        """
        assert IResourceAccess.isImplementedBy(conf_resource)
        self.conf_resource = conf_resource
        gwio = GatewayIO(conf_resource.access(self), connections)
        self._gwio = gwio
        self._conn_list = gwio.get_connection_list()
        gwio.open_connections()
        self.init_databases(clear_all)
        names = []
        sort_keys = []
        for c in gwio.get_connection_list():
            names.append(c.getName())
            sort_keys.append(c.sortKey())
        self._sort_key = tuple(sort_keys)
        if not name:
            name = 'ApeStorage: ' + ', '.join(names)
        self._ltid = None
        self.scanner = None
        self.changed = {}  # {tid: {oid: 1}}
        self.set_debug_conflicts(debug_conflicts)
        BaseStorage.BaseStorage.__init__(self, name)

    def __len__(self):
        return 1

    def getSize(self):
        # Stub
        return 1

    def sortKey(self):
        return self._sort_key

    def getTransactionId(self):
        if hasattr(self, '_tid'):
            return self._tid
        return self._serial

    def init_databases(self, clear_all=0):
        self._gwio.init_databases(clear_all=clear_all)
        for c in self._conn_list:
            c.vote()
            c.finishWrite()
            c.finishCommit()

    def set_debug_conflicts(self, debug_conflicts):
        self.debug_conflicts = debug_conflicts
        if debug_conflicts:
            self._loaded_hashes = {}  # {oid: hash}

    def hash64(self, value):
        """Returns an 8-byte hash value.
        """
        v = hash(value)
        if v < -2L ** 32:
            # This is a hash on a 64-bit machine. Treat as unsigned
            # 64-bit integer
            v += 2L ** 64
        elif v < 0:
            # This is a hash on a 32-bit machine. Treat as an unsigned
            # 32-bit integer
            v += 2L ** 32
        if v > 2L ** 32:
            # This still is a hash on 64-bit machine. Compress to 32-bit.
            v = v / 2 ** 32

        assert v >= 0 and v <= 2L ** 32

        h = '%08x' % v
        if h == HASH0:
            # Avoid the special zero hash.
            h = HASH1
        return h

    def load(self, oid, version):
        if version:
            raise POSException.Unsupported, "Versions aren't supported"
        self._lock_acquire()
        try:
            self.conf_resource.access(self)  # Update configuration
            event, classification, state, hash_value = self._gwio.load(oid)
            file = StringIO()
            p = Pickler(file)
            p.dump(classification)
            p.dump(state)
            data = file.getvalue()
            h = self.hash64(hash_value)
            if self.debug_conflicts:
                self._loaded_hashes[oid] = hash_value
            if self.scanner is not None:
                sources = event.mapper.gateway.get_sources(event)
                self.scanner.after_load(oid, sources)
            return data, h
        finally:
            self._lock_release()

    def store(self, oid, h64, data, version, transaction):
        if transaction is not self._transaction:
            raise POSException.StorageTransactionError(self, transaction)

        if version:
            raise POSException.Unsupported, "Versions aren't supported"

        self._lock_acquire()
        try:
            self.conf_resource.access(self)  # Update configuration

            # First detect conflicts.
            # The "h64" argument, if its value is not 0,
            # was previously generated by hash64().
            if h64 == HASH0:
                # Writing a new object.
                is_new = True
            else:
                # Overwriting an old object.  Use the hash to verify
                # that the new data was derived from the old data.
                is_new = False
                event, old_c, old_state, old_hash = self._gwio.load(oid)
                old_h64 = self.hash64(old_hash)
                if h64 != old_h64:
                    h = None
                    if self.debug_conflicts:
                        h = self._loaded_hashes.get(oid)
                    if h is None:
                        h = h64
                        old_hash = old_h64
                    error = ("Storing %s based on old data.  %s != %s." % (
                        repr(oid), repr(h), repr(old_hash)))
                    if self.debug_conflicts:
                        # Expose the error for debugging..
                        raise RuntimeError(error)
                    else:
                        # Use normal ZODB conflict errors.
                        raise POSException.ConflictError(error)

            # Now unpickle and store the data.
            file = StringIO(data)
            u = Unpickler(file)
            classification = u.load()
            state = u.load()
            event, new_hash = self._gwio.store(
                oid, classification, state, is_new)
            new_h64 = self.hash64(new_hash)
            if self.debug_conflicts:
                self._loaded_hashes[oid] = new_hash

            # Remember that this OID changed (for scanning)
            tid = self.getTransactionId()
            t = self.changed.get(tid)
            if t is None:
                t = {}
                self.changed[tid] = t
            t[oid] = 1
        finally:
            self._lock_release()

        return new_h64

    def get_all_sources(self, oids):
        self._lock_acquire()
        try:
            res = {}
            for oid in oids:
                res[oid] = self._gwio.get_sources(oid)
            return res
        finally:
            self._lock_release()

    def new_oid(self):
        return self._gwio.new_oid()

    def lastTransaction(self):
        return self._ltid

    def _clear_temp(self):
        pass

    def _abort(self):
        for c in self._conn_list:
            c.abort()
        tid = self.getTransactionId()
        if self.changed.has_key(tid):
            del self.changed[tid]

    def _begin(self, tid, u, d, e):
        for c in self._conn_list:
            c.begin()

    def _finish(self, tid, user, desc, ext):
        for c in self._conn_list:
            c.finishWrite()
        tid = self.getTransactionId()
        self._ltid = tid
        if self.changed.has_key(tid):
            oids = self.changed[tid]
            del self.changed[tid]
            if self.scanner:
                for oid in oids.keys():
                    sources = self._gwio.get_sources(oid)
                    self.scanner.changed_sources(oid, sources)
        for c in self._conn_list:
            c.finishCommit()

    def _vote(self):
        for c in self._conn_list:
            c.vote()

    def pack(self, t, referencesf):
        pass

    def _splat(self):
        """Spit out a string showing state.
        """
        return ''

    def close(self):
        for c in self._conn_list:
            c.close()
        self.conf_resource.release(self)
