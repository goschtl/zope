
--------------------------------------------------
Notes for moving the Connection class to ZODB 3.4+
--------------------------------------------------

At the heart of Connection is an ObjectSystemIO object.  (See
apelib.core.io.)  ObjectSystemIO and all of the objects it calls upon
are intended to be potentially reusable with other persistence
frameworks.  Connection is not.

- _setDB(): this is purely for background scanning, but I want to make all
scanning external, so this override should go away.

- _prepare_root(): this creates the root PersistentMapping if it doesn't
exist.  It does it in a more modular way than standard ZODB.  Keep it.

- root(): Ape allows the configured OID generator to choose the root
OID, rather than assume the root is ('\0' * 8).  However, note that
both _prepare_root() and root() have the same logic for determining
the root OID.  If that logic is moved into a separate method, perhaps
root_oid(), _prepare_root() and root() will no longer have
dependencies on Ape and they can move into ZODB.

- _get_osio(): Returns the ObjectSystemIO for use by other methods.
The resource stuff is in there to allow the object mapping to change
without restarting the process.  This was an early idea that never
took off, and today I doubt it would be safe (or even useful) to
change mappings mid-process.  We should rip out the resource
indirection.

- close(): if you rip out the resource indirection, Ape doesn't need to
override close().

- __getitem__(): the only thing different from ZODB is the way we load
the pickle.  Note that pickles in Ape have a slightly different format
from standard ZODB.  ZODB pickles consist of two pickles: a tuple
about the object's class, then the object's state.  Ape also stores
two pickles, but the first pickle is a dictionary containing
classification information and the second pickle is the output of the
object's serializer.  ZODB pickles normally contain inter-object
references, but Ape pickles do not; instead, the serializer converts
inter-object references into normal data that's easy to pickle and
unpickle.  (The line that sets unpickler.persistent_load is commented
out because Ape doesn't expect the pickle to have persistent
references.)

Note that in theory, the connection doesn't really need to pickle or
unpickle.  Everything the connection pickles is immediately unpickled
by the storage.  Also, when loading objects, the storage pickles
object data just before the connection unpickles it.  Ape does this
for two reasons: to conform with the existing storage interface, which
expects pickles, and for ZEO compatibility.  ZEO is important, so Ape
should continue to pickle, but eventually I'd like a mode that doesn't
bother pickling when ZEO is not involved.  Ape might get a little
speed boost.

- _persistent_load(): this has an optimization similar to the one in
standard ZODB.  In standard ZODB, the OID passed to _persistent_load
can be either a string or a tuple; if it's a tuple, ZODB can usually
infer the object's class without actually loading the object, saving a
lot of time.  In Ape, the OID is always a string, but sometimes
serializers pass a second argument to the get() method (which is an
alias for _persistent_load.)  get() is documented in
apelib.core.interfaces.IObjectDatabase.  We should rename
_persistent_load() to get().

- _may_begin(): an artifact for retaining compatibility with older
ZODBs.  Get rid of it.

- commit(): ZODB needs a lot more hooks in commit().  I hope the
latest ZODB has more hooks.  Most of commit() is copied.

  - assert oid != 'unmanaged': a safety measure that's worth
  discussing.  Normal ZODB classifies objects stored in the database
  in two ways: either the object's class subclasses Persistent,
  meaning the object will be stored in its own database record, or the
  object's class does not subclass Persistent, meaning the object will
  be stored inside some other object's database record.  Ape
  introduces a third classification: objects that subclass Persistent,
  but whose mapper decides to store the object inside another record
  anyway.  Ape calls these objects unmanaged persistent objects
  (UPOs), and their _p_oid is always "unmanaged".  Also, each of them
  have their own private _p_jar.  Therefore, this commit() method
  should never see UPOs, but badly behaved application code can mix
  things up, and we don't want to choke.

  - The line that sets pickler.persistent_id is commented out because,
  again, Ape doesn't store inter-object references this way.
  Serializers handle inter-object references.

  (skip lots of copied code)

  - Ape replaces the __getstate__ call with a call to
  ObjectSystemIO.serialize().  Then, for each external reference
  generated by the serializers, it tries to find that object in
  self._cache.  If it's not in the cache, commit() assigns an OID to
  the object and queues the object for commit.  Also, it verifies the
  reference doesn't conflict with some other object already in the
  cache, and it ensures the object isn't in another _p_jar.  (The last
  part of the logic may change when the new database mount machinery
  lands.)

  - If the serialization work generated UPOs, commit() calls
  _handle_unmanaged.  _handle_unmanaged sets the _p_jar for each UPO.
  The special _p_jar enables Ape to store the containing object when
  one of its contained UPOs changes.

  (more copied code)

  - The call to _handle_serial is important.  See below.

- setstate(): Also needs more hooks.  Mostly copied, except the
middle.  As before, ZODB pickles have a class tuple followed by a
class dictionary, while Ape pickles have a classification dictionary
followed by an object state to be fed to the serializer.
ObjectSystemIO encapsulates most of the work.  Don't forget to call
_handle_unmanaged if the serializers saw UPOs while they were loading
the objects.

- register(): Unlike standard Connection, Ape can't deal with an attempt
to store an object with no _p_oid.  Ape needs to know the object's
lineage.  For example, if a Folder is contained in a UserFolder, a
mapper can choose to store the Folder differently than if it's
contained in an Application object.  Therefore, Ape ignores attempts
to store an object with no _p_oid.  In the future, it probably should
raise an exception, but some Zope code will need to be changed first.

- get(), identify(), and new_oid(): implementation of IObjectSystem.

check_serials(): for debugging.  It scans the cache for objects whose
state is not 100% consistent with the database.  I don't think
anything calls it.

- before_load(): registers self in the transaction, ensuring that this
Connection participates in the transaction even if no objects change.
Normal ZODB registers objects in the transaction only when they
change.  __getitem__(), setstate(), and check_serials call this.
before_load() was added only recently.  Until it was added, Ape left
RDBMS connections open without committing or aborting the transaction.
I was initially concerned this solution would cause a performance hit,
but the extra transactions made no apparent difference to the old,
slow computer that runs my web site. :-)

- tpc_abort(), tpc_finish(): hooks to reset the loaded_objects flag.
The loaded_objects flag only exists because there isn't a way to ask
the transaction whether some object (self in particular) is already
registered in the transaction, and registering self more than once
consumes resources.  So Connection remembers for itself whether it has
registered itself.  This may actually be a good pattern to keep, but I
think the attribute could have a better name.

- exportFile(), importFile(): gotta get around to this. :-)

- _get_serial, _set_serial, _handle_serial: ZODB has an ugly
optimization that's really hard for Ape to deal with.  _p_serial
attributes are required to have exactly 8 characters, and _p_mtime is
derived from _p_serial.  ZODB uses _p_serial for three separate pieces
of information:

  - if _p_serial is '\0' * 8, the object is new.  Otherwise the object
  has been stored before.

  - _p_serial is used for conflict detection.  If the connection wants
  to replace an object in the database, the connection is required to
  provide the _p_serial of the object's previous state.  If the old
  _p_serial doesn't match, apparently some other connection modified
  the object concurrently and the conflict needs to be resolved or the
  transaction aborted.

  - _p_serial is used for storing the time the object was last modified.

The first and second meanings fit together, but Ape distinguishes the
first two meanings from the third.  Ape frequently can't know exactly
when an object was last modified, and even when it does, that
information isn't always reliable.  So Ape instead uses a hash of the
object's state for conflict detection.  Ape's storage layer squeezes
the state hash into 64 bits and calls that the serial.

Ape also needs to provide _p_mtime for applications that depend on it.
The only way to provide _p_mtime is to set _p_serial.  So Ape fakes
_p_mtime by setting _p_serial.  Then it stores all of the real serials
in the connection's _serials attribute.

The _p_serial mess would disappear if ZODB separated _p_serial and
_p_mtime into independent fields and allowed _p_serial to contain an
arbitrary object.

- UnmanagedJar class: every UPO has one of these for its _p_jar.
real_jar and real_oid are the connection and oid of the Persistent
object that contains the UPO.  The register() method is the important
method; it causes the container of the UPO to be stored when the UPO
changes.

Also, UnmanagedJar preserves the object's state.  This class would not
have to bother with saving the object's state if it weren't for the
fact that some applications try to release memory by setting
obj._p_changed = None, telling the Persistent base class to clear the
object's __dict__.  If the object is a UPO, releasing its state is a
problem: if the containing object is changed when the UPO state is
gone, the containing object's state will be incomplete (since its
state is supposed to include the state of the UPO.)  Therefore,
UnmanagedJar preserves the UPO's state in itself.  It would be much
better, though, to be able to really prevent UPOs from being ghosted.
The current C code assumes that objects with a _p_jar and _p_oid are
always eligible for ghosting.

