===================
 Multiform Actions
===================

The multiform package defines a new type of action called
ParentAction. A parent action is rendered only one time in the parent
multiform, but applied to all subforms.

In this example we create a specialized item form class, which defines
a new parent action called ``Save``. Additionally two standard actions
are defined in the multiform (parent) class called ``Edit`` and
``Cancel```.

    >>> from zope import interface, schema
    >>> from zope.formlib import form
    >>> from zope.publisher.browser import TestRequest
    >>> from zope.app.form.interfaces import IInputWidget
    >>> from zope.location.interfaces import ILocation
    >>> from z3c.multiform import multiform
    >>> from z3c.multiform.multiform import ItemFormBase,MultiFormBase
    >>> from zope.app.i18n import ZopeMessageFactory as _

    >>> class IOrder(interface.Interface):
    ...     identifier = schema.Int(title=u"Identifier", readonly=True)
    ...     name = schema.TextLine(title=u"Name")
    >>> class Order:
    ...     interface.implements(IOrder,ILocation)
    ...
    ...     def __init__(self, identifier, name=''):
    ...         self.identifier = identifier
    ...         self.name = name
    ...         self.__name__= name

    >>> orderMapping = dict([('n%s'%k,Order(k,name='n%s'%k)) for k in range(2)])

    >>> class OrderForm(ItemFormBase):
    ...     inputMode=False
    ...     form_fields = form.Fields(IOrder,omit_readonly=False,
    ...         render_context=True)
    ...     
    ...     @multiform.parentAction(_(u"Save"),
    ...     condition=multiform.anySubFormInputMode,inputMode=True)
    ...     def handle_save_action(self, action, data):
    ...         form.applyChanges(self.context, self.form_fields,
    ...         data, self.adapters)
    ...         self.newInputMode = False
    ...         
    ...     @form.action(u"Upper", condition=multiform.allSubFormsDisplayMode)
    ...     def handle_uppercase_action(self, action, data):
    ...			self.context.name = self.context.name.upper()
    ...			
    ...     def template(self):
    ...         return '\n<div>%s</div>\n' % '</div><div>'.join([w() for w in
    ...     self.widgets] + [action.render() for action in 
    ...     self.availableActions()])


    >>> class OrdersForm(MultiFormBase):
    ...     itemFormFactory=OrderForm
    ...     def template(self):
    ...         res = u''
    ...         names = sorted(self.subForms.keys())
    ...         for name in names:
    ...             res += '<div>%s</div>\n' % self.subForms[name].render()
    ...         for action in self.availableActions():
    ...             res += '<div>%s</div>\n' % action.render()
    ...         for action in self.availableSubActions():
    ...             res += '<div>%s</div>\n' % action.render()
    ...         return res
    ...     
    ...     @form.action('Edit',condition=multiform.allSubFormsDisplayMode)
    ...     def handle_edit_action(self, action, data):
    ...         for form in self.subForms.values():
    ...             form.newInputMode = True
    ...         
    ...     @form.action('Cancel',condition=multiform.anySubFormInputMode)
    ...     def handle_cancel_action(self, action, data):
    ...         for form in self.subForms.values():
    ...             form.newInputMode = False


So in our new form all widgets are display widgets per default

    >>> request = TestRequest()
    >>> pf = OrdersForm(orderMapping,request)
    >>> print pf()
    <div>
    <div>0</div><div>n0</div>...<input...name="form.sf.n0.actions.upper"...
    </div>
    <div>
    <div>1</div><div>n1</div>...<input...name="form.sf.n1.actions.upper"...
    </div>
    <div><input...name="form.actions.edit"...</div>

And the save action should not be available, due to the reason that there
are no input widgets in the sub forms.

    >>> pf.subActionNames
    []
    >>> [action.__name__ for action in pf.availableActions()]
    [u'form.actions.edit']

Now let's call the edit action to set the widgets to input widgets.

    >>> request.form['form.actions.edit']=u''
    >>> pf =  OrdersForm(orderMapping,request)
    >>> print pf()
    <div>
    <div...<input class="textType" ... value="n0"...
    </div>
    <div>
    <div...<input class="textType" ... value="n1"...
    <div><input...name="form.actions.cancel"...</div>
    <div><input...name="form.actions.save"...</div>
    
Now the save action should be available in the subActionNames and
the cancel action in the multiform actions.

    >>> pf.subActionNames
    [u'form.actions.save']
    >>> [a.__name__ for a in pf.availableActions()]
    [u'form.actions.cancel']


Now Let us save some data.

    >>> request = TestRequest()
    >>> request.form['form.actions.save']=u''
    >>> for i in range(2):
    ...     request.form['form.sf.n%s.name' % i]='newer name %s' % i
    ...     request.form['form.sf.n%s.identifier' % i]= i
    >>> pf =  OrdersForm(orderMapping,request)
    >>> result = pf()

After the form is called, the changes are applied to the objects. 
    >>> sorted([obj.name for obj in orderMapping.values()])
    [u'newer name 0', u'newer name 1']

Due to the reason the save handler sets the inputMode to False,
only display widgets are rendered in the results

    >>> print result
    <div>
    <div>0</div><div>newer name 0</div>...
    </div>
    <div>
    <div>1</div><div>newer name 1</div>...
    </div>
    ...

Now we should only have the edit action be available, which is a
multiform action, therefore not contained in the subActionNames

    >>> pf.subActionNames
    []
    >>> [a.__name__ for a in pf.availableActions()]
    [u'form.actions.edit']

Now Let us cancel the edit mode.

    >>> request = TestRequest()
    >>> request.form['form.actions.cancel']=u''
    >>> for i in range(2):
    ...     request.form['form.sf.n%s.name' % i]='next name %s' % i
    ...     request.form['form.sf.n%s.identifier' % i]= i
    >>> pf =  OrdersForm(orderMapping,request)
    >>> result = pf()

After the form is called, the objects are left unchanged. And the form
should be in display mode again.

    >>> sorted([obj.name for obj in orderMapping.values()])
    [u'newer name 0', u'newer name 1']

    >>> print result
    <div>
    <div>0</div><div>newer name 0</div>...
    </div>
    <div>
    <div>1</div><div>newer name 1</div>...
    </div>...

Now let us call the upper action, which should uppercase the name
attributes of the items. This action is an action on the items itself,
so we have a unique prefix with the key of the item in the parent
mapping.

    >>> request = TestRequest()
    >>> request.form['form.sf.n1.actions.upper']=u''
    >>> pf =  OrdersForm(orderMapping,request)
    >>> result = pf()
    >>> print result
    <div>
    <div>0</div><div>newer name 0</div>...
    </div>
    <div>
    <div>1</div><div>NEWER NAME 1</div>...
    </div>...
