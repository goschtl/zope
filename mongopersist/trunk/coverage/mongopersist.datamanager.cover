       ##############################################################################
       #
       # Copyright (c) 2011 Zope Foundation and Contributors.
       # All Rights Reserved.
       #
       # This software is subject to the provisions of the Zope Public License,
       # Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
       # THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
       # WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
       # WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
       # FOR A PARTICULAR PURPOSE.
       #
       ##############################################################################
    1: """Mongo Persistent Data Manager"""
    1: from __future__ import absolute_import
    1: import UserDict
    1: import persistent
    1: import pymongo
    1: import pymongo.dbref
    1: import transaction
    1: import zope.interface
       
    1: from mongopersist import interfaces, serialize
       
    1: def create_conflict_error(obj, new_doc):
    3:     return interfaces.ConflictError(
    3:         None, obj,
    3:         (new_doc.get('_py_serial', 0), serialize.u64(obj._p_serial)))
       
       
    2: class Root(UserDict.DictMixin):
       
    1:     database='mongopersist'
    1:     collection = 'persistence_root'
       
    1:     def __init__(self, jar, database=None, collection=None):
  123:         self._jar = jar
  123:         if database is not None:
   58:             self.database = database
  123:         if collection is not None:
    2:             self.collection = collection
  123:         db = self._jar._conn[self.database]
  123:         self._collection_inst = db[self.collection]
       
    1:     def __getitem__(self, key):
  119:         doc = self._collection_inst.find_one({'name': key})
  119:         if doc is None:
   14:             raise KeyError(key)
  105:         return self._jar.load(doc['ref'])
       
    1:     def __setitem__(self, key, value):
   16:         dbref = self._jar.dump(value)
   15:         if self.get(key) is not None:
    1:             del self[key]
   15:         doc = {'ref': dbref, 'name': key}
   15:         self._collection_inst.insert(doc)
       
    1:     def __delitem__(self, key):
    2:         doc = self._collection_inst.find_one({'name': key})
    2:         coll = self._jar._conn[doc['ref'].database][doc['ref'].collection]
    2:         coll.remove(doc['ref'].id)
    2:         self._collection_inst.remove({'name': key})
       
    1:     def keys(self):
    6:         return [doc['name'] for doc in self._collection_inst.find()]
       
       
    2: class MongoDataManager(object):
    1:     zope.interface.implements(interfaces.IMongoDataManager)
       
    1:     detect_conflicts = False
    1:     default_database = 'mongopersist'
    1:     name_map_collection = 'persistence_name_map'
    1:     conflict_error_factory = staticmethod(create_conflict_error)
       
    1:     def __init__(self, conn, detect_conflicts=None, default_database=None,
    1:                  root_database=None, root_collection=None,
    1:                  name_map_collection=None, conflict_error_factory=None):
  122:         self._conn = conn
  122:         self._reader = serialize.ObjectReader(self)
  122:         self._writer = serialize.ObjectWriter(self)
  122:         self._registered_objects = []
  122:         self._loaded_objects = []
  122:         self._needs_to_join = True
  122:         self._object_cache = {}
  122:         self.annotations = {}
  122:         if detect_conflicts is not None:
    2:             self.detect_conflicts = detect_conflicts
  122:         if default_database is not None:
   57:             self.default_database = default_database
  122:         if name_map_collection is not None:
    1:             self.name_map_collection = name_map_collection
  122:         if conflict_error_factory is not None:
    1:             self.conflict_error_factory = conflict_error_factory
  122:         self.transaction_manager = transaction.manager
  122:         self.root = Root(self, root_database, root_collection)
       
    1:     def dump(self, obj):
   23:         return self._writer.store(obj)
       
    1:     def load(self, dbref):
  109:         return self._reader.get_ghost(dbref)
       
    1:     def reset(self):
   65:         root = self.root
   65:         self.__init__(self._conn)
   65:         self.root = root
       
    1:     def setstate(self, obj):
               # When reading a state from Mongo, we also need to join the
               # transaction, because we keep an active object cache that gets stale
               # after the transaction is complete and must be cleaned.
   46:         if self._needs_to_join:
   29:             self.transaction_manager.get().join(self)
   29:             self._needs_to_join = False
   46:         self._reader.set_ghost_state(obj)
   46:         self._loaded_objects.append(obj)
       
    1:     def oldstate(self, obj, tid):
               # I cannot find any code using this method. Also, since we do not keep
               # version history, we always raise an error.
    1:         raise KeyError(tid)
       
    1:     def register(self, obj):
   58:         if self._needs_to_join:
   16:             self.transaction_manager.get().join(self)
   16:             self._needs_to_join = False
       
   58:         if obj is not None and obj not in self._registered_objects:
   56:             self._registered_objects.append(obj)
       
    1:     def abort(self, transaction):
   15:         self.reset()
       
    1:     def commit(self, transaction):
   39:         if not self.detect_conflicts:
   32:             return
               # Check each modified object to see whether Mongo has a new version of
               # the object.
   12:         for obj in self._registered_objects:
                   # This object is not even added to the database yet, so there
                   # cannot be a conflict.
    7:             if obj._p_oid is None:
    1:                 continue
    6:             db_name, coll_name = self._writer.get_collection_name(obj)
    6:             coll = self._conn[db_name][coll_name]
    6:             new_doc = coll.find_one(obj._p_oid.id, fields=('_py_serial',))
    6:             if new_doc is None:
    1:                 continue
    5:             if new_doc.get('_py_serial', 0) != serialize.u64(obj._p_serial):
    2:                 raise self.conflict_error_factory(obj, new_doc)
       
    1:     def tpc_begin(self, transaction):
   35:         pass
       
    1:     def tpc_vote(self, transaction):
   34:         pass
       
    1:     def tpc_finish(self, transaction):
   37:         written = []
   92:         for obj in self._registered_objects:
   55:             if getattr(obj, '_p_mongo_sub_object', False):
    5:                 obj = obj._p_mongo_doc_object
   55:             if obj in written:
    3:                 continue
   52:             self._writer.store(obj)
   52:             written.append(obj)
   37:         self.reset()
       
    1:     def tpc_abort(self, transaction):
    2:         self.abort(transaction)
       
    1:     def sortKey(self):
    6:         return ('MongoDataManager', 0)
