       ##############################################################################
       #
       # Copyright (c) 2011 Zope Foundation and Contributors.
       # All Rights Reserved.
       #
       # This software is subject to the provisions of the Zope Public License,
       # Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
       # THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
       # WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
       # WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
       # FOR A PARTICULAR PURPOSE.
       #
       ##############################################################################
    1: """Mongo Persistence Zope Containers"""
    1: import UserDict
    1: import persistent
    1: import pymongo.dbref
    1: import zope.component
    1: from rwproperty import getproperty, setproperty
    1: from zope.container import contained, sample
       
    1: from mongopersist import interfaces, serialize
       
       
    2: class MongoContained(contained.Contained):
       
    1:     @getproperty
           def __name__(self):
    5:         return getattr(self, '_v_key', None)
    1:     @setproperty
           def __name__(self, value):
    1:         setattr(self, '_v_key', value)
       
    1:     @getproperty
           def __parent__(self):
    5:         return getattr(self, '_v_parent', None)
    1:     @setproperty
           def __parent__(self, value):
    1:         setattr(self, '_v_parent', value)
       
       
    2: class SimpleMongoContainer(sample.SampleContainer, persistent.Persistent):
       
    1:     def __getstate__(self):
    5:         state = super(SimpleMongoContainer, self).__getstate__()
    5:         state['data'] = state.pop('_SampleContainer__data')
    5:         return state
       
    1:     def __setstate__(self, state):
    4:         state['_SampleContainer__data'] = state.pop('data', {})
    4:         super(SimpleMongoContainer, self).__setstate__(state)
       
    1:     def __getitem__(self, key):
   13:         obj = super(SimpleMongoContainer, self).__getitem__(key)
   12:         obj._v_key = key
   12:         obj._v_parent = self
   12:         return obj
       
    1:     def get(self, key, default=None):
               '''See interface `IReadContainer`'''
    3:         obj = super(SimpleMongoContainer, self).get(key, default)
    3:         if obj is not default:
    1:             obj._v_key = key
    1:             obj._v_parent = self
    3:         return obj
       
    1:     def items(self):
    2:         items = super(SimpleMongoContainer, self).items()
    4:         for key, obj in items:
    2:             obj._v_key = key
    2:             obj._v_parent = self
    2:         return items
       
    1:     def values(self):
    2:         return [v for k, v in self.items()]
       
    1:     def __setitem__(self, key, object):
    2:         super(SimpleMongoContainer, self).__setitem__(key, object)
    2:         self._p_changed = True
       
    1:     def __delitem__(self, key):
    1:         super(SimpleMongoContainer, self).__delitem__(key)
    1:         self._p_changed = True
       
    2: class MongoContainer(contained.Contained,
    1:                      persistent.Persistent,
    1:                      UserDict.DictMixin):
    1:     _m_database = None
    1:     _m_collection = None
    1:     _m_mapping_key = 'key'
    1:     _m_parent_key = 'parent'
       
    1:     def __init__(self, collection=None, database=None,
    1:                  mapping_key=None, parent_key=None):
   10:         if collection:
   10:             self._m_collection = collection
   10:         if database:
    1:             self._m_database = database
   10:         if mapping_key is not None:
    1:             self._m_mapping_key = mapping_key
   10:         if parent_key is not None:
    1:             self._m_parent_key = parent_key
       
    1:     @property
           def _added(self):
   48:         ann = self._m_jar.annotations.setdefault(self._p_oid or id(self), {})
   48:         return ann.setdefault('added', {})
       
    1:     @property
           def _deleted(self):
   46:         ann = self._m_jar.annotations.setdefault(self._p_oid or id(self), {})
   46:         return ann.setdefault('deleted', {})
       
    1:     @property
           def _m_jar(self):
               # If the container is in a Mongo storage hierarchy, then getting the
               # datamanager is easy, otherwise we do an adapter lookup.
  228:         if interfaces.IMongoDataManager.providedBy(self._p_jar):
  208:             return self._p_jar
               else:
   20:             provider = zope.component.getUtility(
   20:                 interfaces.IMongoDataManagerProvider)
   19:             return provider.get()
       
    1:     def get_collection(self):
   27:         db_name = self._m_database or self._m_jar.default_database
   27:         return self._m_jar._conn[db_name][self._m_collection]
       
    1:     def _m_get_parent_key_value(self):
   48:         if getattr(self, '_p_jar', None) is None:
    1:             raise ValueError('_p_jar not found.')
   47:         if interfaces.IMongoDataManager.providedBy(self._p_jar):
   42:             return self
               else:
   50:             return 'zodb-'+''.join("%02x" % ord(x) for x in self._p_oid).strip()
       
    1:     def _m_get_items_filter(self):
   28:         filter = {}
               # Make sure that we only look through objects that have the mapping
               # key. Objects not having the mapping key cannot be part of the
               # collection.
   28:         if self._m_mapping_key is not None:
   28:             filter[self._m_mapping_key] = {'$exists': True}
   28:         if self._m_parent_key is not None:
   27:             gs = self._m_jar._writer.get_state
   26:             filter[self._m_parent_key] = gs(self._m_get_parent_key_value())
   27:         return filter
       
    1:     def __getitem__(self, key):
   12:         if key in self._added:
    4:             return self._added[key]
    8:         if key in self._deleted:
    1:             raise KeyError(key)
    7:         filter = self._m_get_items_filter()
    7:         filter[self._m_mapping_key] = key
    7:         doc = self.get_collection().find_one(filter, fields=())
    7:         if doc is None:
    1:             raise KeyError(key)
    6:         dbref = pymongo.dbref.DBRef(
    6:             self._m_collection, doc['_id'],
    6:             self._m_database or self._m_jar.default_database)
    6:         obj = self._m_jar._reader.get_ghost(dbref)
    6:         obj._v_key = key
    6:         obj._v_parent = self
    6:         return obj
       
    1:     def __setitem__(self, key, value):
               # This call by iteself caues the state to change _p_changed to True.
   19:         setattr(value, self._m_mapping_key, key)
   19:         if self._m_parent_key is not None:
   19:             setattr(value, self._m_parent_key, self._m_get_parent_key_value())
   19:         self._m_jar.register(value)
               # Temporarily store the added object, so it is immediately available
               # via the API.
   19:         value._v_key = key
   19:         value._v_parent = self
   19:         self._added[key] = value
   19:         self._deleted.pop(key, None)
       
    1:     def __delitem__(self, key):
               # Deleting the object from the database is not our job. We simply
               # remove it from the dictionary.
    1:         value = self[key]
    1:         if self._m_mapping_key is not None:
    1:             delattr(value, self._m_mapping_key)
    1:         if self._m_parent_key is not None:
    1:             delattr(value, self._m_parent_key)
    1:         self._deleted[key] = value
    1:         self._added.pop(key, None)
       
    1:     def keys(self):
   13:         filter = self._m_get_items_filter()
   12:         filter[self._m_mapping_key] = {'$ne': None}
               keys = [
   12:             doc[self._m_mapping_key]
   12:             for doc in self.get_collection().find(filter)
   18:             if not doc[self._m_mapping_key] in self._deleted]
   12:         keys += self._added.keys()
   12:         return keys
       
    1:     def raw_find(self, spec=None, *args, **kwargs):
    3:         if spec is None:
    1:             spec  = {}
    3:         spec.update(self._m_get_items_filter())
    3:         return self.get_collection().find(spec, *args, **kwargs)
       
    1:     def find(self, spec=None, fields=None, *args, **kwargs):
               # If fields were not specified, we only request the oid and the key.
    2:         fields = tuple(fields or ())
    2:         fields += (self._m_mapping_key,)
    2:         result = self.raw_find(spec, fields, *args, **kwargs)
   10:         for doc in result:
    8:             dbref = pymongo.dbref.DBRef(
    8:                 self._m_collection, doc['_id'],
    8:                 self._m_database or self._m_jar.default_database)
    8:             obj = self._m_jar._reader.get_ghost(dbref)
    8:             obj._v_key = doc[self._m_mapping_key]
    8:             obj._v_parent = self
    8:             yield obj
       
    1:     def raw_find_one(self, spec_or_id=None, *args, **kwargs):
    5:         if spec_or_id is None:
    1:             spec_or_id  = {}
    5:         if not isinstance(spec_or_id, dict):
    1:             spec_or_id = {'_id': spec_or_id}
    5:         spec_or_id.update(self._m_get_items_filter())
    5:         return self.get_collection().find_one(spec_or_id, *args, **kwargs)
       
    1:     def find_one(self, spec_or_id=None, fields=None, *args, **kwargs):
               # If fields were not specified, we only request the oid and the key.
    4:         fields = tuple(fields or ())
    4:         fields += (self._m_mapping_key,)
    4:         doc = self.raw_find_one(spec_or_id, fields, *args, **kwargs)
    4:         if doc is None:
    1:             return None
    3:         dbref = pymongo.dbref.DBRef(
    3:             self._m_collection, doc['_id'],
    3:             self._m_database or self._m_jar.default_database)
    3:         obj = self._m_jar._reader.get_ghost(dbref)
    3:         obj._v_key = doc[self._m_mapping_key]
    3:         obj._v_parent = self
    3:         return obj
       
    2: class AllItemsMongoContainer(MongoContainer):
    1:     _m_parent_key = None
       
       
    2: class SubDocumentMongoContainer(MongoContained, MongoContainer):
    1:     _p_mongo_sub_object = True
