
    <html>
      <head><title>Test coverage for mongopersist.serialize</title>
      <style type="text/css">
        a {text-decoration: none; display: block; padding-right: 1em;}
        a:hover {background: #EFA;}
        hr {height: 1px; border: none; border-top: 1px solid gray;}
        .notcovered {background: #FCC;}
        .footer {margin: 2em; font-size: small; color: gray;}
      </style>
      </head>
      <body><h1>Test coverage for mongopersist.serialize</h1>
      <table>
    
<tr><td><a href="mongopersist.html">mongopersist/</a></td> <td style="background: yellow">&nbsp;&nbsp;&nbsp;&nbsp;</td> <td>covered 99% (1 of 695 uncovered)</td></tr>
<tr><td><a href="mongopersist.serialize.html">&nbsp;&nbsp;&nbsp;&nbsp;serialize.py</a></td> <td style="background: yellow">&nbsp;&nbsp;&nbsp;&nbsp;</td> <td>covered 99% (1 of 250 uncovered)</td></tr>
</table><hr/>
<pre>
       <I><FONT COLOR="#B22222">##############################################################################
</FONT></I>       <I><FONT COLOR="#B22222">#
</FONT></I>       <I><FONT COLOR="#B22222"># Copyright (c) 2011 Zope Foundation and Contributors.
</FONT></I>       <I><FONT COLOR="#B22222"># All Rights Reserved.
</FONT></I>       <I><FONT COLOR="#B22222">#
</FONT></I>       <I><FONT COLOR="#B22222"># This software is subject to the provisions of the Zope Public License,
</FONT></I>       <I><FONT COLOR="#B22222"># Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
</FONT></I>       <I><FONT COLOR="#B22222"># THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY AND ALL EXPRESS OR IMPLIED
</FONT></I>       <I><FONT COLOR="#B22222"># WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
</FONT></I>       <I><FONT COLOR="#B22222"># WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
</FONT></I>       <I><FONT COLOR="#B22222"># FOR A PARTICULAR PURPOSE.
</FONT></I>       <I><FONT COLOR="#B22222">#
</FONT></I>       <I><FONT COLOR="#B22222">##############################################################################
</FONT></I>    1: <B><FONT COLOR="#BC8F8F">&quot;&quot;&quot;Object Serialization for Mongo/BSON&quot;&quot;&quot;</FONT></B>
    1: <B><FONT COLOR="#A020F0">from</FONT></B> __future__ <B><FONT COLOR="#A020F0">import</FONT></B> absolute_import
    1: <B><FONT COLOR="#A020F0">import</FONT></B> copy_reg
    1: <B><FONT COLOR="#A020F0">import</FONT></B> struct
       
    1: <B><FONT COLOR="#A020F0">import</FONT></B> lru
    1: <B><FONT COLOR="#A020F0">import</FONT></B> persistent.interfaces
    1: <B><FONT COLOR="#A020F0">import</FONT></B> persistent.dict
    1: <B><FONT COLOR="#A020F0">import</FONT></B> persistent.list
    1: <B><FONT COLOR="#A020F0">import</FONT></B> pymongo.binary
    1: <B><FONT COLOR="#A020F0">import</FONT></B> pymongo.dbref
    1: <B><FONT COLOR="#A020F0">import</FONT></B> pymongo.objectid
    1: <B><FONT COLOR="#A020F0">import</FONT></B> types
    1: <B><FONT COLOR="#A020F0">import</FONT></B> zope.interface
    1: <B><FONT COLOR="#A020F0">from</FONT></B> zope.dottedname.resolve <B><FONT COLOR="#A020F0">import</FONT></B> resolve
       
    1: <B><FONT COLOR="#A020F0">from</FONT></B> mongopersist <B><FONT COLOR="#A020F0">import</FONT></B> interfaces
       
    1: SERIALIZERS = []
    1: OID_CLASS_LRU = lru.LRUCache(20000)
       
    1: <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">p64</FONT></B>(v):
           <B><FONT COLOR="#BC8F8F">&quot;&quot;&quot;Pack an integer or long into a 8-byte string&quot;&quot;&quot;</FONT></B>
   16:     <B><FONT COLOR="#A020F0">return</FONT></B> struct.pack(<B><FONT COLOR="#BC8F8F">&quot;&gt;Q&quot;</FONT></B>, v)
       
    1: <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">u64</FONT></B>(v):
           <B><FONT COLOR="#BC8F8F">&quot;&quot;&quot;Unpack an 8-byte string into a 64-bit long integer.&quot;&quot;&quot;</FONT></B>
   19:     <B><FONT COLOR="#A020F0">return</FONT></B> struct.unpack(<B><FONT COLOR="#BC8F8F">&quot;&gt;Q&quot;</FONT></B>, v)[0]
       
    1: <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_dotted_name</FONT></B>(obj):
  207:     <B><FONT COLOR="#A020F0">return</FONT></B> obj.__module__+<B><FONT COLOR="#BC8F8F">'.'</FONT></B>+obj.__name__
       
    2: <B><FONT COLOR="#A020F0">class</FONT></B> PersistentDict(persistent.dict.PersistentDict):
    1:     _p_mongo_sub_object = True
       
    2: <B><FONT COLOR="#A020F0">class</FONT></B> PersistentList(persistent.list.PersistentList):
    1:     _p_mongo_sub_object = True
       
       
    2: <B><FONT COLOR="#A020F0">class</FONT></B> ObjectSerializer(object):
    1:     zope.interface.implements(interfaces.IObjectSerializer)
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">can_read</FONT></B>(self, state):
    1:         <B><FONT COLOR="#A020F0">raise</FONT></B> NotImplementedError
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">read</FONT></B>(self, state):
    1:         <B><FONT COLOR="#A020F0">raise</FONT></B> NotImplementedError
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">can_write</FONT></B>(self, obj):
    1:         <B><FONT COLOR="#A020F0">raise</FONT></B> NotImplementedError
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">write</FONT></B>(self, obj):
    1:         <B><FONT COLOR="#A020F0">raise</FONT></B> NotImplementedError
       
       
    2: <B><FONT COLOR="#A020F0">class</FONT></B> ObjectWriter(object):
    1:     zope.interface.implements(interfaces.IObjectWriter)
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">__init__</FONT></B>(self, jar):
  139:         self._jar = jar
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_collection_name</FONT></B>(self, obj):
  168:         db_name = getattr(obj, <B><FONT COLOR="#BC8F8F">'_p_mongo_database'</FONT></B>, self._jar.default_database)
  168:         <B><FONT COLOR="#A020F0">try</FONT></B>:
  168:             coll_name = obj._p_mongo_collection
   99:         <B><FONT COLOR="#A020F0">except</FONT></B> AttributeError:
   99:             <B><FONT COLOR="#A020F0">return</FONT></B> db_name, get_dotted_name(obj.__class__)
               <I><FONT COLOR="#B22222"># Make sure that the coll_name to class path mapping is available.
</FONT></I>   69:         db = self._jar._conn[self._jar.default_database]
   69:         coll = db[self._jar.name_map_collection]
   69:         map = {<B><FONT COLOR="#BC8F8F">'collection'</FONT></B>: coll_name,
   69:                <B><FONT COLOR="#BC8F8F">'database'</FONT></B>: db_name,
   69:                <B><FONT COLOR="#BC8F8F">'path'</FONT></B>: get_dotted_name(obj.__class__)}
   69:         result = coll.find_one(map)
   69:         <B><FONT COLOR="#A020F0">if</FONT></B> result <B><FONT COLOR="#A020F0">is</FONT></B> None:
                   <I><FONT COLOR="#B22222"># If there is already a map for this collection, the next map must
</FONT></I>                   <I><FONT COLOR="#B22222"># force the object to store the type.
</FONT></I>   28:             result = coll.find({<B><FONT COLOR="#BC8F8F">'collection'</FONT></B>: coll_name,
   28:                                 <B><FONT COLOR="#BC8F8F">'database'</FONT></B>: db_name})
   28:             <B><FONT COLOR="#A020F0">if</FONT></B> result.count() &gt; 0:
    3:                 setattr(obj, <B><FONT COLOR="#BC8F8F">'_p_mongo_store_type'</FONT></B>, True)
   28:             map[<B><FONT COLOR="#BC8F8F">'doc_has_type'</FONT></B>] = getattr(obj, <B><FONT COLOR="#BC8F8F">'_p_mongo_store_type'</FONT></B>, False)
   28:             coll.save(map)
   69:         <B><FONT COLOR="#A020F0">return</FONT></B> db_name, coll_name
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_non_persistent_state</FONT></B>(self, obj, seen):
   34:         __traceback_info__ = obj
               <I><FONT COLOR="#B22222"># XXX: Look at the pickle library how to properly handle all types and
</FONT></I>               <I><FONT COLOR="#B22222"># old-style classes with all of the possible pickle extensions.
</FONT></I>       
               <I><FONT COLOR="#B22222"># Only non-persistent, custom objects can produce unresolvable
</FONT></I>               <I><FONT COLOR="#B22222"># circular references.
</FONT></I>   34:         <B><FONT COLOR="#A020F0">if</FONT></B> obj <B><FONT COLOR="#A020F0">in</FONT></B> seen:
    2:             <B><FONT COLOR="#A020F0">raise</FONT></B> interfaces.CircularReferenceError(obj)
               <I><FONT COLOR="#B22222"># Add the current object to the list of seen objects.
</FONT></I>   32:         seen.append(obj)
               <I><FONT COLOR="#B22222"># Get the state of the object. Only pickable objects can be reduced.
</FONT></I>   32:         reduced = obj.__reduce__()
               <I><FONT COLOR="#B22222"># The full object state (item 3) seems to be optional, so let's make
</FONT></I>               <I><FONT COLOR="#B22222"># sure we handle that case gracefully.
</FONT></I>   32:         <B><FONT COLOR="#A020F0">if</FONT></B> len(reduced) == 2:
    2:             factory, args = obj.__reduce__()
    2:             obj_state = {}
               <B><FONT COLOR="#A020F0">else</FONT></B>:
   30:             factory, args, obj_state = reduced
               <I><FONT COLOR="#B22222"># We are trying very hard to create a clean Mongo (sub-)document. But
</FONT></I>               <I><FONT COLOR="#B22222"># we need a little bit of meta-data to help us out later.
</FONT></I>   32:         <B><FONT COLOR="#A020F0">if</FONT></B> factory == copy_reg._reconstructor <B><FONT COLOR="#A020F0">and</FONT></B> \
   16:                args == (obj.__class__, object, None):
                   <I><FONT COLOR="#B22222"># This is the simple case, which means we can produce a nicer
</FONT></I>                   <I><FONT COLOR="#B22222"># Mongo output.
</FONT></I>   16:             state = {<B><FONT COLOR="#BC8F8F">'_py_type'</FONT></B>: get_dotted_name(args[0])}
   16:         <B><FONT COLOR="#A020F0">elif</FONT></B> factory == copy_reg.__newobj__ <B><FONT COLOR="#A020F0">and</FONT></B> args == (obj.__class__,):
                   <I><FONT COLOR="#B22222"># Another simple case for persistent objects that do not want
</FONT></I>                   <I><FONT COLOR="#B22222"># their own document.
</FONT></I>   14:             state = {<B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B>: get_dotted_name(args[0])}
               <B><FONT COLOR="#A020F0">else</FONT></B>:
    2:             state = {<B><FONT COLOR="#BC8F8F">'_py_factory'</FONT></B>: get_dotted_name(factory),
    2:                      <B><FONT COLOR="#BC8F8F">'_py_factory_args'</FONT></B>: self.get_state(args, seen)}
   86:         <B><FONT COLOR="#A020F0">for</FONT></B> name, value <B><FONT COLOR="#A020F0">in</FONT></B> obj_state.items():
   56:             state[name] = self.get_state(value, seen)
   30:         <B><FONT COLOR="#A020F0">return</FONT></B> state
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_persistent_state</FONT></B>(self, obj, seen):
   73:         __traceback_info__ = obj
               <I><FONT COLOR="#B22222"># Persistent sub-objects are stored by reference, the key being
</FONT></I>               <I><FONT COLOR="#B22222"># (collection name, oid).
</FONT></I>               <I><FONT COLOR="#B22222"># Getting the collection name is easy, but if we have an unsaved
</FONT></I>               <I><FONT COLOR="#B22222"># persistent object, we do not yet have an OID. This must be solved by
</FONT></I>               <I><FONT COLOR="#B22222"># storing the persistent object.
</FONT></I>   73:         <B><FONT COLOR="#A020F0">if</FONT></B> obj._p_oid <B><FONT COLOR="#A020F0">is</FONT></B> None:
   11:             dbref = self.store(obj, ref_only=True)
               <B><FONT COLOR="#A020F0">else</FONT></B>:
   62:             db_name, coll_name = self.get_collection_name(obj)
   62:             dbref = obj._p_oid
               <I><FONT COLOR="#B22222"># Create the reference sub-document. The _p_type value helps with the
</FONT></I>               <I><FONT COLOR="#B22222"># deserialization later.
</FONT></I>   73:         <B><FONT COLOR="#A020F0">return</FONT></B> dbref
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_state</FONT></B>(self, obj, seen=None):
  478:         seen = seen <B><FONT COLOR="#A020F0">or</FONT></B> []
  478:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(obj, interfaces.MONGO_NATIVE_TYPES):
                   <I><FONT COLOR="#B22222"># If we have a native type, we'll just use it as the state.
</FONT></I>  189:             <B><FONT COLOR="#A020F0">return</FONT></B> obj
  289:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(obj, str):
                   <I><FONT COLOR="#B22222"># In Python 2, strings can be ASCII, encoded unicode or binary
</FONT></I>                   <I><FONT COLOR="#B22222"># data. Unfortunately, BSON cannot handle that. So, if we have a
</FONT></I>                   <I><FONT COLOR="#B22222"># string that cannot be UTF-8 decoded (luckily ASCII is a valid
</FONT></I>                   <I><FONT COLOR="#B22222"># subset of UTF-8), then we use the BSON binary type.
</FONT></I>   50:             <B><FONT COLOR="#A020F0">try</FONT></B>:
   50:                 obj.decode(<B><FONT COLOR="#BC8F8F">'utf-8'</FONT></B>)
   48:                 <B><FONT COLOR="#A020F0">return</FONT></B> obj
    2:             <B><FONT COLOR="#A020F0">except</FONT></B> UnicodeError:
    2:                 <B><FONT COLOR="#A020F0">return</FONT></B> pymongo.binary.Binary(obj)
       
               <I><FONT COLOR="#B22222"># Some objects might not naturally serialize well and create a very
</FONT></I>               <I><FONT COLOR="#B22222"># ugly Mongo entry. Thus, we allow custom serializers to be
</FONT></I>               <I><FONT COLOR="#B22222"># registered, which can encode/decode different types of objects.
</FONT></I>  317:         <B><FONT COLOR="#A020F0">for</FONT></B> serializer <B><FONT COLOR="#A020F0">in</FONT></B> SERIALIZERS:
   85:             <B><FONT COLOR="#A020F0">if</FONT></B> serializer.can_write(obj):
    7:                 <B><FONT COLOR="#A020F0">return</FONT></B> serializer.write(obj)
       
  232:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(obj, (type, types.ClassType)):
                   <I><FONT COLOR="#B22222"># We frequently store class and function paths as meta-data, so we
</FONT></I>                   <I><FONT COLOR="#B22222"># need to be able to properly encode those.
</FONT></I>    2:             <B><FONT COLOR="#A020F0">return</FONT></B> {<B><FONT COLOR="#BC8F8F">'_py_type'</FONT></B>: <B><FONT COLOR="#BC8F8F">'type'</FONT></B>,
    2:                     <B><FONT COLOR="#BC8F8F">'path'</FONT></B>: get_dotted_name(obj)}
  230:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(obj, (tuple, list, PersistentList)):
                   <I><FONT COLOR="#B22222"># Make sure that all values within a list are serialized
</FONT></I>                   <I><FONT COLOR="#B22222"># correctly. Also convert any sequence-type to a simple list.
</FONT></I>   47:             <B><FONT COLOR="#A020F0">return</FONT></B> [self.get_state(value, seen) <B><FONT COLOR="#A020F0">for</FONT></B> value <B><FONT COLOR="#A020F0">in</FONT></B> obj]
  209:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(obj, (dict, PersistentDict)):
                   <I><FONT COLOR="#B22222"># Same as for sequences, make sure that the contained values are
</FONT></I>                   <I><FONT COLOR="#B22222"># properly serialized.
</FONT></I>                   <I><FONT COLOR="#B22222"># Note: A big constraint in Mongo is that keys must be strings!
</FONT></I>  109:             has_non_string_key = False
  109:             data = []
  373:             <B><FONT COLOR="#A020F0">for</FONT></B> key, value <B><FONT COLOR="#A020F0">in</FONT></B> obj.items():
  265:                 data.append((key, self.get_state(value, seen)))
  264:                 has_non_string_key |= <B><FONT COLOR="#A020F0">not</FONT></B> isinstance(key, basestring)
  108:             <B><FONT COLOR="#A020F0">if</FONT></B> <B><FONT COLOR="#A020F0">not</FONT></B> has_non_string_key:
                       <I><FONT COLOR="#B22222"># The easy case: all keys are strings:
</FONT></I>  107:                 <B><FONT COLOR="#A020F0">return</FONT></B> dict(data)
                   <B><FONT COLOR="#A020F0">else</FONT></B>:
                       <I><FONT COLOR="#B22222"># We first need to reduce the keys and then produce a data
</FONT></I>                       <I><FONT COLOR="#B22222"># structure.
</FONT></I>    4:                 data = [(self.get_state(key), value) <B><FONT COLOR="#A020F0">for</FONT></B> key, value <B><FONT COLOR="#A020F0">in</FONT></B> data]
    1:                 <B><FONT COLOR="#A020F0">return</FONT></B> {<B><FONT COLOR="#BC8F8F">'dict_data'</FONT></B>: data}
       
  100:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(obj, persistent.Persistent):
                   <I><FONT COLOR="#B22222"># Only create a persistent reference, if the object does not want
</FONT></I>                   <I><FONT COLOR="#B22222"># to be a sub-document.
</FONT></I>   84:             <B><FONT COLOR="#A020F0">if</FONT></B> <B><FONT COLOR="#A020F0">not</FONT></B> getattr(obj, <B><FONT COLOR="#BC8F8F">'_p_mongo_sub_object'</FONT></B>, False):
   71:                 <B><FONT COLOR="#A020F0">return</FONT></B> self.get_persistent_state(obj, seen)
                   <I><FONT COLOR="#B22222"># This persistent object is a sub-document, so it is treated like
</FONT></I>                   <I><FONT COLOR="#B22222"># a non-persistent object.
</FONT></I>       
   29:         <B><FONT COLOR="#A020F0">return</FONT></B> self.get_non_persistent_state(obj, seen)
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">store</FONT></B>(self, obj, ref_only=False):
   96:         db_name, coll_name = self.get_collection_name(obj)
   96:         coll = self._jar._conn[db_name][coll_name]
   96:         <B><FONT COLOR="#A020F0">if</FONT></B> ref_only:
                   <I><FONT COLOR="#B22222"># We only want to get OID quickly. Trying to reduce the full state
</FONT></I>                   <I><FONT COLOR="#B22222"># might cause infinite recusrion loop. (Example: 2 new objects
</FONT></I>                   <I><FONT COLOR="#B22222"># reference each other.)
</FONT></I>   11:             doc = {}
                   <I><FONT COLOR="#B22222"># Make sure that the object gets saved fully later.
</FONT></I>   11:             self._jar.register(obj)
               <B><FONT COLOR="#A020F0">else</FONT></B>:
                   <I><FONT COLOR="#B22222"># XXX: Handle newargs; see ZODB.serialize.ObjectWriter.serialize
</FONT></I>                   <I><FONT COLOR="#B22222"># Go through each attribute and search for persistent references.
</FONT></I>   85:             doc = self.get_state(obj.__getstate__())
   95:         <B><FONT COLOR="#A020F0">if</FONT></B> getattr(obj, <B><FONT COLOR="#BC8F8F">'_p_mongo_store_type'</FONT></B>, False):
    4:             doc[<B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B>] = get_dotted_name(obj.__class__)
               <I><FONT COLOR="#B22222"># If conflict detection is turned on, store a serial number for the
</FONT></I>               <I><FONT COLOR="#B22222"># document.
</FONT></I>   95:         <B><FONT COLOR="#A020F0">if</FONT></B> self._jar.detect_conflicts:
   11:             doc[<B><FONT COLOR="#BC8F8F">'_py_serial'</FONT></B>] = u64(getattr(obj, <B><FONT COLOR="#BC8F8F">'_p_serial'</FONT></B>, 0)) + 1
   11:             obj._p_serial = p64(doc[<B><FONT COLOR="#BC8F8F">'_py_serial'</FONT></B>])
       
   95:         <B><FONT COLOR="#A020F0">if</FONT></B> obj._p_oid <B><FONT COLOR="#A020F0">is</FONT></B> None:
   63:             doc_id = coll.insert(doc)
   63:             obj._p_jar = self._jar
   63:             obj._p_oid = pymongo.dbref.DBRef(coll_name, doc_id, db_name)
                   <I><FONT COLOR="#B22222"># Make sure that any other code accessing this object in this
</FONT></I>                   <I><FONT COLOR="#B22222"># session, gets the same instance.
</FONT></I>   63:             self._jar._object_cache[doc_id] = obj
               <B><FONT COLOR="#A020F0">else</FONT></B>:
   32:             doc[<B><FONT COLOR="#BC8F8F">'_id'</FONT></B>] = obj._p_oid.id
   32:             coll.save(doc)
   95:         <B><FONT COLOR="#A020F0">return</FONT></B> obj._p_oid
       
       
    2: <B><FONT COLOR="#A020F0">class</FONT></B> ObjectReader(object):
    1:     zope.interface.implements(interfaces.IObjectReader)
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">__init__</FONT></B>(self, jar):
  138:         self._jar = jar
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">simple_resolve</FONT></B>(self, path):
  118:         <B><FONT COLOR="#A020F0">return</FONT></B> resolve(path)
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">resolve</FONT></B>(self, dbref):
   72:         <B><FONT COLOR="#A020F0">try</FONT></B>:
   72:             <B><FONT COLOR="#A020F0">return</FONT></B> OID_CLASS_LRU[dbref.id]
   66:         <B><FONT COLOR="#A020F0">except</FONT></B> KeyError:
   66:             <B><FONT COLOR="#A020F0">pass</FONT></B>
               <I><FONT COLOR="#B22222"># First we try to resolve the path directly.
</FONT></I>   66:         <B><FONT COLOR="#A020F0">try</FONT></B>:
   66:             <B><FONT COLOR="#A020F0">return</FONT></B> self.simple_resolve(dbref.collection)
   28:         <B><FONT COLOR="#A020F0">except</FONT></B> ImportError:
   28:             <B><FONT COLOR="#A020F0">pass</FONT></B>
               <I><FONT COLOR="#B22222"># Let's now try to look up the path from the collection to path
</FONT></I>               <I><FONT COLOR="#B22222"># mapping
</FONT></I>   28:         db = self._jar._conn[self._jar.default_database]
   28:         coll = db[self._jar.name_map_collection]
   28:         result = coll.find(
   28:             {<B><FONT COLOR="#BC8F8F">'collection'</FONT></B>: dbref.collection, <B><FONT COLOR="#BC8F8F">'database'</FONT></B>: dbref.database})
   28:         <B><FONT COLOR="#A020F0">if</FONT></B> result.count() == 0:
    1:             <B><FONT COLOR="#A020F0">raise</FONT></B> ImportError(dbref)
   27:         <B><FONT COLOR="#A020F0">elif</FONT></B> result.count() == 1:
                   <I><FONT COLOR="#B22222"># Do not add these results to the LRU cache, since the count might
</FONT></I>                   <I><FONT COLOR="#B22222"># change later.
</FONT></I>   22:             <B><FONT COLOR="#A020F0">return</FONT></B> self.simple_resolve(result.next()[<B><FONT COLOR="#BC8F8F">'path'</FONT></B>])
               <B><FONT COLOR="#A020F0">else</FONT></B>:
    5:             <B><FONT COLOR="#A020F0">if</FONT></B> dbref.id <B><FONT COLOR="#A020F0">is</FONT></B> None:
    1:                 <B><FONT COLOR="#A020F0">raise</FONT></B> ImportError(dbref)
                   <I><FONT COLOR="#B22222"># Multiple object types are stored in the collection. We have to
</FONT></I>                   <I><FONT COLOR="#B22222"># look at the object to find out the type.
</FONT></I>    4:             obj_doc = self._jar._conn[dbref.database][dbref.collection].find_one(
    4:                 dbref.id, fields=(<B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B>,))
    4:             <B><FONT COLOR="#A020F0">if</FONT></B> <B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B> <B><FONT COLOR="#A020F0">in</FONT></B> obj_doc:
    2:                 klass = self.simple_resolve(obj_doc[<B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B>])
                   <B><FONT COLOR="#A020F0">else</FONT></B>:
                       <I><FONT COLOR="#B22222"># Find the name-map entry where &quot;doc_has_type&quot; is False.
</FONT></I>    2:                 <B><FONT COLOR="#A020F0">for</FONT></B> name_map_item <B><FONT COLOR="#A020F0">in</FONT></B> result:
    2:                     <B><FONT COLOR="#A020F0">if</FONT></B> <B><FONT COLOR="#A020F0">not</FONT></B> name_map_item[<B><FONT COLOR="#BC8F8F">'doc_has_type'</FONT></B>]:
    2:                         klass = self.simple_resolve(name_map_item[<B><FONT COLOR="#BC8F8F">'path'</FONT></B>])
    2:                         <B><FONT COLOR="#A020F0">break</FONT></B>
                       <B><FONT COLOR="#A020F0">else</FONT></B>:
<div class="notcovered">&gt;&gt;&gt;&gt;&gt;&gt;                     <B><FONT COLOR="#A020F0">raise</FONT></B> ImportError(path)</div>    4:             OID_CLASS_LRU[dbref.id] = klass
    4:             <B><FONT COLOR="#A020F0">return</FONT></B> klass
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_non_persistent_object</FONT></B>(self, state, obj):
   24:         <B><FONT COLOR="#A020F0">if</FONT></B> <B><FONT COLOR="#BC8F8F">'_py_type'</FONT></B> <B><FONT COLOR="#A020F0">in</FONT></B> state:
                   <I><FONT COLOR="#B22222"># Handle the simplified case.
</FONT></I>   12:             klass = self.simple_resolve(state.pop(<B><FONT COLOR="#BC8F8F">'_py_type'</FONT></B>))
   12:             sub_obj = copy_reg._reconstructor(klass, object, None)
   12:         <B><FONT COLOR="#A020F0">elif</FONT></B> <B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B> <B><FONT COLOR="#A020F0">in</FONT></B> state:
                   <I><FONT COLOR="#B22222"># Another simple case for persistent objects that do not want
</FONT></I>                   <I><FONT COLOR="#B22222"># their own document.
</FONT></I>   10:             klass = self.simple_resolve(state.pop(<B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B>))
   10:             sub_obj = copy_reg.__newobj__(klass)
               <B><FONT COLOR="#A020F0">else</FONT></B>:
    2:             factory = self.simple_resolve(state.pop(<B><FONT COLOR="#BC8F8F">'_py_factory'</FONT></B>))
    2:             factory_args = self.get_object(state.pop(<B><FONT COLOR="#BC8F8F">'_py_factory_args'</FONT></B>), obj)
    2:             sub_obj = factory(*factory_args)
   24:         <B><FONT COLOR="#A020F0">if</FONT></B> len(state):
   20:             sub_obj_state = self.get_object(state, obj)
   20:             <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(sub_obj, persistent.Persistent):
    9:                 sub_obj.__setstate__(sub_obj_state)
                   <B><FONT COLOR="#A020F0">else</FONT></B>:
   11:                 sub_obj.__dict__.update(sub_obj_state)
   24:         <B><FONT COLOR="#A020F0">if</FONT></B> getattr(sub_obj, <B><FONT COLOR="#BC8F8F">'_p_mongo_sub_object'</FONT></B>, False):
   10:             sub_obj._p_mongo_doc_object = obj
   10:             sub_obj._p_jar = self._jar
   24:         <B><FONT COLOR="#A020F0">return</FONT></B> sub_obj
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_object</FONT></B>(self, state, obj):
  584:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(state, pymongo.objectid.ObjectId):
                   <I><FONT COLOR="#B22222"># The object id is special. Preserve it.
</FONT></I>    1:             <B><FONT COLOR="#A020F0">return</FONT></B> state
  583:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(state, pymongo.binary.Binary):
                   <I><FONT COLOR="#B22222"># Binary data in Python 2 is presented as a string. We will
</FONT></I>                   <I><FONT COLOR="#B22222"># convert back to binary when serializing again.
</FONT></I>    2:             <B><FONT COLOR="#A020F0">return</FONT></B> str(state)
  581:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(state, pymongo.dbref.DBRef):
                   <I><FONT COLOR="#B22222"># Load a persistent object. Using the get_ghost() method, so that
</FONT></I>                   <I><FONT COLOR="#B22222"># caching is properly applied.
</FONT></I>   38:             <B><FONT COLOR="#A020F0">return</FONT></B> self.get_ghost(state)
  543:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(state, dict) <B><FONT COLOR="#A020F0">and</FONT></B> state.get(<B><FONT COLOR="#BC8F8F">'_py_type'</FONT></B>) == <B><FONT COLOR="#BC8F8F">'type'</FONT></B>:
                   <I><FONT COLOR="#B22222"># Convert a simple object reference, mostly classes.
</FONT></I>    1:             <B><FONT COLOR="#A020F0">return</FONT></B> self.simple_resolve(state[<B><FONT COLOR="#BC8F8F">'path'</FONT></B>])
       
               <I><FONT COLOR="#B22222"># Give the custom serializers a chance to weigh in.
</FONT></I>  810:         <B><FONT COLOR="#A020F0">for</FONT></B> serializer <B><FONT COLOR="#A020F0">in</FONT></B> SERIALIZERS:
  275:             <B><FONT COLOR="#A020F0">if</FONT></B> serializer.can_read(state):
    7:                 <B><FONT COLOR="#A020F0">return</FONT></B> serializer.read(state)
       
  535:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(state, dict) <B><FONT COLOR="#A020F0">and</FONT></B> (<B><FONT COLOR="#BC8F8F">'_py_factory'</FONT></B> <B><FONT COLOR="#A020F0">in</FONT></B> state <B><FONT COLOR="#A020F0">or</FONT></B> \
  106:                <B><FONT COLOR="#BC8F8F">'_py_type'</FONT></B> <B><FONT COLOR="#A020F0">in</FONT></B> state <B><FONT COLOR="#A020F0">or</FONT></B> <B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B> <B><FONT COLOR="#A020F0">in</FONT></B> state):
                   <I><FONT COLOR="#B22222"># Load a non-persistent object.
</FONT></I>   20:             <B><FONT COLOR="#A020F0">return</FONT></B> self.get_non_persistent_object(state, obj)
  515:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(state, (tuple, list)):
                   <I><FONT COLOR="#B22222"># All lists are converted to persistent lists, so that their state
</FONT></I>                   <I><FONT COLOR="#B22222"># changes are noticed. Also make sure that all value states are
</FONT></I>                   <I><FONT COLOR="#B22222"># converted to objects.
</FONT></I>   17:             sub_obj = PersistentList(
   40:                 [self.get_object(value, obj) <B><FONT COLOR="#A020F0">for</FONT></B> value <B><FONT COLOR="#A020F0">in</FONT></B> state])
   17:             sub_obj._p_mongo_doc_object = obj
   17:             sub_obj._p_jar = self._jar
   17:             <B><FONT COLOR="#A020F0">return</FONT></B> sub_obj
  498:         <B><FONT COLOR="#A020F0">if</FONT></B> isinstance(state, dict):
                   <I><FONT COLOR="#B22222"># All dictionaries are converted to persistent dictionaries, so
</FONT></I>                   <I><FONT COLOR="#B22222"># that state changes are detected. Also convert all value states
</FONT></I>                   <I><FONT COLOR="#B22222"># to objects.
</FONT></I>                   <I><FONT COLOR="#B22222"># Handle non-string key dicts.
</FONT></I>   87:             <B><FONT COLOR="#A020F0">if</FONT></B> <B><FONT COLOR="#BC8F8F">'dict_data'</FONT></B> <B><FONT COLOR="#A020F0">in</FONT></B> state:
    1:                 items = state[<B><FONT COLOR="#BC8F8F">'dict_data'</FONT></B>]
                   <B><FONT COLOR="#A020F0">else</FONT></B>:
   86:                 items = state.items()
   87:             sub_obj = PersistentDict(
   87:                 [(self.get_object(name, obj), self.get_object(value, obj))
  329:                  <B><FONT COLOR="#A020F0">for</FONT></B> name, value <B><FONT COLOR="#A020F0">in</FONT></B> items])
   87:             sub_obj._p_mongo_doc_object = obj
   87:             sub_obj._p_jar = self._jar
   87:             <B><FONT COLOR="#A020F0">return</FONT></B> sub_obj
  411:         <B><FONT COLOR="#A020F0">return</FONT></B> state
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">set_ghost_state</FONT></B>(self, obj):
               <I><FONT COLOR="#B22222"># Look up the object state by coll_name and oid.
</FONT></I>   47:         coll = self._jar._conn[obj._p_oid.database][obj._p_oid.collection]
   47:         doc = coll.find_one({<B><FONT COLOR="#BC8F8F">'_id'</FONT></B>: obj._p_oid.id})
   47:         doc.pop(<B><FONT COLOR="#BC8F8F">'_id'</FONT></B>)
   47:         doc.pop(<B><FONT COLOR="#BC8F8F">'_py_persistent_type'</FONT></B>, None)
               <I><FONT COLOR="#B22222"># Store the serial, if conflict detection is enabled.
</FONT></I>   47:         <B><FONT COLOR="#A020F0">if</FONT></B> self._jar.detect_conflicts:
    5:             obj._p_serial = p64(doc.pop(<B><FONT COLOR="#BC8F8F">'_py_serial'</FONT></B>, 0))
               <I><FONT COLOR="#B22222"># Now convert the document to a proper Python state dict.
</FONT></I>   47:         state = self.get_object(doc, obj)
               <I><FONT COLOR="#B22222"># Set the state.
</FONT></I>   47:         obj.__setstate__(dict(state))
       
    1:     <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">get_ghost</FONT></B>(self, dbref):
               <I><FONT COLOR="#B22222"># If we can, we return the object from cache.
</FONT></I>  171:         <B><FONT COLOR="#A020F0">try</FONT></B>:
  171:             <B><FONT COLOR="#A020F0">return</FONT></B> self._jar._object_cache[dbref.id]
   66:         <B><FONT COLOR="#A020F0">except</FONT></B> KeyError:
   66:             <B><FONT COLOR="#A020F0">pass</FONT></B>
   66:         klass = self.resolve(dbref)
   66:         obj = klass.__new__(klass)
   66:         obj._p_jar = self._jar
   66:         obj._p_oid = dbref
   66:         <B><FONT COLOR="#A020F0">del</FONT></B> obj._p_changed
               <I><FONT COLOR="#B22222"># Assign the collection after deleting _p_changed, since the attribute
</FONT></I>               <I><FONT COLOR="#B22222"># is otherwise deleted.
</FONT></I>   66:         obj._p_mongo_database = dbref.database
   66:         obj._p_mongo_collection = dbref.collection
               <I><FONT COLOR="#B22222"># Adding the object to the cache is very important, so that we get the
</FONT></I>               <I><FONT COLOR="#B22222"># same object reference throughout the transaction.
</FONT></I>   66:         self._jar._object_cache[dbref.id] = obj
   66:         <B><FONT COLOR="#A020F0">return</FONT></B> obj
</pre>

      <div class="footer">
      Generated for revision 5108:5114M on 2011-11-04 17:02:17.574731Z
      </div>
    </body>
    </html>
