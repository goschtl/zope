       ##############################################################################
       #
       # Copyright (c) 2011 Zope Foundation and Contributors.
       # All Rights Reserved.
       #
       # This software is subject to the provisions of the Zope Public License,
       # Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
       # THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
       # WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
       # WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
       # FOR A PARTICULAR PURPOSE.
       #
       ##############################################################################
    1: """Object Serialization for Mongo/BSON"""
    1: from __future__ import absolute_import
    1: import copy_reg
    1: import struct
       
    1: import lru
    1: import persistent.interfaces
    1: import persistent.dict
    1: import persistent.list
    1: import pymongo.binary
    1: import pymongo.dbref
    1: import pymongo.objectid
    1: import types
    1: import zope.interface
    1: from zope.dottedname.resolve import resolve
       
    1: from mongopersist import interfaces
       
    1: SERIALIZERS = []
    1: OID_CLASS_LRU = lru.LRUCache(20000)
       
    1: def p64(v):
           """Pack an integer or long into a 8-byte string"""
   16:     return struct.pack(">Q", v)
       
    1: def u64(v):
           """Unpack an 8-byte string into a 64-bit long integer."""
   19:     return struct.unpack(">Q", v)[0]
       
    1: def get_dotted_name(obj):
  207:     return obj.__module__+'.'+obj.__name__
       
    2: class PersistentDict(persistent.dict.PersistentDict):
    1:     _p_mongo_sub_object = True
       
    2: class PersistentList(persistent.list.PersistentList):
    1:     _p_mongo_sub_object = True
       
       
    2: class ObjectSerializer(object):
    1:     zope.interface.implements(interfaces.IObjectSerializer)
       
    1:     def can_read(self, state):
    1:         raise NotImplementedError
       
    1:     def read(self, state):
    1:         raise NotImplementedError
       
    1:     def can_write(self, obj):
    1:         raise NotImplementedError
       
    1:     def write(self, obj):
    1:         raise NotImplementedError
       
       
    2: class ObjectWriter(object):
    1:     zope.interface.implements(interfaces.IObjectWriter)
       
    1:     def __init__(self, jar):
  139:         self._jar = jar
       
    1:     def get_collection_name(self, obj):
  168:         db_name = getattr(obj, '_p_mongo_database', self._jar.default_database)
  168:         try:
  168:             coll_name = obj._p_mongo_collection
   99:         except AttributeError:
   99:             return db_name, get_dotted_name(obj.__class__)
               # Make sure that the coll_name to class path mapping is available.
   69:         db = self._jar._conn[self._jar.default_database]
   69:         coll = db[self._jar.name_map_collection]
   69:         map = {'collection': coll_name,
   69:                'database': db_name,
   69:                'path': get_dotted_name(obj.__class__)}
   69:         result = coll.find_one(map)
   69:         if result is None:
                   # If there is already a map for this collection, the next map must
                   # force the object to store the type.
   28:             result = coll.find({'collection': coll_name,
   28:                                 'database': db_name})
   28:             if result.count() > 0:
    3:                 setattr(obj, '_p_mongo_store_type', True)
   28:             map['doc_has_type'] = getattr(obj, '_p_mongo_store_type', False)
   28:             coll.save(map)
   69:         return db_name, coll_name
       
    1:     def get_non_persistent_state(self, obj, seen):
   34:         __traceback_info__ = obj
               # XXX: Look at the pickle library how to properly handle all types and
               # old-style classes with all of the possible pickle extensions.
       
               # Only non-persistent, custom objects can produce unresolvable
               # circular references.
   34:         if obj in seen:
    2:             raise interfaces.CircularReferenceError(obj)
               # Add the current object to the list of seen objects.
   32:         seen.append(obj)
               # Get the state of the object. Only pickable objects can be reduced.
   32:         reduced = obj.__reduce__()
               # The full object state (item 3) seems to be optional, so let's make
               # sure we handle that case gracefully.
   32:         if len(reduced) == 2:
    2:             factory, args = obj.__reduce__()
    2:             obj_state = {}
               else:
   30:             factory, args, obj_state = reduced
               # We are trying very hard to create a clean Mongo (sub-)document. But
               # we need a little bit of meta-data to help us out later.
   32:         if factory == copy_reg._reconstructor and \
   16:                args == (obj.__class__, object, None):
                   # This is the simple case, which means we can produce a nicer
                   # Mongo output.
   16:             state = {'_py_type': get_dotted_name(args[0])}
   16:         elif factory == copy_reg.__newobj__ and args == (obj.__class__,):
                   # Another simple case for persistent objects that do not want
                   # their own document.
   14:             state = {'_py_persistent_type': get_dotted_name(args[0])}
               else:
    2:             state = {'_py_factory': get_dotted_name(factory),
    2:                      '_py_factory_args': self.get_state(args, seen)}
   86:         for name, value in obj_state.items():
   56:             state[name] = self.get_state(value, seen)
   30:         return state
       
    1:     def get_persistent_state(self, obj, seen):
   73:         __traceback_info__ = obj
               # Persistent sub-objects are stored by reference, the key being
               # (collection name, oid).
               # Getting the collection name is easy, but if we have an unsaved
               # persistent object, we do not yet have an OID. This must be solved by
               # storing the persistent object.
   73:         if obj._p_oid is None:
   11:             dbref = self.store(obj, ref_only=True)
               else:
   62:             db_name, coll_name = self.get_collection_name(obj)
   62:             dbref = obj._p_oid
               # Create the reference sub-document. The _p_type value helps with the
               # deserialization later.
   73:         return dbref
       
    1:     def get_state(self, obj, seen=None):
  478:         seen = seen or []
  478:         if isinstance(obj, interfaces.MONGO_NATIVE_TYPES):
                   # If we have a native type, we'll just use it as the state.
  189:             return obj
  289:         if isinstance(obj, str):
                   # In Python 2, strings can be ASCII, encoded unicode or binary
                   # data. Unfortunately, BSON cannot handle that. So, if we have a
                   # string that cannot be UTF-8 decoded (luckily ASCII is a valid
                   # subset of UTF-8), then we use the BSON binary type.
   50:             try:
   50:                 obj.decode('utf-8')
   48:                 return obj
    2:             except UnicodeError:
    2:                 return pymongo.binary.Binary(obj)
       
               # Some objects might not naturally serialize well and create a very
               # ugly Mongo entry. Thus, we allow custom serializers to be
               # registered, which can encode/decode different types of objects.
  317:         for serializer in SERIALIZERS:
   85:             if serializer.can_write(obj):
    7:                 return serializer.write(obj)
       
  232:         if isinstance(obj, (type, types.ClassType)):
                   # We frequently store class and function paths as meta-data, so we
                   # need to be able to properly encode those.
    2:             return {'_py_type': 'type',
    2:                     'path': get_dotted_name(obj)}
  230:         if isinstance(obj, (tuple, list, PersistentList)):
                   # Make sure that all values within a list are serialized
                   # correctly. Also convert any sequence-type to a simple list.
   47:             return [self.get_state(value, seen) for value in obj]
  209:         if isinstance(obj, (dict, PersistentDict)):
                   # Same as for sequences, make sure that the contained values are
                   # properly serialized.
                   # Note: A big constraint in Mongo is that keys must be strings!
  109:             has_non_string_key = False
  109:             data = []
  373:             for key, value in obj.items():
  265:                 data.append((key, self.get_state(value, seen)))
  264:                 has_non_string_key |= not isinstance(key, basestring)
  108:             if not has_non_string_key:
                       # The easy case: all keys are strings:
  107:                 return dict(data)
                   else:
                       # We first need to reduce the keys and then produce a data
                       # structure.
    4:                 data = [(self.get_state(key), value) for key, value in data]
    1:                 return {'dict_data': data}
       
  100:         if isinstance(obj, persistent.Persistent):
                   # Only create a persistent reference, if the object does not want
                   # to be a sub-document.
   84:             if not getattr(obj, '_p_mongo_sub_object', False):
   71:                 return self.get_persistent_state(obj, seen)
                   # This persistent object is a sub-document, so it is treated like
                   # a non-persistent object.
       
   29:         return self.get_non_persistent_state(obj, seen)
       
    1:     def store(self, obj, ref_only=False):
   96:         db_name, coll_name = self.get_collection_name(obj)
   96:         coll = self._jar._conn[db_name][coll_name]
   96:         if ref_only:
                   # We only want to get OID quickly. Trying to reduce the full state
                   # might cause infinite recusrion loop. (Example: 2 new objects
                   # reference each other.)
   11:             doc = {}
                   # Make sure that the object gets saved fully later.
   11:             self._jar.register(obj)
               else:
                   # XXX: Handle newargs; see ZODB.serialize.ObjectWriter.serialize
                   # Go through each attribute and search for persistent references.
   85:             doc = self.get_state(obj.__getstate__())
   95:         if getattr(obj, '_p_mongo_store_type', False):
    4:             doc['_py_persistent_type'] = get_dotted_name(obj.__class__)
               # If conflict detection is turned on, store a serial number for the
               # document.
   95:         if self._jar.detect_conflicts:
   11:             doc['_py_serial'] = u64(getattr(obj, '_p_serial', 0)) + 1
   11:             obj._p_serial = p64(doc['_py_serial'])
       
   95:         if obj._p_oid is None:
   63:             doc_id = coll.insert(doc)
   63:             obj._p_jar = self._jar
   63:             obj._p_oid = pymongo.dbref.DBRef(coll_name, doc_id, db_name)
                   # Make sure that any other code accessing this object in this
                   # session, gets the same instance.
   63:             self._jar._object_cache[doc_id] = obj
               else:
   32:             doc['_id'] = obj._p_oid.id
   32:             coll.save(doc)
   95:         return obj._p_oid
       
       
    2: class ObjectReader(object):
    1:     zope.interface.implements(interfaces.IObjectReader)
       
    1:     def __init__(self, jar):
  138:         self._jar = jar
       
    1:     def simple_resolve(self, path):
  118:         return resolve(path)
       
    1:     def resolve(self, dbref):
   72:         try:
   72:             return OID_CLASS_LRU[dbref.id]
   66:         except KeyError:
   66:             pass
               # First we try to resolve the path directly.
   66:         try:
   66:             return self.simple_resolve(dbref.collection)
   28:         except ImportError:
   28:             pass
               # Let's now try to look up the path from the collection to path
               # mapping
   28:         db = self._jar._conn[self._jar.default_database]
   28:         coll = db[self._jar.name_map_collection]
   28:         result = coll.find(
   28:             {'collection': dbref.collection, 'database': dbref.database})
   28:         if result.count() == 0:
    1:             raise ImportError(dbref)
   27:         elif result.count() == 1:
                   # Do not add these results to the LRU cache, since the count might
                   # change later.
   22:             return self.simple_resolve(result.next()['path'])
               else:
    5:             if dbref.id is None:
    1:                 raise ImportError(dbref)
                   # Multiple object types are stored in the collection. We have to
                   # look at the object to find out the type.
    4:             obj_doc = self._jar._conn[dbref.database][dbref.collection].find_one(
    4:                 dbref.id, fields=('_py_persistent_type',))
    4:             if '_py_persistent_type' in obj_doc:
    2:                 klass = self.simple_resolve(obj_doc['_py_persistent_type'])
                   else:
                       # Find the name-map entry where "doc_has_type" is False.
    2:                 for name_map_item in result:
    2:                     if not name_map_item['doc_has_type']:
    2:                         klass = self.simple_resolve(name_map_item['path'])
    2:                         break
                       else:
>>>>>>                     raise ImportError(path)
    4:             OID_CLASS_LRU[dbref.id] = klass
    4:             return klass
       
    1:     def get_non_persistent_object(self, state, obj):
   24:         if '_py_type' in state:
                   # Handle the simplified case.
   12:             klass = self.simple_resolve(state.pop('_py_type'))
   12:             sub_obj = copy_reg._reconstructor(klass, object, None)
   12:         elif '_py_persistent_type' in state:
                   # Another simple case for persistent objects that do not want
                   # their own document.
   10:             klass = self.simple_resolve(state.pop('_py_persistent_type'))
   10:             sub_obj = copy_reg.__newobj__(klass)
               else:
    2:             factory = self.simple_resolve(state.pop('_py_factory'))
    2:             factory_args = self.get_object(state.pop('_py_factory_args'), obj)
    2:             sub_obj = factory(*factory_args)
   24:         if len(state):
   20:             sub_obj_state = self.get_object(state, obj)
   20:             if isinstance(sub_obj, persistent.Persistent):
    9:                 sub_obj.__setstate__(sub_obj_state)
                   else:
   11:                 sub_obj.__dict__.update(sub_obj_state)
   24:         if getattr(sub_obj, '_p_mongo_sub_object', False):
   10:             sub_obj._p_mongo_doc_object = obj
   10:             sub_obj._p_jar = self._jar
   24:         return sub_obj
       
    1:     def get_object(self, state, obj):
  584:         if isinstance(state, pymongo.objectid.ObjectId):
                   # The object id is special. Preserve it.
    1:             return state
  583:         if isinstance(state, pymongo.binary.Binary):
                   # Binary data in Python 2 is presented as a string. We will
                   # convert back to binary when serializing again.
    2:             return str(state)
  581:         if isinstance(state, pymongo.dbref.DBRef):
                   # Load a persistent object. Using the get_ghost() method, so that
                   # caching is properly applied.
   38:             return self.get_ghost(state)
  543:         if isinstance(state, dict) and state.get('_py_type') == 'type':
                   # Convert a simple object reference, mostly classes.
    1:             return self.simple_resolve(state['path'])
       
               # Give the custom serializers a chance to weigh in.
  810:         for serializer in SERIALIZERS:
  275:             if serializer.can_read(state):
    7:                 return serializer.read(state)
       
  535:         if isinstance(state, dict) and ('_py_factory' in state or \
  106:                '_py_type' in state or '_py_persistent_type' in state):
                   # Load a non-persistent object.
   20:             return self.get_non_persistent_object(state, obj)
  515:         if isinstance(state, (tuple, list)):
                   # All lists are converted to persistent lists, so that their state
                   # changes are noticed. Also make sure that all value states are
                   # converted to objects.
   17:             sub_obj = PersistentList(
   40:                 [self.get_object(value, obj) for value in state])
   17:             sub_obj._p_mongo_doc_object = obj
   17:             sub_obj._p_jar = self._jar
   17:             return sub_obj
  498:         if isinstance(state, dict):
                   # All dictionaries are converted to persistent dictionaries, so
                   # that state changes are detected. Also convert all value states
                   # to objects.
                   # Handle non-string key dicts.
   87:             if 'dict_data' in state:
    1:                 items = state['dict_data']
                   else:
   86:                 items = state.items()
   87:             sub_obj = PersistentDict(
   87:                 [(self.get_object(name, obj), self.get_object(value, obj))
  329:                  for name, value in items])
   87:             sub_obj._p_mongo_doc_object = obj
   87:             sub_obj._p_jar = self._jar
   87:             return sub_obj
  411:         return state
       
    1:     def set_ghost_state(self, obj):
               # Look up the object state by coll_name and oid.
   47:         coll = self._jar._conn[obj._p_oid.database][obj._p_oid.collection]
   47:         doc = coll.find_one({'_id': obj._p_oid.id})
   47:         doc.pop('_id')
   47:         doc.pop('_py_persistent_type', None)
               # Store the serial, if conflict detection is enabled.
   47:         if self._jar.detect_conflicts:
    5:             obj._p_serial = p64(doc.pop('_py_serial', 0))
               # Now convert the document to a proper Python state dict.
   47:         state = self.get_object(doc, obj)
               # Set the state.
   47:         obj.__setstate__(dict(state))
       
    1:     def get_ghost(self, dbref):
               # If we can, we return the object from cache.
  171:         try:
  171:             return self._jar._object_cache[dbref.id]
   66:         except KeyError:
   66:             pass
   66:         klass = self.resolve(dbref)
   66:         obj = klass.__new__(klass)
   66:         obj._p_jar = self._jar
   66:         obj._p_oid = dbref
   66:         del obj._p_changed
               # Assign the collection after deleting _p_changed, since the attribute
               # is otherwise deleted.
   66:         obj._p_mongo_database = dbref.database
   66:         obj._p_mongo_collection = dbref.collection
               # Adding the object to the cache is very important, so that we get the
               # same object reference throughout the transaction.
   66:         self._jar._object_cache[dbref.id] = obj
   66:         return obj
