Zope transactions and sqlalchemy
================================

When a zope transaction is used also a sqlalchemy transaction must be
activated. "zalchemy" installs a data manager every time a new zope
transaction is created. 

Setup zope's test environment :

  >>> from zope.app.testing.placelesssetup import setUp, tearDown
  >>> setUp()

Create a utility to provide a database :

  >>> from zope.component import provideUtility
  >>> from zalchemy.datamanager import AlchemyEngineUtility
  >>> engineUtility = AlchemyEngineUtility('database',
  ...                                      'sqlite://filename=abc.db',
  ...                                      echo=False)
  >>> provideUtility(engineUtility, name="test")

Setup a sqlalchemy table and class :

  >>> import sqlalchemy
  >>> proxy = sqlalchemy.ext.proxy.ProxyEngine()
  >>> aTable = sqlalchemy.Table(
  ...     'aTable',
  ...     proxy,
  ...     sqlalchemy.Column('id', sqlalchemy.Integer, primary_key = True),
  ...     sqlalchemy.Column('x', sqlalchemy.Integer),
  ...     )
  >>> class A(object):
  ...   pass
  >>> sqlalchemy.assign_mapper(A, aTable)


We need to register a connection between the engine and the table.
This connetion will be used later to connect the proxy in aTable with
a real engine.

  >>> import os
  >>> try:
  ...     os.remove('abc.db')
  ... except:
  ...     pass

We need a connection between the database and the table :
  This is done manually here but can also be done using the
  connect ZCML directive.

  >>> engineUtility.addTable(aTable)

Now start a zope transaction :

  >>> import transaction
  >>> txn = transaction.begin()

Now we need to connect our table to a real engine :

  >>> from zalchemy.datamanager import beforeTraversal
  >>> beforeTraversal(None)

  >>> aTable.engine.engine is not None
  True

Because we now have a connection to a brand new database we need to create
the table.

  >>> try:
  ...     dummy = aTable.create()
  ... except:
  ...    pass

  >>> a=A()
  >>> a.x = 1

  >>> transaction.get().commit()
  >>> a=None

Now we must be able to use the newly created object from within another
thread :

  >>> import threading
  >>> log = []
  >>> def do():
  ...     txn = transaction.begin()
  ...     beforeTraversal(None)
  ...     obj = A.get(1)
  ...     log.append(obj.x)
  ...     obj.x+= 1
  ...     transaction.get().commit()
  ...

  >>> thread = threading.Thread(target=do)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [1]
  >>> log = []
  >>> thread = threading.Thread(target=do)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [2]

  >>> def doSubThread():
  ...     txn = transaction.begin()
  ...     beforeTraversal(None)
  ...     obj = A.get(1)
  ...     thread = threading.Thread(target=do)
  ...     thread.start()
  ...     thread.join()
  ...     log.append(obj.x)
  ...     obj.x+= 1
  ...     transaction.get().commit()
  ...

  >>> log = []
  >>> thread = threading.Thread(target=doSubThread)
  >>> thread.start()
  >>> thread.join()

TODO:
Can we accept this ?
This result shows, that a running transaction is not aborted or rolled back
if another transaction was commited between begin and commit !
Or does this only happen with sqlite ?

  >>> log
  [3, 3]

Use of a second table with the same engine :

  >>> bTable = sqlalchemy.Table(
  ...     'bTable',
  ...     proxy,
  ...     sqlalchemy.Column('id', sqlalchemy.Integer, primary_key = True),
  ...     sqlalchemy.Column('x', sqlalchemy.Integer),
  ...     )
  >>> class B(object):
  ...   pass
  >>> sqlalchemy.assign_mapper(B, bTable)

Connect the new table to the already existing database :

  >>> engineUtility.addTable(bTable)

  >>> log = []
  >>> def createB():
  ...     txn = transaction.begin()
  ...     beforeTraversal(None)
  ...     obj=B()
  ...     obj.x=1
  ...     log.append(obj.x)
  ...     transaction.get().commit()
  ...
  >>> def doB():
  ...     txn = transaction.begin()
  ...     beforeTraversal(None)
  ...     obj = B.get(1)
  ...     log.append(obj.x)
  ...     obj.x+= 1
  ...     transaction.get().commit()
  ...

  >>> thread = threading.Thread(target=createB)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [1]

  >>> log = []
  >>> thread = threading.Thread(target=doB)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [1]

  >>> tearDown()

