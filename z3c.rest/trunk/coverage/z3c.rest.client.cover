       ##############################################################################
       #
       # Copyright (c) 2007 Zope Corporation and Contributors.
       # All Rights Reserved.
       #
       # This software is subject to the provisions of the Zope Public License,
       # Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
       # THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
       # WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
       # WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
       # FOR A PARTICULAR PURPOSE.
       #
       ##############################################################################
       """REST Client
       
       $Id: http.py 72310 2007-02-01 21:39:01Z mkerrin $
    1: """
    1: import lxml
    1: import httplib
    1: import socket
    1: import urllib
    1: import urlparse
    1: import base64
    1: import zope.interface
    1: from z3c.rest import interfaces
       
    1: def isRelativeURL(url):
           """Determines whether the given URL is a relative path segment."""
   37:     pieces = urlparse.urlparse(url)
   37:     if not pieces[0] and not pieces[1]:
    5:         return True
   32:     return False
       
    1: def absoluteURL(base, url):
           """Convertes a URL to an absolute URL given a base."""
   37:     if isRelativeURL(url):
    5:         fullUrl = urlparse.urljoin(base, url)
           else:
   32:         fullUrl = url
   37:     pieces = list(urlparse.urlparse(fullUrl))
   37:     if not pieces[2].endswith('/'):
   18:         pieces[2] += '/'
   37:     return urlparse.urlunparse(pieces)
       
    1: def getFullPath(pieces, params):
           """Build a full httplib request path, including a query string."""
   32:     query = ''
   32:     if pieces[4]:
    2:         query = pieces[4]
   32:     if params:
    2:         encParams = urllib.urlencode(params)
    2:         if query:
    1:             query += '&' + encParams
               else:
    1:             query = encParams
   32:     return urlparse.urlunparse(
               ('', '', pieces[2], pieces[3], query, pieces[5]))
       
       
    2: class XLink(object):
           """A link implementation for simple XLinks."""
    1:     zope.interface.implements(interfaces.ILink)
       
    1:     def __init__(self, client, title, url):
    5:         self._client = client
    5:         self.title = title
    5:         self.url = url
       
    1:     def click(self):
               """See interfaces.ILink"""
    3:         self._client.get(self.url)
       
    1:     def __repr__(self):
    2:         return '<%s title=%r url=%r>' %(
                   self.__class__.__name__, self.title, self.url)
       
       
    2: class RESTClient(object):
    1:     zope.interface.implements(interfaces.IRESTClient)
       
    1:     connectionFactory = httplib.HTTPConnection
       
    1:     def __init__(self, url=None):
    3:         self.requestHeaders = {}
    3:         self._reset()
    3:         self._history = []
    3:         self._requestData = None
    3:         self.url = ''
    3:         if url:
    1:             self.open(url)
       
    1:     @property
           def fullStatus(self):
   12:         return '%i %s' %(self.status, self.reason)
       
    1:     def _reset(self):
   35:         self.headers = []
   35:         self.contents = {}
   35:         self.status = None
   35:         self.reason = None
       
    1:     def open(self, url='', data=None, params=None, headers=None, method='GET'):
               # Create a correct absolute URL and set it.
   32:         self.url = absoluteURL(self.url, url)
       
               # Create the full set of request headers
   32:         requestHeaders = self.requestHeaders.copy()
   32:         if headers:
    1:             requestHeaders.update(headers)
       
               # Let's now reset all response values
   32:         self._reset()
       
               # Store all the request data
   32:         self._requestData = (url, data, params, headers, method)
       
               # Make a connection and retrieve the result
   32:         pieces = urlparse.urlparse(self.url)
   32:         connection = self.connectionFactory(pieces[1])
   32:         try:
   32:             connection.request(
                       method, getFullPath(pieces, params), data, requestHeaders)
   30:             response = connection.getresponse()
   30:             connection.close()
    2:         except socket.error, e:
    1:             connection.close()
    1:             self.status, self.reason = e.args
    1:             self._addHistory()
    1:             raise e
               else:
   30:             self.headers = response.getheaders()
   30:             self.contents = response.read()
   30:             self.status = response.status
   30:             self.reason = response.reason
   30:             self._addHistory()
       
    1:     def get(self, url='', params=None, headers=None):
   17:         self.open(url, None, params, headers)
       
    1:     def put(self, url='', data='', params=None, headers=None):
    6:         self.open(url, data, params, headers, 'PUT')
       
    1:     def post(self, url='', data='', params=None, headers=None):
    1:         self.open(url, data, params, headers, 'POST')
       
    1:     def delete(self, url='', params=None, headers=None):
    4:         self.open(url, None, params, headers, 'DELETE')
       
    1:     def setCredentials(self, username, password):
    1:         creds = username + u':' + password
    1:         creds = "Basic " + base64.encodestring(creds.encode('utf-8')).strip()
    1:         self.requestHeaders['Authorization'] = creds
       
    1:     def _addHistory(self):
   31:         self._history.append((
                   self.url, self.requestHeaders, self.headers, self.contents,
                   self.status, self.reason, self._requestData
                   ))
       
    1:     def goBack(self, count=1):
               # The user really does not want to go back.
    4:         if count == 0:
    1:             return
               # The user wants to reach before a pre-historical state.
    3:         if len(self._history) < count:
    1:             raise ValueError('There is not enough history.')
               # Let's now get the entry and set the history back to that state.
    2:         entry = self._history[-(count+1)]
    2:         self._history = self._history[:-count]
               # Reset the state.
    2:         (self.url, self.requestHeaders, self.headers, self.contents,
                self.status, self.reason, self._requestData) = entry
       
    1:     def reload(self):
    1:         self.open(*self._requestData)
       
    1:     def getLink(self, title=None, url=None, index=0):
    6:         nsmap = {'xlink': "http://www.w3.org/1999/xlink"}
    6:         tree = lxml.etree.fromstring(self.contents)
    6:         res = []
    6:         if title is not None:
    4:             res = tree.xpath(
                       '//*[@xlink:title="%s"]' %title, nsmap)
    2:         elif url is not None:
    1:             res = tree.xpath(
                       '//*[@xlink:href="%s"]' %url, nsmap)
               else:
    1:             raise ValueError('You must specify a title or URL.')
    5:         elem = res[index]
    5:         url = elem.attrib.get('{%(xlink)s}href' %nsmap, '')
    5:         return XLink(self,
    5:                      elem.attrib.get('{%(xlink)s}title' %nsmap),
    5:                      absoluteURL(self.url, url))
       
    1:     def xpath(self, expr, nsmap=None, single=False):
    3:         res = lxml.etree.fromstring(self.contents).xpath(expr, nsmap)
    3:         if not single:
    1:             return res
    2:         if len(res) != 1:
    1:             raise ValueError('XPath expression returned more than one result.')
    1:         return res[0]
