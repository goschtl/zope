zope.introspector.util
**********************

Helper functions for the zope.introspector

:Test-Layer: unit

is_namespace_package
====================

Tell, whether a dotted name denotes a namespace package::

  >>> from zope.introspector.util import is_namespace_package
  >>> is_namespace_package('zope')
  True

  >>> is_namespace_package('zope.app')
  True

  >>> is_namespace_package('zope.app.file')
  False

  >>> is_namespace_package('zope.introspector')
  False


get_package_items
=================

A function to gather names of items that are contained in a
package. It looks for modules, subpackages and text files of type
.txt, .rst and .zcml::

  >>> from zope.introspector.util import get_package_items
  >>> sorted(get_package_items('zope.introspector'))
  ['README.txt', 'adapters', ..., 'meta.zcml', ..., 'tests', 
  ... ..., 'viewinfo.txt']

It can also handle namespace packages::

  >>> sorted(get_package_items('zope'))
  ['annotation', 'app', ..., 'traversing']

Often the `zope` package is installed as a zipped egg, but as we can
see here, that makes no difference.

The function ignores directories that are not Python packages and
hidden files and directories, i.e. such starting with a dot in their
name.


getFunctionSignature(func)
==========================

This helper function was taken from ``zope.app.apidoc``.

Return the signature of a function or method. The `func` argument *must* be a
generic function or a method of a class.

First, we get the signature of a function that has a specific positional and
keyword argument:

  >>> from zope.introspector.util import get_function_signature
  >>> def func(attr, attr2=None):
  ...     pass
  >>> get_function_signature(func)
  '(attr, attr2=None)'

Here is a function that has an unspecified amount of keyword arguments:

  >>> def func(attr, **kw):
  ...     pass
  >>> get_function_signature(func)
  '(attr, **kw)'

And here we mix specified and unspecified keyword arguments:

  >>> def func(attr, attr2=None, **kw):
  ...     pass
  >>> get_function_signature(func)
  '(attr, attr2=None, **kw)'

In the next example we have unspecified positional and keyword arguments:

  >>> def func(*args, **kw):
  ...     pass
  >>> get_function_signature(func)
  '(*args, **kw)'

And finally an example, where we have on unspecified keyword arguments without
any positional arguments:

  >>> def func(**kw):
  ...     pass
  >>> get_function_signature(func)
  '(**kw)'

Next we test whether the signature is correctly determined for class
methods. Note that the `self` argument is removed from the signature, since it
is not essential for documentation.

We start out with a simple positional argument:

  >>> class Klass(object):
  ...     def func(self, attr):
  ...         pass
  >>> get_function_signature(Klass.func)
  '(attr)'

Next we have specific and unspecified positional arguments as well as
unspecified keyword arguments:

  >>> class Klass(object):
  ...     def func(self, attr, *args, **kw):
  ...         pass
  >>> get_function_signature(Klass.func)
  '(attr, *args, **kw)'

If you do not pass a function or method to the function, it will fail:

  >>> get_function_signature('func')
  Traceback (most recent call last):
  ...
  TypeError: func must be a function or method

A very uncommon, but perfectly valid, case is that tuple arguments are
unpacked inside the argument list of the function. Here is an example:

  >>> def func((arg1, arg2)):
  ...     pass
  >>> get_function_signature(func)
  '((arg1, arg2))'

Even default assignment is allowed:

  >>> def func((arg1, arg2)=(1, 2)):
  ...     pass
  >>> get_function_signature(func)
  '((arg1, arg2)=(1, 2))'

However, lists of this type are not allowed inside the argument list:

  >>> def func([arg1, arg2]):
  ...     pass
  Traceback (most recent call last):
  ...
  SyntaxError: invalid syntax

Internal assignment is also not legal:

  >>> def func((arg1, arg2=1)):
  ...     pass
  Traceback (most recent call last):
  ...
  SyntaxError: invalid syntax


