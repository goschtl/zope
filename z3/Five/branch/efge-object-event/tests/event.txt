================
Container events
================

Zope 3 container events are used to inform subscribers that an object is
about to be added/removed from a container, and also after it has been
done. This is used for bookkeeping and cleaning up in subobjects.

These events replace the Zope 2 manage_afterAdd, manage_beforeDelete and
manage_afterClone methods.

Phases
======

There are 4 steps to the migration process of having Zope 2 use Zope 3
container events.

Phase 1
-------

Original Zope 2 status, where no events are sent, and manage_afterAdd &
co are called on the children.

Phase 2
-------

<five:containerEvents transitional="true"/>

Some content classes have been migrated to using Zope 3 events.

All standard Zope containers send Zope 3 events. Their manage_afterAdd &
co methods do not do recursion anymore, and send a deprecation warning
if called. The dispatching to subobjects is done through the standard
Zope 3 dispatchToSublocations subscriber.

Containers will still call manage_afterAdd & co (with a deprecation
warning) for content classes not specified in a::

  <five:containerEventAware class="some.content.class"/>

directive.

Phase 3
-------

<five:containerEvents/>

Most content classes have been migrated to using Zope 3 events.

All standard Zope containers will only call manage_afterAdd & co on
classes specified in a::

  <five:deprecatedManageAddDelete class="some.content.class"/>

directive. A deprecation warning is sent for these.

<five:containerEventAware/> is deprecated, as it is now the default
for other classes.

Phase 4
-------

All content classes use Zope 3 events. <five:containerEvents/> is
deprecated as it is now the default. <five:deprecatedManageAddDelete/>
is forbidden.


Testing
=======

Let's see what happens for these phases. There is a bit of setup for the
tests.

  >>> from zope.app.tests.placelesssetup import setUp, tearDown
  >>> setUp()

Because we'll test copy/paste, we need to work inside a database.

  >>> import ZODB.tests.util
  >>> db = ZODB.tests.util.DB()
  >>> connection = db.open()
  >>> root = connection.root()

We'll use two simple classes (defined in python code for picklability)
and simple folders for our tests.

  >>> from Products.Five.tests.test_event import MyApp, MyContent
  >>> from Products.Five.tests.test_event import MyFolder, MyBTreeFolder
  >>> from Products.Five.tests.test_event import MyOrderedFolder

  >>> app = MyApp('')
  >>> root['app'] = app
  >>> folder = MyFolder('folder')
  >>> app._setObject('folder', folder)
  old manage_afterAdd folder folder
  'folder'
  >>> folder = app.folder
  >>> btfolder = MyBTreeFolder('btfolder')
  >>> app._setObject('btfolder', btfolder)
  old manage_afterAdd btfolder btfolder
  'btfolder'

To observe what object events are dispatched, we'll have some
subscribers print them. We'll actually do that for a specific interface,
not for (None, IObjectEvent), and register our subscribers before the
framework's ones, so ours will be called first. This has the effect that
printed events will be in their "natural" order.

  >>> from zope.app.event.interfaces import IObjectEvent
  >>> from zope.app.container.interfaces import IObjectMovedEvent
  >>> from Products.Five.event import IObjectWillBeMovedEvent
  >>> from Products.Five.event import IFiveObjectClonedEvent
  >>> from OFS.interfaces import IObjectManager
  >>> from OFS.interfaces import ISimpleItem
  >>> from zope.app.tests import ztapi
  >>> def printObjectEvent(object, event):
  ...     print event.__class__.__name__, object.getId()
  >>> def printObjectEventExceptSome(object, event):
  ...     if (IObjectMovedEvent.providedBy(event) or
  ...         IObjectWillBeMovedEvent.providedBy(event) or
  ...         IFiveObjectClonedEvent.providedBy(event)):
  ...         return
  ...     print event.__class__.__name__, object.getId()
  >>> ztapi.handle([IObjectManager, IObjectMovedEvent], printObjectEvent)
  >>> ztapi.handle([ISimpleItem, IObjectMovedEvent], printObjectEvent)
  >>> ztapi.handle([IObjectManager, IObjectWillBeMovedEvent], printObjectEvent)
  >>> ztapi.handle([ISimpleItem, IObjectWillBeMovedEvent], printObjectEvent)
  >>> ztapi.handle([IObjectManager, IFiveObjectClonedEvent], printObjectEvent)
  >>> ztapi.handle([ISimpleItem, IFiveObjectClonedEvent], printObjectEvent)
  >>> ztapi.handle([None, IObjectEvent], printObjectEventExceptSome)

Phase 1
-------

Let's test standard folder operations. The methods manage_afterAdd and
manage_beforeDelete, and several others, are called.

  >>> ob = MyContent('milou')
  >>> folder._setObject('milou', ob)
  old manage_afterAdd milou milou folder
  'milou'
  >>> folder.manage_delObjects('milou')
  old manage_beforeDelete milou milou folder

We can also move objects.

  >>> ob = MyContent('tintin')
  >>> folder._setObject('tintin', ob)
  old manage_afterAdd tintin tintin folder
  'tintin'
  >>> cp = folder.manage_cutObjects('tintin')
  >>> folder.manage_pasteObjects(cp)
  old manage_beforeDelete tintin tintin folder
  old manage_afterAdd tintin tintin folder
  [{'new_id': 'tintin', 'id': 'tintin'}]

And we can copy them.

  >>> cp = folder.manage_copyObjects('tintin')
  >>> folder.manage_pasteObjects(cp)
  old manage_afterAdd copy_of_tintin copy_of_tintin folder
  old manage_afterClone copy_of_tintin copy_of_tintin
  [{'new_id': 'copy_of_tintin', 'id': 'tintin'}]

We can rename objects:

  >>> folder.manage_renameObject('copy_of_tintin', 'haddock')
  old manage_beforeDelete copy_of_tintin copy_of_tintin folder
  old manage_afterAdd haddock haddock folder

We can also call manage_clone by hand:

  >>> res = folder.manage_clone(folder.tintin, 'tournesol')
  old manage_afterAdd tournesol tournesol folder
  old manage_afterClone tournesol tournesol
  >>> res.getId()
  'tournesol'

Let's also test with a BTreeFolder:

  >>> ob = MyContent('castafiore')
  >>> btfolder._setObject('castafiore', ob)
  old manage_afterAdd castafiore castafiore btfolder
  'castafiore'
  >>> btfolder.manage_delObjects('castafiore')
  old manage_beforeDelete castafiore castafiore btfolder

When a tree of objects is affected, the methods are called for all
levels.

  >>> subfolder = MyFolder('subfolder')
  >>> folder._setObject('subfolder', subfolder)
  old manage_afterAdd subfolder subfolder folder
  'subfolder'
  >>> subfolder = folder.subfolder
  >>> ob = MyContent('riri')
  >>> subfolder._setObject('riri', ob)
  old manage_afterAdd riri riri subfolder
  'riri'

Renaming a tree of objects. Note that manage_beforeDelete is called
bottom-up.

  >>> folder.manage_renameObject('subfolder', 'bob')
  old manage_beforeDelete riri subfolder folder
  old manage_beforeDelete subfolder subfolder folder
  old manage_afterAdd bob bob folder
  old manage_afterAdd riri bob folder

Cloning a tree of objects:

  >>> res = folder.manage_clone(folder.bob, 'loulou')
  old manage_afterAdd loulou loulou folder
  old manage_afterAdd riri loulou folder
  old manage_afterClone loulou loulou
  old manage_afterClone riri loulou
  >>> res.getId()
  'loulou'

Phase 2
-------

In this phase, transitional events are in effect.

We need some of the Five setup, to get proper five:interfaces declared
for Zope 2 classes.

  >>> from Products.Five import zcml
  >>> import Products.Five
  >>> zcml.load_config('meta.zcml', Products.Five)
  >>> zcml.load_config('interfaces.zcml', Products.Five)

Phase 2 is when we're using <five:containerEvents transitional="true"/>

  >>> from Products.Five.event import doMonkies, undoMonkies
  >>> doMonkies(transitional=True)

When we add an instance of an old class for which we haven't specified
anything, some events are sent but the old manage_afterAdd method is
also called.

  >>> ob = MyContent('lassie')
  >>> folder._setObject('lassie', ob)
  ObjectWillBeAddedEvent lassie
  ObjectAddedEvent lassie
  old manage_afterAdd lassie lassie folder
  'lassie'

And when we delete the object, manage_beforeDelete is also called and
events are sent.

  >>> folder.manage_delObjects('lassie')
  ObjectWillBeRemovedEvent lassie
  old manage_beforeDelete lassie lassie folder
  ObjectRemovedEvent lassie

The old behavior happens for a move or a copy, with events too.
For a move:

  >>> ob = MyContent('blueberry')
  >>> folder._setObject('blueberry', ob)
  ObjectWillBeAddedEvent blueberry
  ObjectAddedEvent blueberry
  old manage_afterAdd blueberry blueberry folder
  'blueberry'
  >>> cp = folder.manage_cutObjects('blueberry')
  >>> folder.manage_pasteObjects(cp)
  ObjectWillBeMovedEvent blueberry
  old manage_beforeDelete blueberry blueberry folder
  ObjectMovedEvent blueberry
  old manage_afterAdd blueberry blueberry folder
  [{'new_id': 'blueberry', 'id': 'blueberry'}]

Old behavior with events for a copy:

  >>> cp = folder.manage_copyObjects('blueberry')
  >>> folder.manage_pasteObjects(cp)
  ObjectCopiedEvent copy_of_blueberry
  ObjectWillBeAddedEvent copy_of_blueberry
  ObjectAddedEvent copy_of_blueberry
  old manage_afterAdd copy_of_blueberry copy_of_blueberry folder
  FiveObjectClonedEvent copy_of_blueberry
  old manage_afterClone copy_of_blueberry copy_of_blueberry
  [{'new_id': 'copy_of_blueberry', 'id': 'blueberry'}]

Old behavior with events for a renaming:

  >>> folder.manage_renameObject('copy_of_blueberry', 'myrtille')
  ObjectWillBeMovedEvent copy_of_blueberry
  old manage_beforeDelete copy_of_blueberry copy_of_blueberry folder
  ObjectMovedEvent myrtille
  old manage_afterAdd myrtille myrtille folder

Old behavior with events for a clone:

  >>> res = folder.manage_clone(folder.blueberry, 'strawberry')
  ObjectCopiedEvent strawberry
  ObjectWillBeAddedEvent strawberry
  ObjectAddedEvent strawberry
  old manage_afterAdd strawberry strawberry folder
  FiveObjectClonedEvent strawberry
  old manage_afterClone strawberry strawberry
  >>> res.getId()
  'strawberry'

Events are also sent when we work with a BTreeFolder:

  >>> ob = MyContent('luckyluke')
  >>> btfolder._setObject('luckyluke', ob)
  ObjectWillBeAddedEvent luckyluke
  ObjectAddedEvent luckyluke
  old manage_afterAdd luckyluke luckyluke btfolder
  'luckyluke'

  >>> btfolder.manage_delObjects('luckyluke')
  ObjectWillBeRemovedEvent luckyluke
  old manage_beforeDelete luckyluke luckyluke btfolder
  ObjectRemovedEvent luckyluke

Here is what happens for a tree of objects. Let's create a simple one.

  >>> subfolder = MyFolder('subfolder')
  >>> folder._setObject('subfolder', subfolder)
  ObjectWillBeAddedEvent subfolder
  ObjectAddedEvent subfolder
  old manage_afterAdd subfolder subfolder folder
  'subfolder'
  >>> subfolder = folder.subfolder
  >>> ob = MyContent('donald')
  >>> subfolder._setObject('donald', ob)
  ObjectWillBeAddedEvent donald
  ObjectAddedEvent donald
  old manage_afterAdd donald donald subfolder
  'donald'

Renaming a tree of objects. Note that manage_beforeDelete is called
bottom-up.

  >>> folder.manage_renameObject('subfolder', 'pluto')
  ObjectWillBeMovedEvent subfolder
  ObjectWillBeMovedEvent donald
  old manage_beforeDelete donald subfolder folder
  old manage_beforeDelete subfolder subfolder folder
  ObjectMovedEvent pluto
  old manage_afterAdd pluto pluto folder
  ObjectMovedEvent donald
  old manage_afterAdd donald pluto folder

Cloning a tree of objects:

  >>> res = folder.manage_clone(folder.pluto, 'mickey')
  ObjectCopiedEvent mickey
  ObjectWillBeAddedEvent mickey
  ObjectWillBeAddedEvent donald
  ObjectAddedEvent mickey
  old manage_afterAdd mickey mickey folder
  ObjectAddedEvent donald
  old manage_afterAdd donald mickey folder
  FiveObjectClonedEvent mickey
  old manage_afterClone mickey mickey
  FiveObjectClonedEvent donald
  old manage_afterClone donald mickey
  >>> res.getId()
  'mickey'

If however we specify using ZCML that our classes can react to events,
the framework won't call manage_afterAdd and manage_beforeDelete
anymore.

  >>> from Products.Five.eventconfigure import setContainerEventAware
  >>> setContainerEventAware(MyContent)
  >>> setContainerEventAware(MyFolder)

  >>> ob = MyContent('dogbert')
  >>> folder._setObject('dogbert', ob)
  ObjectWillBeAddedEvent dogbert
  ObjectAddedEvent dogbert
  'dogbert'
  >>> folder.manage_delObjects('dogbert')
  ObjectWillBeRemovedEvent dogbert
  ObjectRemovedEvent dogbert

Now move:

  >>> ob = MyContent('dilbert')
  >>> folder._setObject('dilbert', ob)
  ObjectWillBeAddedEvent dilbert
  ObjectAddedEvent dilbert
  'dilbert'
  >>> cp = folder.manage_cutObjects('dilbert')
  >>> folder.manage_pasteObjects(cp)
  ObjectWillBeMovedEvent dilbert
  ObjectMovedEvent dilbert
  [{'new_id': 'dilbert', 'id': 'dilbert'}]

And copy:

  >>> cp = folder.manage_copyObjects('dilbert')
  >>> folder.manage_pasteObjects(cp)
  ObjectCopiedEvent copy_of_dilbert
  ObjectWillBeAddedEvent copy_of_dilbert
  ObjectAddedEvent copy_of_dilbert
  FiveObjectClonedEvent copy_of_dilbert
  [{'new_id': 'copy_of_dilbert', 'id': 'dilbert'}]

Then rename:

  >>> folder.manage_renameObject('copy_of_dilbert', 'wally')
  ObjectWillBeMovedEvent copy_of_dilbert
  ObjectMovedEvent wally

Or copy using manage_clone:

  >>> res = folder.manage_clone(folder.dilbert, 'phb')
  ObjectCopiedEvent phb
  ObjectWillBeAddedEvent phb
  ObjectAddedEvent phb
  FiveObjectClonedEvent phb
  >>> res.getId()
  'phb'

Also on a BTreeFolder:

  >>> ob = MyContent('alice')
  >>> btfolder._setObject('alice', ob)
  ObjectWillBeAddedEvent alice
  ObjectAddedEvent alice
  'alice'
  >>> btfolder.manage_renameObject('alice', 'rabbit')
  ObjectWillBeMovedEvent alice
  ObjectMovedEvent rabbit
  >>> btfolder.manage_delObjects('rabbit')
  ObjectWillBeRemovedEvent rabbit
  ObjectRemovedEvent rabbit

Now for a tree of objects. Let's create a simple one.

  >>> subfolder = MyFolder('subfolder')
  >>> folder._setObject('subfolder', subfolder)
  ObjectWillBeAddedEvent subfolder
  ObjectAddedEvent subfolder
  'subfolder'
  >>> subfolder = folder.subfolder
  >>> ob = MyContent('mel')
  >>> subfolder._setObject('mel', ob)
  ObjectWillBeAddedEvent mel
  ObjectAddedEvent mel
  'mel'

Renaming a tree of objects.

  >>> folder.manage_renameObject('subfolder', 'firefly')
  ObjectWillBeMovedEvent subfolder
  ObjectWillBeMovedEvent mel
  ObjectMovedEvent firefly
  ObjectMovedEvent mel

Cloning a tree of objects:

  >>> res = folder.manage_clone(folder.firefly, 'serenity')
  ObjectCopiedEvent serenity
  ObjectWillBeAddedEvent serenity
  ObjectWillBeAddedEvent mel
  ObjectAddedEvent serenity
  ObjectAddedEvent mel
  FiveObjectClonedEvent serenity
  FiveObjectClonedEvent mel
  >>> res.getId()
  'serenity'

OrderedFolder has the same renaming behavior than before:

  >>> ofolder = MyOrderedFolder('ofolder')
  >>> app._setObject('ofolder', ofolder)
  ObjectWillBeAddedEvent ofolder
  ObjectAddedEvent ofolder
  old manage_afterAdd ofolder ofolder
  'ofolder'
  >>> ob1 = MyContent('ob1')
  >>> ofolder._setObject('ob1', ob1)
  ObjectWillBeAddedEvent ob1
  ObjectAddedEvent ob1
  'ob1'
  >>> ob2 = MyContent('ob2')
  >>> ofolder._setObject('ob2', ob2)
  ObjectWillBeAddedEvent ob2
  ObjectAddedEvent ob2
  'ob2'
  >>> ofolder.manage_renameObject('ob1', 'ob4')
  ObjectWillBeMovedEvent ob1
  ObjectMovedEvent ob4
  >>> ofolder.objectIds()
  ['ob4', 'ob2']


Now cleanup all the monkey patches:

  >>> undoMonkies()

Phase 3
-------

This is the target phase.

  >>> doMonkies(transitional=False)

By default, events are sent and manage_afterAdd is not called.

  >>> ob = MyContent('droopy')
  >>> folder._setObject('droopy', ob)
  ObjectWillBeAddedEvent droopy
  ObjectAddedEvent droopy
  'droopy'
  >>> folder.manage_delObjects('droopy')
  ObjectWillBeRemovedEvent droopy
  ObjectRemovedEvent droopy

Old methods are called only for classes where we have specified that
they are old.

  >>> from Products.Five.eventconfigure import setDeprecatedManageAddDelete
  >>> setDeprecatedManageAddDelete(MyContent)

  >>> ob = MyContent('rantanplan')
  >>> folder._setObject('rantanplan', ob)
  ObjectWillBeAddedEvent rantanplan
  ObjectAddedEvent rantanplan
  old manage_afterAdd rantanplan rantanplan folder
  'rantanplan'
  >>> folder.manage_delObjects('rantanplan')
  ObjectWillBeRemovedEvent rantanplan
  old manage_beforeDelete rantanplan rantanplan folder
  ObjectRemovedEvent rantanplan

Now cleanup:

  >>> import transaction
  >>> transaction.abort()
  >>> undoMonkies()
  >>> tearDown()
