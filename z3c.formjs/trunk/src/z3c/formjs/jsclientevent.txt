========================================
Propogating Events from Server to Client
========================================

The ``jsclientevent`` module of this package provides an extremely minimal
event framework whereby events that occur on the server, such as
``IObjectModifiedEvent``s, propagate to a client's browser through
injected JavaScript code.  This is not to be confused with "action
events" that occur on the client such as "onClick".

  >>> from z3c.formjs import jsclientevent

There are several components that must work together to propagate the
events to the client:

  1. Server Events - These are events that get notified by server side code such as
  ``IObjectEvent`` and its many derivatives.

  2. Server Event Handlers - These are server side functions that get
  called immediately when an event is notified in the order that the
  functions were registered as handlers.

  3. Client Event Handlers - these are snippets of javascript code which
  get rendered for each occurance of an event and are inlined into the
  DOM at some later time (when requested by an HTTP call, or placed
  into a page template).

The first two components are handled for us by Zope's
notification/subscription event model.  This module serves to connect
the second and third components in such a way that events which occur
during an interaction (a request and repsonse cycle) can be caught and
stored in memory so that JavaScript handlers can be rendered for
these events along with all other form elements.

Client Event Handlers
---------------------

The client side event handler is just a snippet of JavaScript that
gets evaluated when an appropriate event occurs.  To be precise, JavaScript is
evaluated when the client's web browser first sees it in the DOM,
wrapped in the appropriate ``script`` tags.  In fact, the client
browser will also immediately evaluate JavaScript inserted into the
DOM long after the DOM has been originally initialized -- such as when
data is inserted into the DOM after an asynchronous HTTP request.

Client event handlers are defined in much the same way that server
event handlers are defined.  That is, they are python function which
adapt an event object and perform actions based on the event.  In our
use case, the action to be performed is the rendering of JavaScript.

Let's create a simple view class with an event handler for the
``IObjectModifiedEvent`` event.

  >>> from zope.interface import Interface
  >>> from zope.lifecycleevent.interfaces import IObjectModifiedEvent
  >>> class View(object):
  ...
  ...     @jsclientevent.listener((Interface, IObjectModifiedEvent,))
  ...     def modifiedListener(self, event):
  ...         return 'alert("object modified: %s");' % event.object

The argument passed to the ``listener`` decorator is a list (or tuple)
of the required interfaces for the event handler.  These are, the
interface implemented by the object given to the event's constructor,
and the interface for the event itself.  This is just like the set of
interfaces one would pass to the ``zope.component.provideHandler``
function.

XXX: should we rename this decorator to simply ``handler``?  Or maybe
     ``subscribe``?  ``listener`` seems out of place and inconsistent with
     the other types of handlers we have defined.

The decorator also registers this client side event handler with a local
component registry that is accessed through the ``jsClientListeners``
attribute.

  >>> View.jsClientListeners
  <ClientEventHandlers
     [<ClientEventHandler for
         (<InterfaceClass zope.interface.Interface>,
          <InterfaceClass ...IObjectModifiedEvent>)>]>

The component registry used to store the client event handlers takes
the form of a ``ClientEventHandlers`` instance, which provides the
following methods:

The ``getHandlers`` method takes an instance of an event and returns
a list of all the handlers for that event and its associated object.

  >>> from zope.lifecycleevent import ObjectModifiedEvent
  >>> objectEvent = ObjectModifiedEvent("some context")
  >>> View.jsClientListeners.getHandlers(objectEvent)
  [<ClientEventHandler for
      (<InterfaceClass zope.interface.Interface>,
       <InterfaceClass ...IObjectModifiedEvent>)>]

Of course, we do not get any handlers if there are none registered for
the event in question.

  >>> from zope.component.interfaces import ObjectEvent
  >>> objectEvent2 = ObjectEvent("some context")
  >>> View.jsClientListeners.getHandlers(objectEvent2)
  []

The ``addHandler`` method takes an event specification (a tuple of two
interfaces representing the object type and the event type) and the
handler function itself.

  >>> def someHandler(event): return str(event)
  >>> from zope.component.interfaces import IObjectEvent
  >>> View.jsClientListeners.addHandler((Interface, IObjectEvent), someHandler)
  >>> View.jsClientListeners.getHandlers(objectEvent2)
  [<function someHandler at ...>]

XXX: do we want to allow plain functions to be registerd as handlers?
     Or only things that implement IClientEventHandler (which must be
     a callable that takes two parameters, a form and an event).

``ClientEventHandlers`` instances can be copied,

  >>> copy = View.jsClientListeners.copy()
  >>> copy
  <ClientEventHandlers [<ClientEventHandler for (<InterfaceClass ...Interface>,
                                                 <InterfaceClass ...IObjectModifiedEvent>)>,
                        <function someHandler at ...>]>

  >>> copy is View.jsClientListeners
  False

and also be added amongst each other:

  >>> View.jsClientListeners + copy
  <ClientEventHandlers
    [<ClientEventHandler for (<InterfaceClass ...Interface>,
                                                 <InterfaceClass ...IObjectModifiedEvent>)>,
                        <function someHandler at ...>,
     <ClientEventHandler for (<InterfaceClass ...Interface>,
                                                 <InterfaceClass ...IObjectModifiedEvent>)>,
                        <function someHandler at ...>]>

Other objects cannot be added to these ``ClientEventHandlers`` instances:

  >>> View.jsClientListeners + 1
  Traceback (most recent call last):
  ...
  NotImplementedError


Server Side Listeners
---------------------

We also need a subscriber on the server side that listens for relevant server
side events and sticks the event into the request so it can be processed by
the form at the end of the interaction.  First we need to register the
subscriber.

  >>> import zope.component
  >>> zope.component.provideHandler(jsclientevent.serverToClientEventLoader)

  >>> from zope.event import notify
  >>> from zope.lifecycleevent import ObjectModifiedEvent
  >>> notify(ObjectModifiedEvent('foo'))

Let's create a typical use case scenario:

First the setup:

  >>> from z3c.form.testing import setupFormDefaults
  >>> setupFormDefaults()
  >>> from z3c.formjs import testing
  >>> testing.setupRenderers()

Create a content component for an "article":

  >>> import zope.interface
  >>> import zope.schema
  >>> class IArticle(zope.interface.Interface):
  ...     title = zope.schema.TextLine(title=u'Title')

  >>> class Article(object):
  ...     zope.interface.implements(IArticle)
  ...     title = u'Default Title'

  >>> article = Article()
  >>> article.title
  u'Default Title'

Create an Edit Form for said content component.

  >>> from z3c.form import form, field
  >>> class ArticleEditForm(jsclientevent.ClientEventsForm,
  ...                       form.EditForm):
  ...     fields = field.Fields(IArticle)
  ...
  ...     @jsclientevent.listener((IArticle, IObjectModifiedEvent,))
  ...     def alertModifiedEvent(self, event):
  ...         return 'alert("This event occured: %s");' % event

Now we will instantiate the form and modify the object.

  >>> from z3c.form.testing import TestRequest
  >>> request = TestRequest(form={'form.widgets.title':u'New Title',
  ...                             'form.buttons.apply':u'Apply'})

  >>> from zope.security import management
  >>> management.endInteraction()

  >>> form = ArticleEditForm(article, request)
  >>> form.update()

  >>> request.annotations.get(jsclientevent.CLIENT_EVENT_REQUEST_KEY)

Initially nothing happens, because we did not register an interaction:

  >>> request = TestRequest(form={'form.widgets.title':u'New Title 2',
  ...                             'form.buttons.apply':u'Apply'})

  >>> management.newInteraction(request)

  >>> form = ArticleEditForm(article, request)
  >>> form.update()

The request tells the form to update the title of the article, and
subsequently send out an object modified event.  This event gets
picked up by our handler, and stored in the request's annotations

  >>> request.annotations[jsclientevent.CLIENT_EVENT_REQUEST_KEY]
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>]

More importantly, now our form knows about this event.

  >>> form.eventCalls
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>]

But what happens if we throw events for which there are not handlers?
They should not show up in the ``eventCalls`` attribute.  First of
all, events that are not sent out when an interaction is not taking
place are not picked up at all -- not event in the request annotation.
Since we have not ended the last interaction though, any events we
we notify will get picked up.

  >>> from zope.component.interfaces import ObjectEvent
  >>> notify(ObjectEvent('foo'))
  >>> request.annotations[jsclientevent.CLIENT_EVENT_REQUEST_KEY]
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>,
   <zope.app.event.objectevent.ObjectEvent object at ...>]

But this still does not show up in the eventCalls, as there is no
handler registered for it.

  >>> form.eventCalls
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>]

Now we can get all the javascript that needs to be injected into the
dom from the ``eventInjections`` attribute.

  >>> print form.eventInjections
  alert("This event occured:
         <zope.app.event.objectevent.ObjectModifiedEvent object at ...>");
