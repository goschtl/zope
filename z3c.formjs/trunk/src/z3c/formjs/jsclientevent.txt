========================================
Mapping Events Between Server and Client
========================================

The ``jsclientevent`` module of this package provides an extremely
minimal event framework whereby events that occur on the server, such
as ``IObjectModifiedEvent``s, propagate to a clients browser through
injected JavaScript function calls.  This is not to be confused with
"action events" that occur on the client such as onClick.

  >>> from z3c.formjs import jsclientevent

There are several components these types of interactions.  First there
are the server events, which, for example, are thrown on a state
change.  Next there is a client listener, which is just a javascript
function that gets called when the event occurs, and finally there is
the "event transport" which allows the server to call a function
defined on the client side.


Client Side Handler
--------------------

The client side event handler is just a snippet of JavaScript that
gets executed when the event occurs.  The server injects this
javascript onto the page via an ajax response.

Let's create a simple view class with an event listener for the
IObjectModifiedEvent

  >>> from zope.lifecycleevent.interfaces import IObjectModifiedEvent
  >>> class View(object):
  ...
  ...     @jsclientevent.listener((IObjectModifiedEvent,))
  ...     def modifiedListener(self, event):
  ...         return 'alert("object modified: %s");' % event.object

The argument passed to the ``listener`` decorator is a list (or tuple)
of the required interfaces for the event handler.  This is just like
the set of interfaces one would pass to the
zope.component.provideHandler function.

The decorator also registers this client side event handler with a
local component registry that is accessed through the
``jsClientListeners`` attribute, which is now available on the view class itself.

  >>> View.jsClientListeners
  <ClientEventHandlers
     [<ClientEventHandler for (<InterfaceClass zope.lifecycleevent.interfaces.IObjectModifiedEvent>,)>]>

Server Side Listeners
---------------------

So, we need a subscriber on the server side that listens for
server side events that are relevant and sticks the event into the
request to be rendered by the form at the end of the interaction.
First we need to register the subscriber.

  >>> import zope.component
  >>> from zope.component.interfaces import IObjectEvent
  >>> zope.component.provideHandler(jsclientevent.serverToClientEventLoader,
  ...                               (IObjectEvent,))

  >>> from zope.event import notify
  >>> from zope.lifecycleevent import ObjectModifiedEvent
  >>> notify(ObjectModifiedEvent('foo'))

Let's create a typical use case scenario:

First the setup:

  >>> from z3c.form.testing import setupFormDefaults
  >>> setupFormDefaults()
  >>> from z3c.formjs import testing
  >>> testing.setupRenderers()

Create a content component for an "article"

  >>> import zope.interface
  >>> import zope.schema
  >>> class IArticle(zope.interface.Interface):
  ...     title = zope.schema.TextLine(title=u'Title')

  >>> class Article(object):
  ...     zope.interface.implements(IArticle)
  ...     title = u'Default Title'

  >>> article = Article()
  >>> article.title
  u'Default Title'

Create an Edit Form for said content component.

  >>> from z3c.form import form, field
  >>> class ArticleEditForm(jsclientevent.ClientEventsForm,
  ...                       form.EditForm):
  ...     fields = field.Fields(IArticle)
  ...
  ...     @jsclientevent.listener((IArticle, IObjectModifiedEvent,))
  ...     def alertModifiedEvent(self, event):
  ...         return 'alert("This event occured: %s");' % event

Now we will instantiate the form and modify the object.

  >>> from z3c.form.testing import TestRequest
  >>> request = TestRequest(form={'form.widgets.title':u'New Title',
  ...                             'form.buttons.apply':u'Apply'})
  >>> from zope.security import management
  >>> from zope.security.testing import Participation
  >>> management.endInteraction()
  >>> management.newInteraction(request)

  >>> form = ArticleEditForm(article, request)
  >>> form.update()

The request tells the form to update the title of the article, and
subsequently send out an object modified event.  This event gets
picked up by our handler, and stored in the request's annotations

  >>> request.annotations[jsclientevent.CLIENT_EVENT_REQUEST_KEY]
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>]

More importantly, now our form knows about this event.

  >>> form.eventCalls
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>]

But what happens if we throw events for which there are not handlers?
They should not show up in the ``eventCalls`` attribute.  First of
all, events that are not sent out when an interaction is not taking
place are not picked up at all -- not event in the request annotation.
Since we have not ended the last interaction though, any events we
we notify will get picked up.

  >>> from zope.component.interfaces import ObjectEvent
  >>> notify(ObjectEvent('foo'))
  >>> request.annotations[jsclientevent.CLIENT_EVENT_REQUEST_KEY]
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>,
   <zope.app.event.objectevent.ObjectEvent object at ...>]

But this still does not show up in the eventCalls, as there is no
handler registered for it.

  >>> form.eventCalls
  [<zope.app.event.objectevent.ObjectModifiedEvent object at ...>]

Now we can get all the javascript that needs to be injected into the
dom from the ``eventInjections`` attribute.

  >>> print form.eventInjections
  alert("This event occured: <zope.app.event.objectevent.ObjectModifiedEvent object at ...>");
