====================
JavaScript Functions
====================

When developing JavaScript-enabled user interfaces, it is often necessary to
create small callback functions. The usual way of creating those functions is
to write and register a resource, then create a viewlet for it that integrates
it. Those steps can be tedious when writing small functions. Thus, this
package provides a way to convert a Python method to a Javascript function.

  >>> from z3c.formjs import jsfunction

So let's create a simple view with a JavaScript function in it:

  >>> class View(object):
  ...
  ...     @jsfunction.function('hw')
  ...     def showHelloWorldMessage(self):
  ...         return u"alert('Hello World!');"

The argument to ``jsfunction.function`` is the namspace into which the
function will be placed. This argument is optional. The Python method is
expected to return the Javascript code as a string. All functions are
collected in a special attribute called "jsFunctions"

  >>> View.jsFunctions
  <JSFunctions
      {'hw': {'showHelloWorldMessage': <JSFunction showHelloWorldMessage>}}>

The functions can be rendered directly:

  >>> print View.jsFunctions.render()
  var hw = {};
  hw.showHelloWorldMessage = function() {
    alert('Hello World!');
  };

We can also give a dotted path for the namespace, which will in turn
be reflect in javascript:

  >>> class View(object):
  ...
  ...     @jsfunction.function('z3c.formjs.hw')
  ...     def showHelloWorldMessage(self):
  ...         return u"alert('Hello World!');"

  >>> View.jsFunctions
  <JSFunctions {'z3c.formjs.hw':
        {'showHelloWorldMessage': <JSFunction showHelloWorldMessage>}}>

  >>> print View.jsFunctions.render()
  var z3c = {};
  z3c.formjs = {};
  z3c.formjs.hw = {};
  z3c.formjs.hw.showHelloWorldMessage = function() {
    alert('Hello World!');
  };

We can also do mixed level namespacing:

  >>> class View(object):
  ...
  ...     @jsfunction.function('z3c.formjs.hw')
  ...     def foo(self):
  ...         return u"alert('Foo');"
  ...
  ...     @jsfunction.function('z3c.formjs')
  ...     def bar(self):
  ...         return u"alert('Bar');"
  ...
  ...     @jsfunction.function('z3c.formjs.hw')
  ...     def baz(self):
  ...         return u"alert('Baz');"

  >>> View.jsFunctions
  <JSFunctions {'z3c.formjs.hw': {'foo': <JSFunction foo>,
                                  'baz': <JSFunction baz>},
                'z3c.formjs': {'bar': <JSFunction bar>}}>

  >>> print View.jsFunctions.render()
  var z3c = {};
  z3c.formjs = {};
  z3c.formjs.hw = {};
  z3c.formjs.hw.foo = function() {
    alert('Foo');
  };
  z3c.formjs.hw.baz = function() {
    alert('Baz');
  };
  z3c.formjs.bar = function() {
    alert('Bar');
  };



Similarly to Javascript subscriptions, a JavaScript viewlet exists for
any view containing JavaScript functions that provides the following
output:

  >>> viewlet = jsfunction.JSFunctionsViewlet(
  ...     object(), object(), View(), object())
  >>> viewlet.update()
  >>> print viewlet.render()
  <script type="text/javascript">
    var z3c = {};
    z3c.formjs = {};
    z3c.formjs.hw = {};
    z3c.formjs.hw.foo = function() {
      alert('Foo');
    };
    z3c.formjs.hw.baz = function() {
      alert('Baz');
    };
    z3c.formjs.bar = function() {
      alert('Bar');
    };
  </script>

!Note! a form must implement IHaveJSFunctions for the viewlet to be
rendered.

Let's now have a closer look at the decorator. As mentioned before,
the namespace is optional. So what happens if the namespace is not
specified? Then the function should be declared normally:

  >>> class View(object):
  ...
  ...     @jsfunction.function()
  ...     def showHelloWorldMessage(self):
  ...         return u"alert('Hello World!');"

  >>> print View.jsFunctions.render()
  var showHelloWorldMessage = function () {
    alert('Hello World!');
  }

Of course you can mix namespace and non-namespace functions:

  >>> class View(object):
  ...
  ...     @jsfunction.function()
  ...     def show1(self):
  ...         return u"alert('Hello World!');"
  ...
  ...     @jsfunction.function('ns1')
  ...     def show1(self):
  ...         return u"alert('Hello World!');"
  ...
  ...     @jsfunction.function('ns1')
  ...     def show2(self):
  ...         return u"alert('Hello World!');"

  >>> print View.jsFunctions.render()
  var show1 = function () {
    alert('Hello World!');
  }
  ns1 = {};
  ns1.show1 = function() {
    alert('Hello World!');
  };
  ns1.show2 = function() {
    alert('Hello World!');
  };

What about arguments? The arguments are directly extracted into the
code. Currently, keyword arguments, and variable positional and keyword
arguments are not supported, as they are not supported by JavaScript either:

  >>> class View(object):
  ...
  ...     @jsfunction.function('ns')
  ...     def show(self, title):
  ...         return u"alert('Title' + title);"

  >>> print View.jsFunctions.render()
  var ns = {};
  ns.show = function(title) {
    alert('Title' + title);
  };

And that is really everything that there is to it.


Calling JSFunctions from Python
-------------------------------

We can also render a JavaScript call to a JSFunction from within
python using the call method of the function.  We can even pass
the call method the arguments to be rendered.

  >>> View.show.call(u"Some Title")
  "ns.show('Some Title');"
  >>> View.show.call("Some Title")
  "ns.show('Some Title');"
  >>> View.show.call(3.0)
  'ns.show(3.0);'
  >>> View.show.call(1)
  'ns.show(1);'
  >>> View.show.call(True)
  'ns.show(true);'

Unsupported data types are just rendered as strings.

  >>> View.show.call(object())
  "ns.show('<object object at ...>');"

Functions without namespaces also render correctly:

  >>> class View(object):
  ...
  ...     @jsfunction.function()
  ...     def show(self, title):
  ...         return u"alert('Title' + title);"

  >>> View.show.call(u"Some Title")
  "show('Some Title');"
