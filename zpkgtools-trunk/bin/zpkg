#!/usr/bin/env python2.3

import optparse
import os
import shutil
import sys
import tempfile

try:
    __file__
except NameError:
    __file__ = sys.argv[0]

script = os.path.realpath(__file__)
here = os.path.dirname(script)

try:
    import zpkgtools
except ImportError:
    # Not installed; running from development copy:
    basedir = os.path.dirname(here)
    sys.path.append(basedir)
    import zpkgtools

from zpkgtools import config
from zpkgtools import cvsloader
from zpkgtools import locationmap
from zpkgtools import publication
from zpkgtools import setup
from zpkgtools.include import InclusionProcessor


class Application:

    def __init__(self, options, resource, program):
        self.ip = None
        self.options = options
        self.resource = locationmap.normalizeResourceId(resource)
        self.resource_type, self.resource_name = self.resource.split(":", 1)
        # Create a new directory for all temporary files to go in:
        self.tmpdir = tempfile.mkdtemp(prefix=program + "-")
        tempfile.tempdir = self.tmpdir
        self.loader = cvsloader.CvsLoader()
        cf = config.Configuration(options.configfile)
        cf.finalize()
        self.locations = cf.locations

        if resource not in self.locations:
            print >>sys.stderr, "unknown resource:", resource
            sys.exit(1)
        self.resource_url = self.locations[resource]

    def buildDistribution(self):
        # This could be either a package distribution or a collection
        # distribution; it's the former if there's an __init__.py in
        # the source directory.
        name = "build%sDistribution" % self.resource_type.capitalize()
        method = getattr(self, name)
        method()
        self.generateSetup()

    def buildPackageDistribution(self):
        os.mkdir(self.destination)
        pkgname = self.metadata.name

        self.ip = InclusionProcessor(self.source,
                                     os.path.join(self.destination, pkgname))
        try:
            self.ip.createDistributionTree()
        except cvsloader.CvsLoadingError, e:
            print >>sys.stderr, e
            sys.exit(1)

    def buildCollectionDistribution(self):
        # Build the destination directory:
        self.ip = InclusionProcessor(self.source,
                                     self.destination)
        try:
            self.ip.createDistributionTree()
        except cvsloader.CvsLoadingError, e:
            print >>sys.stderr, e
            sys.exit(1)

    def loadMetadata(self):
        metadata_file = os.path.join(self.source, "PUBLICATION.txt")
        if not os.path.isfile(metadata_file):
            print >>sys.stderr, \
                  "source-dir does not contain required publication data file"
            sys.exit(1)
        self.metadata = publication.load(open(metadata_file))

    def loadResource(self):
        self.source = self.loader.load(self.resource_url)
        self.loadMetadata()
        if not self.options.release_name:
            self.options.release_name = self.metadata.name.replace(" ", "-")
        release_name = self.options.release_name
        self.target_name = "%s-%s" % (release_name, self.options.version)
        self.target_file = self.target_name + ".tar.bz2"
        self.destination = os.path.join(self.tmpdir, self.target_name)

    def generateSetup(self):
        setup.generate(self.destination,
                       self.resource_name,
                       self.options.version,
                       self.resource_type)

    def createTarball(self):
        pwd = os.getcwd()
        os.chdir(self.tmpdir)
        try:
            rc = os.spawnlp(os.P_WAIT, "tar",
                            "tar", "cjf", self.target_file, self.target_name)
        finally:
            os.chdir(pwd)
        if rc:
            print >>sys.stderr, "error generating", self.target_file
            sys.exit(1)
        # We have a tarball; clear some space, then copy the tarball
        # to the current directory:
        shutil.rmtree(self.destination)
        shutil.copy(os.path.join(self.tmpdir, self.target_file),
                    self.target_file)

    def cleanup(self):
        shutil.rmtree(self.tmpdir)

    def run(self):
        try:
            self.loadResource()
            self.buildDistribution()
            self.createTarball()
            self.cleanup()
        except:
            print >>sys.stderr, "temporary files are in", self.tmpdir
            raise


def main(argv=None):
    if argv is None:
        argv = sys.argv
    program = os.path.basename(argv[0])
    parser = optparse.OptionParser(
        usage="usage: %prog [options] resource")
    parser.add_option(
        "-C", "--configure", dest="configfile",
        help="path or URL to the configuration file")
    parser.add_option(
        "-n", "--name", dest="release_name",
        help="base name of the distribution file")
    parser.add_option(
        "-r", "--revision-tag", dest="revision_tag",
        help="default CVS tag to use (default: HEAD)",
        default="HEAD")
    parser.add_option(
        "-v", dest="version",
        help="version label for the new distribution",
        default="0.0.0")
    options, args = parser.parse_args(argv[1:])

    # figure out what to read from:
    if len(args) != 1:
        print >>sys.stderr, "wrong number of arguments"
        return 2
    resource = args[0]

    try:
        app = Application(options, resource, program)
        app.run()
    except SystemExit, e:
        return e.code
    except KeyboardInterrupt:
        return 1
    else:
        return 0


if __name__ == "__main__":
    sys.exit(main())
