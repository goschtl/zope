
TransactionController Tests
---------------------------

The TransactionController commits or aborts the current transaction
after the pipeline processing. It also annotates the transaction with
info about what the user did in that transaction.

Set up enough of a request to make the annotation work.

    >>> from zope.interface import classImplements
    >>> from zope.location.interfaces import IRoot
    >>> from zope.location.traversing import RootPhysicallyLocatable
    >>> from zope.component import provideAdapter
    >>> provideAdapter(RootPhysicallyLocatable)

    >>> class TestRoot(object):
    ...     def mymethod(self):
    ...         pass
    >>> classImplements(TestRoot, IRoot)
    >>> class TestRequest(object):
    ...     pass
    >>> request = TestRequest()
    >>> class TestPrincipal(object):
    ...     pass
    >>> request.principal = TestPrincipal()
    >>> request.principal.id = 'testuser'

Create a data manager object and an application that registers that data
manager with the transaction in progress.

    >>> import transaction
    >>> class TestDataManager(object):
    ...     def __init__(self):
    ...         self.phase = ''
    ...         self.committed = []
    ...         self.aborted = []
    ...         self.committed_user = None
    ...         self.committed_extension = None
    ...     def tpc_begin(self, txn):
    ...         self.phase = 'begin'
    ...     def tpc_vote(self, txn):
    ...         self.phase = 'vote'
    ...     def tpc_finish(self, txn):
    ...         self.phase = 'finish'
    ...         self.committed_user = txn.user
    ...         self.committed_extension = txn._extension
    ...     def tpc_abort(self, txn):
    ...         self.phase = 'abort'
    ...     def commit(self, obj, txn):
    ...         self.committed.append(obj)
    ...     def abort(self, obj, txn):
    ...         self.aborted.append(obj)
    >>> dm = TestDataManager()
    >>> def my_app(environ, start_response):
    ...     transaction.get().register(dm)
    ...     return ['done']
    >>> from zope.pipeline.apps.txnctl import TransactionController
    >>> app = TransactionController(my_app)

Run the app.

    >>> environ = {
    ...     'zope.pipeline.request': request,
    ...     'zope.pipeline.traversed': [('xyz', TestRoot().mymethod)],
    ...     }
    >>> app(environ, None)
    ['done']
    >>> dm.phase
    'finish'
    >>> dm.committed
    [<TestDataManager object at ...>]
    >>> dm.aborted
    []

Examine the annotations.

    >>> dm.committed_user
    '/ testuser'
    >>> from pprint import pprint
    >>> pprint(dm.committed_extension)
    {'location': u'/', 'request_type': 'zope.publisher.interfaces.base.IRequest'}

Make the app raise an exception.

    >>> dm = TestDataManager()
    >>> def my_app(environ, start_response):
    ...     transaction.get().register(dm)
    ...     raise ValueError('no way')
    >>> app = TransactionController(my_app)
    >>> app(environ, None)
    Traceback (most recent call last):
    ...
    ValueError: no way
    >>> dm.phase
    ''
    >>> dm.committed
    []
    >>> dm.aborted
    [<TestDataManager object at ...>]

Doom a transaction.  When a transaction is doomed, no data can be written,
but the pipeline can return a normal (non-exception) response.

    >>> dm = TestDataManager()
    >>> def doom_app(environ, start_response):
    ...     transaction.get().register(dm)
    ...     transaction.doom()
    ...     return ['done but doomed']
    >>> from zope.pipeline.apps.txnctl import TransactionController
    >>> app = TransactionController(doom_app)
    >>> app(environ, None)
    ['done but doomed']
    >>> dm.phase
    ''
    >>> dm.committed
    []
    >>> dm.aborted
    [<TestDataManager object at ...>]

