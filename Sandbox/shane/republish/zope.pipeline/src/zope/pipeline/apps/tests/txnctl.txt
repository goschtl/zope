
TransactionController Tests
---------------------------

The TransactionController commits or aborts the current transaction after
the pipeline processing.

Create a data manager object and an application that registers that data
manager with the transaction in progress.

    >>> import transaction
    >>> class TestDataManager(object):
    ...     def __init__(self):
    ...         self.phase = ''
    ...         self.committed = []
    ...         self.aborted = []
    ...     def tpc_begin(self, txn):
    ...         self.phase = 'begin'
    ...     def tpc_vote(self, txn):
    ...         self.phase = 'vote'
    ...     def tpc_finish(self, txn):
    ...         self.phase = 'finish'
    ...     def tpc_abort(self, txn):
    ...         self.phase = 'abort'
    ...     def commit(self, obj, txn):
    ...         self.committed.append(obj)
    ...     def abort(self, obj, txn):
    ...         self.aborted.append(obj)
    >>> dm = TestDataManager()
    >>> def my_app(environ, start_response):
    ...     transaction.get().register(dm)
    ...     return ['done']
    >>> from zope.pipeline.apps.txnctl import TransactionController
    >>> app = TransactionController(my_app)

Run the app.

    >>> environ = {}
    >>> app(environ, None)
    ['done']
    >>> dm.phase
    'finish'
    >>> dm.committed
    [<TestDataManager object at ...>]
    >>> dm.aborted
    []

Make the app raise an exception.

    >>> dm = TestDataManager()
    >>> def my_app(environ, start_response):
    ...     transaction.get().register(dm)
    ...     raise ValueError('no way')
    >>> app = TransactionController(my_app)
    >>> app(environ, None)
    Traceback (most recent call last):
    ...
    ValueError: no way
    >>> dm.phase
    ''
    >>> dm.committed
    []
    >>> dm.aborted
    [<TestDataManager object at ...>]

Doom a transaction.  When a transaction is doomed, no data can be written,
but the pipeline can return a normal (non-exception) response.

    >>> dm = TestDataManager()
    >>> def doom_app(environ, start_response):
    ...     transaction.get().register(dm)
    ...     transaction.doom()
    ...     return ['done but doomed']
    >>> from zope.pipeline.apps.txnctl import TransactionController
    >>> app = TransactionController(doom_app)
    >>> app(environ, None)
    ['done but doomed']
    >>> dm.phase
    ''
    >>> dm.committed
    []
    >>> dm.aborted
    [<TestDataManager object at ...>]


TransactionAnnotator Tests
--------------------------

The TransactionAnnotator application adds information to the
zope.pipeline.request after the rest of the pipeline has finished.

Set up enough of a request to make the TransactionAnnotator work.

    >>> from zope.interface import classImplements
    >>> from zope.location.interfaces import IRoot
    >>> from zope.location.traversing import RootPhysicallyLocatable
    >>> from zope.component import provideAdapter
    >>> provideAdapter(RootPhysicallyLocatable)

    >>> class TestRoot(object):
    ...     def mymethod(self):
    ...         pass
    >>> classImplements(TestRoot, IRoot)
    >>> class TestRequest(object):
    ...     pass
    >>> request = TestRequest()
    >>> class TestPrincipal(object):
    ...     pass
    >>> request.principal = TestPrincipal()
    >>> request.principal.id = 'testuser'

Create and run an app with a TransactionAnnotator.

    >>> def my_app(environ, start_response):
    ...     return ['done annotating']
    >>> from zope.pipeline.apps.txnctl import TransactionAnnotator
    >>> app = TransactionAnnotator(my_app)
    >>> environ = {
    ...     'zope.pipeline.request': request,
    ...     'zope.pipeline.traversed': [('xyz', TestRoot().mymethod)],
    ...     }
    >>> app(environ, None)
    ['done annotating']

Examine the annotations.

    >>> transaction.get().user
    '/ testuser'
    >>> from pprint import pprint
    >>> pprint(transaction.get()._extension)
    {'location': u'/', 'request_type': 'zope.publisher.interfaces.base.IRequest'}
    >>> transaction.abort()
