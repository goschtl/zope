A mapping with acyclic directed graph key
=========================================

A normal mapping (dictionary) in Python has keys that are completely
independent from each other. If you look up a particular key, either that
key is present in the mapping or not at all.

This is a mapping that understands about relations between keys. Keys
can have zero or more parents. If a key is not found, a value will
still be found if a parent key can be found.

We create a special kind of keys that can have parents. First we
create one without parents::

  >>> from iface import MapKey
  >>> a = MapKey('a')

Now we create keys ``b`` and ``c`` that both have ``a`` for a parent::

  >>> b = MapKey('b', [a])
  >>> c = MapKey('c', [a])

Finally we create a key ``d`` that has two parents, ``b`` and ``c``::

  >>> d = MapKey('d', [b, c])

Now we create a mapping::

  >>> from iface import Map
  >>> map = Map()

``a`` can be used just like any dictionary key::

  >>> map[a] = u'Value for A'
  >>> map[a]
  u'Value for A'
  >>> del map[a]
  >>> map[a]
  Traceback (most recent call last):
    ...
  KeyError: <MapKey: 'a'>
 
We now register something for ``b``::

  >>> map[b] = u'Value for B'

Of course we can find ``b``::
  >>> map[b]
  u'Value for B'

We cannot find ``c`` as there is no relation to ``b``::

  >>> map[c]
  Traceback (most recent call last):
    ...
  KeyError: <MapKey: 'c'>

Neither can we find ``a``, as ``b`` is not an ancestor of ``a``::

  >>> map[a]
  Traceback (most recent call last):
    ...
  KeyError: <MapKey: 'a'>

Now for the special behavor. Since ``d`` does have ``b`` as an
ancestor, we can look it up, finding the value for B::

  >>> map[d]
  u'Value for B'

We register a value for ``c``::

  >>> map[c] = u'Value for C'

When we look up the value for ``d`` we get still the value for ``b``,
as it comes first in the parent resolution order (similar to Python's
method resolution order for classes)::

  >>> map[d]
  u'Value for B'

When we take out the value for ``b`` we get the value for ``c`` when we
look up ``d``::
  
  >>> del map[b]
  >>> map[d]
  u'Value for C'

If we store a ``d`` key itself, then we will get its value, not the
value of its ancestor ``c``::

  >>> map[d] = u'Value for D'
  >>> map[d]
  u'Value for D'

next: multi lookup. What is the behavior of zope.interface? Do earlier
entries in the lookup list always weigh more heavily than the second
one? We need backtracking in case we don't find anything for the next
entry. That's not exactly efficient.
