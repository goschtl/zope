=======================================
Mini-Howto: Automated Testing with Grok
=======================================

:Author: Uli Fouquet

Intended Audience:

  * Python Developers

  * Zope 2 Developers

.. contents::

Introduction
------------

Testing is a major topic in Zope 3 and its support for several kinds
of tests is remarkable. Even for developers, that are already familiar
with functional tests, unittests and doctests, there might remain some
questions, for example, where to put what tests and similar.

This mini tutorial gives a very short overview over the different
kinds of tests supported by Zope 3 and then shows some basic ways how
to use them within a typical Grok project.

This is *not* a general introduction to testing with Python, the
concepts of unit testing or similar. It is just a sketch to get you
started, when you want to create tests for your Grok project (and you
*want* to create tests).

What we will show here, is a way, to create and run your tests using
``bin/test`` from your project root.

For experienced Zope 3 developers there should be nothing new herein.

Types of Tests
--------------

There are several kinds of tests, you can use with Zope 3
out-of-the-box:

- unit tests

  Are tests for testing discrete units of your code, say a class or a
  function. Support for unit tests comes with your Python
  installation's ``unittest`` package. See the `Python reference of
  the unittest package`_  for details.

  You will use unit tests most probably for non-view related testing.

.. _`Python reference of the unittest package`: http://docs.python.org/lib/module-unittest.html

- functional tests

  or integration tests in Zope 3 treat the whole Zope machinery as a
  black box and provide the possibility to 'send' requests to
  it. However, in fact no real requests happen, but the testing
  environment only creates suitable objects to simulate browser
  requests.

  You will use functional tests most probably for the mere
  view-related testing.

- doc tests

  are not a special kind of tests, but a special (and very convenient)
  method to notate tests. They can be used to write unit tests as well
  as functional tests. Their advantage is, that in many cases (but not
  all) they are better readable and can be integrated into documenting
  code. Often they improve chances of others to understand your code
  better.

  See the `Python reference of the doctest package`_ for details.

.. _`Python reference of the doctest package`: http://docs.python.org/lib/module-doctest.html


Preparing the Project
---------------------

For the following we expect to have a typical Grok project already
created, as it is done by::

  $ grokproject Sample

Afterwards we have a newly created directory ``Sample/`` which contains
a ``bin/`` and in ``src/sample`` your application. In the following
``app.py`` should contain a class ``Sample`` which will be generated
automatically if you enter the above commandline.

We will now create tests, that can be run using::

  $ bin/test

which at the beginning should result in the following output::

  Running tests at level 1
  Total: 0 tests, 0 failures, 0 errors in 0.000 seconds.


Writing Unittests
-----------------

Now we want to do some unit testing for the classes in ``app.py``. 


Defining unit tests in ``tests.py``
+++++++++++++++++++++++++++++++++++

If you have a look at the ``bin/test`` script, that runs all the
tests, you will find the definition of a Zope test runner. The test
runner is configured to look for modules and packages named ``tests``
or ``ftests``. See the ``zope.testing`` package to learn more about
testrunners.

This means, we can create a file ``src/sample/tests.py`` which will be
executed by the testrunner automatically.

Create a file ``tests.py`` in the root of your application.


.. code-block:: python

  """File: src/sample/tests.py
  """
  import unittest
  from sample.app import Sample

  class SampleTestCase(unittest.TestCase):

      def test_fake(self):
          self.assertEqual(0,0)

  def test_suite():
      suite = unittest.TestSuite()
      suite.addTest(unittest.makeSuite(SampleTestCase))
      return suite

  if __name__ == '__main__':
      unittest.main()

As you can see, we define a test case ``SampleTestCase`` here with a
plain and senseless test ``test_fake`` as part of the test case and
a test suite.

When we run the ``test`` programme again, we get::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  .
    Ran 1 tests with 0 failures and 0 errors in 0.000 seconds.

Ooh, we performed one test as indicated by the dot below
'Running:'.


Defining unit tests in a ``tests`` package
++++++++++++++++++++++++++++++++++++++++++

This is all very well, but normally you want more than only one module
for unit testing. It is part of the unit testing concept to test
different elements in different files. 

So the generally more recommended way is, to create a ``tests``
package, where all unit tests for your application can be put in.

So let's remove ``tests.py``::

  $ rm tests.py

Now create a ``tests/`` directory where we create an (empty) file
``__init__.py``::

  $ mkdir tests
  $ touch tests/__init__.py # make this directory a package

Such, we have an empty package ``tests`` wherein we will create a
slightly modified unit tests suite.

In ``src/sample/tests/`` create a file ``test_sample.py``.

.. code-block:: python

  """File: src/sample/tests/test_sample.py"""

  import unittest
  from sample.app import Sample

  class SampleTestCase(unittest.TestCase):

      def setUp(self):
          # Put here anything to be done before a test is run.
          pass

      def test_fake(self):
          self.assertEqual(0,0)

  def test_suite():
      suite = unittest.TestSuite()
      suite.addTest(unittest.makeSuite(SampleTestCase))
      return suite

  if __name__ == '__main__':
      unittest.main()

The file could in fact be exactly the same as above. We only added a
``setUp()`` method in the test case, which is very usual.

When we run the tests afterwards, we will get exactly the same results
as above::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  .
    Ran 1 tests with 0 failures and 0 errors in 0.000 seconds.

You can add as many test modules (files) to the ``tests`` package as
you like. The only requirement for the testrunner to handle them is,
that their filename starts with ``test``. So you can create a module
``simpletest.py`` and another ``testsomethingelse.py``, but only the
latter will be run by the testrunner.


Defining unit tests in subpackages
++++++++++++++++++++++++++++++++++

When your project starts to grow, even many modules in the ``tests``
package might not be sufficient. Especially if the number of tests
starts to be confusing, it is a good idea to create subpackages, where
you can aggregate the tests related to certain elements.

The problem with it is, that the testrunner does not automatically
scan all subpackages for test suites. We have to register them
manually, which can be done as follows.

1. create packages inside the ``tests`` directory:

   For our demonstration purposes we only create one package, called
   ``sampletests``::

     $ mkdir src/tests/sampletests
     $ touch src/tests/sampletests/__init__.py

   Note: don't name a subpackage in ``tests`` as your
   application. This will lead to import problems.

2. create a new ``test_sample.py`` which will 'drive' the tests,
   i.e. find the packages, that contain tests.

   .. code-block:: python

    """File: src/sample/tests/test_sample.py
    """
    import unittest
    from pkg_resources import resource_listdir
    from sample.app import Sample

    test_packages = ['sampletests']
    test_root = 'sample.tests'

    def suiteFromPackage(name):
        files = resource_listdir(__name__,name)
        testloader = unittest.TestLoader()
        suite = unittest.TestSuite()
        for filename in files:
            if not filename.endswith('.py'):
                continue
            if filename == '__init__.py':
                continue

            dottedname = '%s.%s.%s' % (test_root, name, filename[:-3])
            test = testloader.loadTestsFromName(dottedname)
            suite.addTest(test)
        return suite

    def test_suite():
        suite = unittest.TestSuite()
        for name in test_packages:
            suite.addTest(suiteFromPackage(name))
        return suite

    if __name__ == '__main__':
        unittest.main()
  


   In this little script the ``suiteFromPackage()`` function looks for
   a package called ``sample.tests.<name>``, loads all modules therein
   and adds their tests to a test suite which is returned.

   You have eventually to modify the variables 

   - ``test_root``, which sets the dotted name of the package, where
     the subpackages reside, and the list

   - ``test_modules``, which gives the names of the subpackages, where
     the real tests can be found.


3. Now fill the new ``sampletests`` package with tests. We can use the
   module we have already written above, but this time give it another
   name, not beginning with 'test'.

   Create a file ``samplefake.py`` in the ``sampletests`` package:

   .. code-block:: python

    """File: src/sample/tests/sampletests/samplefake.py"""

    import unittest
    from sample.app import Sample

    class SampleTestCase(unittest.TestCase):

        def setUp(self):
            # Put here anything to be done before a test is run.
            pass

        def test_fake(self):
            self.assertEqual(0,0)

    def test_suite():
        suite = unittest.TestSuite()
        suite.addTest(unittest.makeSuite(SampleTestCase))
        return suite

    if __name__ == '__main__':
        unittest.main()


When we run the tests afterwards, we will get exactly the same results
as above::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  .
    Ran 1 tests with 0 failures and 0 errors in 0.000 seconds.



Doing Unit Tests Using Doctests
-------------------------------

To integrate doctests into your test suite, you have to tell the
testrunner, that your tests are formulated in doctest format and not
simple Python code. Furthermore you have to tell which files (plain
text or Python files) contain doctests. This also is easy.

To clean up everything, you might remove the ``tests/`` directory::

  $ rm -rf src/sample/tests


Create (overwrite) a file ``src/sample/tests.py`` with the
following content:

.. code-block:: python

  """File: src/sample/tests.py
  """
  import unittest
  from zope.testing import doctest, cleanup
  import zope.component.eventtesting

  test_root = 'sample'
  doctestfiles = ['sample.txt','app.py']

  def setUpZope(test):
      zope.component.eventtesting.setUp(test)

  def cleanUpZope(test):
      cleanup.cleanUp()

  def test_suite():
      suite = unittest.TestSuite()
      for name in doctestfiles:
          suite.addTest(doctest.DocFileSuite(name,
                                             package=test_root,
                                             setUp=setUpZope,
                                             tearDown=cleanUpZope,
                                             optionflags=doctest.ELLIPSIS+
                                             doctest.NORMALIZE_WHITESPACE)
                        )
      return suite

  if __name__ == '__main__':
      unittest.main(defaultTest='test_suite')


Here we advice the testrunner to scan ``sample.txt`` and ``app.py`` in
the package ``sample`` for doctests. This is determined by the two
variables ``test_root`` and ``doctestfiles`` at the beginning. Now we
should define some tests there.

Create a file ``src/sample/sample.txt``:

.. code-block:: python

  """File: src/sample/sample.txt
   
     Sample applications are made for giving samples. They can
     easily be created:

        >>> from sample.app import Sample
        >>> s = Sample()
        >>> s
        <sample.app.Sample object at ...>

  """

If we run ``bin/test`` again, we get::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  ..
    Ran 2 tests with 0 failures and 0 errors in 0.450 seconds.

Oops, we got two tests? How come? Well, because ``app.py`` is scanned
for tests as well, it is also a test, although it doesn't contain any
testing code.

But we can add tests now to ``app.py``.

Modify ``src/sample/app.py`` to make it look like this:

.. code-block:: python

  import grok

  class Sample(grok.Application, grok.Container):
      """This is a sample application.

      It can be created this way:

        >>> from sample.app import Sample
        >>> s = Sample()
        >>> s
        <Sample object at ...>
    
      """
      pass

  class Index(grok.View):
      pass # see app_templates/index.pt


when we run the tests again, we get something like::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  ..

  Failure in test ../src/sample/app.py
  Failed doctest test for app.py
    File "../src/sample/app.py", line 0

  ----------------------------------------------------------------------
  File "../src/sample/app.py", line 10, in app.py
  Failed example:
      s
  Expected:
      <Sample object at ...>
  Got:
      <sample.app.Sample object at 0xb7ac65ec>


    Ran 2 tests with 1 failures and 0 errors in 0.466 seconds.

  Tests with failures:
     .../src/sample/app.py

Ouch! We expected a wrong object type. It is always a good idea, to
let your tests fail once. This way you make sure, that they are really
and correctly executed. 

Update the docstring in ``src/sample/app.py`` to expect the correct
object type:

.. code-block:: python

      """This is a sample application.

      It can be created this way:

        >>> from sample.app import Sample
        >>> s = Sample()
        >>> s
        <sample.app.Sample object at ...>
    
      """

and run the tests again. Now no failures should show up::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  ..
    Ran 2 tests with 0 failures and 0 errors in 0.465 seconds.



Doctests in Separate ``tests`` Package
++++++++++++++++++++++++++++++++++++++

It is quite usual, to put all tests for a package in a subpackage
``tests``. To create such a package you don't have to do much.

Just create a ``tests`` directory in your package, put an (empty)
``__init__.py`` in it and place the ``tests.py`` file from above in
the new directory, eventually using a new name (beginning with
'test')::

  $ mkdir src/sample/tests
  $ touch src/sample/tests/__init__.py
  $ mv src/sample/tests.py src/sample/tests/test_sample.py


That's it. You can easily modify ``test_sample.py`` to support both,
tests in the application package (``sample``) and tests in the
``sample.tests`` package. This is left to the gentle reader as an
exercise. 

Defining Doctests in Subpackages
++++++++++++++++++++++++++++++++

To get the whole picture, we want to set up a testing environment,
which looks for doctests in subpackages of a ``tests`` package and in
the application root (``src/sample/``) as well. To do this, we make
use of the ``DocTestSuite`` feature provided by
``zope.testing.doctest``. It scans whole modules for doctests and
returns them as unittest test suites.

Create (overwrite) a file ``src/sample/tests/test_sample.py`` with the
following content:

.. code-block:: python

  """File: src/sample/tests/test_sample.py
  """
  import unittest
  from pkg_resources import resource_listdir
  from zope.testing import doctest, cleanup
  import zope.component.eventtesting

  test_root = 'sample'
  doctestfiles = ['sample.txt','app.py']
  test_packages = ['sampletests']

  def setUpZope(test):
      zope.component.eventtesting.setUp(test)

  def cleanUpZope(test):
      cleanup.cleanUp()

  def suiteFromPackage(name):
      files = resource_listdir(__name__, name)
      suite = unittest.TestSuite()
      for filename in files:
          if not filename.endswith('.py'):
              continue
          if filename.endswith('_fixture.py'):
              continue
          if filename == '__init__.py':
              continue

          dottedname = '%s.tests.%s.%s' % (test_root, name, filename[:-3])
          test = doctest.DocTestSuite(dottedname,
                                      setUp=setUpZope,
                                      tearDown=cleanUpZope,
                                      optionflags=doctest.ELLIPSIS+
                                      doctest.NORMALIZE_WHITESPACE)
          suite.addTest(test)
      return suite

  def test_suite():
      suite = unittest.TestSuite()
      for name in test_packages:
          suite.addTest(suiteFromPackage(name))
      for name in doctestfiles:
          suite.addTest(doctest.DocFileSuite(name,
                                             package=test_root,
                                             setUp=setUpZope,
                                             tearDown=cleanUpZope,
                                             optionflags=doctest.ELLIPSIS+
                                             doctest.NORMALIZE_WHITESPACE)
                        )
      return suite

  if __name__ == '__main__':
      unittest.main(defaultTest='test_suite')


As you can see, this piece of code is the same as the one shown
before, but with an extra ``suiteFromPackage()`` method, which scans
also complete packages for doctests. The three variables
``test_root``, ``doctestfiles`` and ``test_packages``, set at the
beginning, determine the dotted name of the application
(``test_root``), the list of files to scan for doctests in the
application root (``doctestfiles``) and the list of subpackages in
``tests`` which contain doctests (``test_packages``).


If we now run ``bin/tests`` we first get an error::

  $ ./bin/test
  Running tests at level 1
  Test-module import failures:

  Module: sample.tests.test_sample

  OSError: [Errno 2] No such file or directory: '../src/sample/tests/sampletests'


  Total: 0 tests, 0 failures, 0 errors in 0.000 seconds.

  Test-modules with import problems:
    sample.tests.test_sample

We required to scan a package ``sampletest`` which yet does not
exist. Let's do it now.

We create the test package ``src/sample/tests/sampletests``::

  $ mkdir src/sample/tests/sampletests
  $ touch src/sample/tests/sampletests/__init__.py

and create a doctest file ``create.py`` wherein we check (once again),
whether ``Sample`` objects can be created:

.. code-block:: python

  """File src/sample/tests/sampletests/create.py
  
  Silly check, whether Samples can be created:
  
    >>> from sample.app import Sample
    >>> s = Sample()
    >>> s
    <sample.app.Sample object at ...>
  
  """

When we run the tests again, all three doctest files are parsed for
unittests and executed::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  ...
    Ran 3 tests with 0 failures and 0 errors in 0.456 seconds.


Doctests as Part of Documentation
+++++++++++++++++++++++++++++++++

The doctests provided above are silly in the sense, that they do not
test important things and that they use three different locations to
perform the same test.

For real-world-tests you will avoid such duplicates and - more
important - make a decision, which tests to put in which
environment. It does not neccessarily make sense to bother people with
tons of tests in the application root, while some tests, that help
people to understand how your application/module/whatever really
works, should not be hidden away in a 'far away' subpackage of another
subpackage. 

It is after all up to you, the developer, to decide, which tests should
be part of documentation and which should not.



Functional Tests
----------------

As mentioned in the `Types of Tests`_ section, functional tests are
different from unit tests in many aspects. They can, however, be
written as doctests as well and this is the only method we cover in
this tutorial. All functional tests described below are doctests.

We already said, that functional tests treat Zope like a black box,
where we can 'send' requests to and check the result. Functional tests
therefore are primarily used for browser-related testing, checking
views and similar.

Because this means, that a very complex framework must be prepared and
enabled before running functional tests, there is also more effort
neccessary to keep them going. The main action to take beforehand, is
to setup an appropriate *layer*, which is able to simulate the
system. 

Usually, the main configuration task of the layer is it, to provide
credentials for the testing environment.

Fortunately, Grok projects come with such a credentials configuration
already prepared (in ``src/sample/ftesting.zcml``), so you don't have
to set it up yourself. To 'activate' this configuration, we need some
code, which is part of ``test_functional.py`` as shown below.

We want to test the ``Index`` class of our sample application.
Because ``Index`` is a view, we want to make sure, that it displays,
what we expect it to display when we add a ``Sample`` object to the
root.

To prepare this, we first create a subdirectory ``src/sample/ftests``,
where we will put our fundtional tests in::

  $ mkdir src/sample/ftests

Then we make this directory a Python package::

  $ touch src/sample/ftests/__init__.py

In the freshly created directory we put a 'test collector' and a
doctest file. First the 'test collector'.

Create a file ``src/sample/ftests/test_functional.py``:

.. code-block:: python

  """File: src/sample/ftests/test_functional.py
  """
  import unittest
  import grok
  import os.path

  from pkg_resources import resource_listdir
  from zope.testing import doctest
  from zope.app.testing.functional import (HTTPCaller, getRootFolder,
                                           FunctionalTestSetup, sync, ZCMLLayer,
                                           FunctionalDocFileSuite)

  test_root = 'sample'
  doctestfiles = ['index.txt']
  test_packages = []

  ftesting_zcml = os.path.join(os.path.dirname(grok.__file__), 'ftesting.zcml')
  SampleFunctionalLayer = ZCMLLayer(ftesting_zcml, __name__, 'SampleFunctionalLayer')

  def setUp(test):
      FunctionalTestSetup().setUp()

  def tearDown(test):
      FunctionalTestSetup().tearDown()

  def suiteFromPackage(name):
      files = resource_listdir(__name__, name)
      suite = unittest.TestSuite()
      for filename in files:
          if not filename.endswith('.py'):
              continue
          if filename == '__init__.py':
              continue

          dottedname = '%s.ftests.%s.%s' % (test_root, name, filename[:-3])
          test = doctest.DocTestSuite(
              dottedname, setUp=setUp, tearDown=tearDown,
              extraglobs=dict(http=HTTPCaller(),
                              getRootFolder=getRootFolder,
                              sync=sync),
              optionflags=(doctest.ELLIPSIS+
                           doctest.NORMALIZE_WHITESPACE+
                           doctest.REPORT_NDIFF)
              )
          test.layer = SampleFunctionalLayer

          suite.addTest(test)
      return suite

  def suiteFromFile(name):
      suite = unittest.TestSuite()
      test = FunctionalDocFileSuite(
          name, setUp=setUp, tearDown=tearDown,
          globs=dict(http=HTTPCaller(),
                     getRootFolder=getRootFolder,
                     sync=sync
                     ),
              optionflags = (doctest.ELLIPSIS+
                             doctest.NORMALIZE_WHITESPACE+
                             doctest.REPORT_NDIFF)
          )
      test.layer = SampleFunctionalLayer
      suite.addTest(test)
      return suite

  def test_suite():
      suite = unittest.TestSuite()
      for name in test_packages:
          suite.addTest(suiteFromPackage(name))
      for name in doctestfiles:
          suite.addTest(suiteFromFile(name))
      return suite

  if __name__ == '__main__':
      unittest.main(defaultTest='test_suite')


To add any functional tests, we just have to modify the variables
``doctestfiles`` (a list of filenames in ``src/sample/ftests/``
containing functional tests) and ``test_packages`` (a list of package
names, which are looked up in ``src/sample/ftests``. Afterwards all
functional tests in subpackages of ``sample/ftests`` are scanned for
*.py* files and considered as functional tests. This is true for
packages registered in ``test_packages``.

Let's create the real functional tests for the ``Index`` class in
``src/sample/ftests/index.txt``. The filename is already contained in
the ``doctestfiles`` list of the above code.

Create a file ``src/sample/ftests/index.txt``::

  Use the Grok admin UI to create an instance of the app::

    >>> import grok
    >>> grok.grok('sample.app')

    >>> from zope.testbrowser.testing import Browser
    >>> browser = Browser()
    >>> browser.addHeader('Authorization', 'Basic mgr:mgrpw')
    >>> browser.handleErrors = False
    >>> browser.open('http://localhost/')
    >>> browser.getControl('Application').displayValue = ['sample.app.Sample']
    >>> browser.getControl('Name').value = 'sample01'
    >>> browser.getControl('Add').click()

  Navigate to the index page and verify its contents::

    >>> browser.getLink('sample01').click()
    >>> "Your Grok application is up and running." in browser.contents
    True

  The default Grok app is also a container, but initially it is empty::

    >>> root = getRootFolder()
    >>> sample = root['sample01']
    >>> print sample.keys()
    <OOBTreeItems object at ...>
    >>> print len(sample.keys())
    0

If we now run the testrunner, we see three new tests::

  $ ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  ...
    Ran 3 tests with 0 failures and 0 errors in 0.007 seconds.
  Running sample.ftests.test_functional.SampleFunctionalLayer tests:
    Set up sample.ftests.test_functional.SampleFunctionalLayer in 1.259 seconds.
    Running:
  ...
    Ran 3 tests with 0 failures and 0 errors in 0.221 seconds.
  Tearing down left over layers:
    Tear down sample.ftests.test_functional.SampleFunctionalLayer ... not supported
  Total: 6 tests, 0 failures, 0 errors in 1.647 seconds.


(This assumes you already implemented the unit tests as described
above; otherwise the 'unit tests' section will be empty).


Functional Tests in Subpackages
+++++++++++++++++++++++++++++++

To add a subpackage with functional tests, we can reuse the code shown
in the last section. So we need ``src/ftests/test_functional.py`` as
above.  

Now, just add a package like this::

  $ mkdir src/sample/ftests/index
  $ touch src/sample/ftests/index/__init__.py

and add a functional tests file.

Create a file ``src/sample/ftests/index/create.py`` with the following
content:

.. code-block:: python

  """
  Use the Grok admin UI to create an instance of the app::

    >>> import grok
    >>> grok.grok('sample.app')

    >>> from zope.testbrowser.testing import Browser
    >>> browser = Browser()
    >>> browser.addHeader('Authorization', 'Basic mgr:mgrpw')
    >>> browser.handleErrors = False
    >>> browser.open('http://localhost/')
    >>> browser.getControl('Application').displayValue = ['sample.app.Sample']
    >>> browser.getControl('Name').value = 'sample01'
    >>> browser.getControl('Add').click()

  Navigate to the index page and verify its contents::

    >>> browser.getLink('sample01').click()
    >>> "Your Grok application is up and running." in browser.contents
    True

  The default Grok app is also a container, but initially it is empty::

    >>> root = getRootFolder()
    >>> sample = root['sample01']
    >>> print sample.keys()
    <OOBTreeItems object at ...>
    >>> print len(sample.keys())
    0
  """

Note, that this is a Python file, not a text file! In subpackages only
Python files will be run by the testrunner. Therefore you have to
format the whole test as a docstring (surrounded by triple quotation
marks (""")).

The advantage of this is, that you can also define classes functions
and variables at the bottom of the file, which will automatically be
parsed before your tests are run. In the example code we did not.

Last, not least, we have to 'register' the new ftesting package in
``src/sample/ftests/test_functional.py``. Look for the line::

  test_packages = []

and replace it with::

  test_packages = ['index']

This will make sure, that the testrunner will look for a subpackage
called ``index`` in ``src/sample/ftests/`` and execute all functional
tests defined in modules therein. You can afterwards add as many
testing modules in ``src/sample/ftests/index/`` as you like, without
changing ``test_functional.py`` anymore.

When you now run the tests again, you should get an error::

  $ bin/test
    Running tests at level 1
  Running unit tests:
    Running:
  ...
    Ran 3 tests with 0 failures and 0 errors in 0.007 seconds.
  Running sample.ftests.test_functional.SampleFunctionalLayer tests:
    Set up sample.ftests.test_functional.SampleFunctionalLayer in 1.265 seconds.
    Running:
  ......
  Failure in test .../Sample/src/sample/ftests/index.txt
  Failed doctest test for index.txt

with tons of messages following, ending with::

  DuplicationError: <class 'sample.app.Index'>


What happened? You might have noticed, that in our functional tests,
we registered the classes to test with Grok like this:

.. code-block:: python 

  grok.grok('sample.app')

Such we make sure, that the classes in ``app.py`` are grokked, which
is neccessary to have ``sample.app.Sample`` objects available in the
admin-UI. However, if we do it twice, Grok complains.

Therefore we have to delete the registration in index.txt.

Delete the line in ``src/sample/ftests/index.txt`` saying::

  >>> grok.grok('sample.app')

and rerun the tests::

  ./bin/test
  Running tests at level 1
  Running unit tests:
    Running:
  ...
    Ran 3 tests with 0 failures and 0 errors in 0.010 seconds.
  Running sample.ftests.test_functional.SampleFunctionalLayer tests:
    Set up sample.ftests.test_functional.SampleFunctionalLayer in 1.291 seconds.
    Running:
  ......
    Ran 6 tests with 0 failures and 0 errors in 0.259 seconds.
  Tearing down left over layers:
    Tear down sample.ftests.test_functional.SampleFunctionalLayer ... not supported
  Total: 9 tests, 0 failures, 0 errors in 1.719 seconds.

Now we got six successfull functional tests and a total of nine tests.


