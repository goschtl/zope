#!/usr/bin/env python

"""Apply actions dictated by traffic_table.py to checkins as they occur.

Normal operation is to fork into the background with stderr and stdout
redirected to append to the file named by the OUTPUT_LOG config var - so
that the user doesn't have to wait for the checkin message to be collected
and sent or for the rsync to complete.  (We can't simply fork into the
background, because clients like emacs VC will hang waiting the close of
sys.stdin, sys.stderr, sys.stdout, etc. - on the order of minutes.)

Options:

 --verbose - operate in verbose mode, with output to OUTPUT_LOG in the
             detached copy, and to stdout before the detach (and forever if 
             --wait specified)

 --recurse - remote repository sync recurses into all subject dirs offspring

 --dryrun - do not actually do any of the activities

 --wait - do not fork into the background (and leave output in stdout/stderr)

 --syncrepo - only do the recursive repository setup (good for initting the
              remote copy or rectifying gaps that crept in)

 --msgfile MSGFILENM - get log message from MSGFILENM (and delete it!)

An optional leading arg --verbose argument says operate verbosely.

We expect to be invoked from loginfo with %{CVSROOT} %{sVv}: The %{sVv}
format string is expanded into a single argument passed in, containing
multiple space-delimited parts:

  - The first part is the path of repository directory

  - Then a comma-concatenated string for each file being checked in,
    consisting of:

    - The file name,
    - The old version number, then
    - the new one, like so

    filename,1.1,1.2

\(See the CVS Gnu INFO file for loginfo for more format-string details.)

Currently the actions are:

 - doing a g+w chmod of the subject files
 - emailing checkin messages to designated recipients
 - doing an rsync of the repository to the public repository host.

... with settings for the latter two configured in the traffic_table.py
module."""

import sys, os, tempfile
import re, string
import getopt

import traffic_table

OUTPUT_LOG = "/var/tmp/cvs-postcommit_actions.log"
ERROR_LOG = "/var/tmp/cvs-postcommit_actions.errors"

MAIL_CMD = "/bin/mail"
SSH_EXE_PATH = RSYNC_EXE_PATH = ["/bin", "/usr/bin", "/usr/local/bin"]

# XXX IDENTITY_FILE must be readable by the process of anyone doing a
#     checkin that uses the rsync mechanism.  Ideally, that would be by
#     virtue of a particular group membership - world readable opens up the 
#     rsync privilege to everyone on the system.
IDENTITY_ACCT = "dccvs"
IDENTITY_FILE = "/cvs-repository/cvsidentity"


WAIT = 0                                # Fork unless waiting is requested.
RECURSE = 0                             # '--recurse' option
DRYRUN = 0                              # '--dryrun' option
VERBOSE = 0                             # '--verbose' option
MSGFILENM = ""                            # '--msgfile' option (value of arg)
SCRIPT = "postcommit_actions"           # Changes to args[0], when obtained.

sVv_re = re.compile("(.*),([^,]+),([^,]+)")

def main(args):
    """Grok the args and the traffic_table and process accordingly."""

    global SCRIPT, DRYRUN, VERBOSE, RECURSE, WAIT, MSGFILENM

    orig_args = args[:]

    SCRIPT = args[0]
    try:
        opts, args = getopt.getopt(args[1:], "", ["verbose", "dryrun",
                                                  "recurse", "wait",
                                                  "msgfile=", "syncrepo"])
    except getopt.error, err:
        complain("%s\n", err)
        raise SystemExit, 1

    only_repo = 0

    if len(args) != 1:
        usage(); raise SystemExit, 1
    for opt, val in opts:
        if opt == "--verbose":
            VERBOSE = 1
            complain("%s: VERBOSE mode...\n", SCRIPT)
        elif opt == "--dryrun":
            DRYRUN = 1
            complain("%s: DRYRUN mode...\n", SCRIPT)
        elif opt == "--recurse":
            RECURSE = 1
            complain("%s: FULL-DEPTH RECURSE mode...\n", SCRIPT)
        elif opt == "--wait":
            WAIT = 1
            complain("%s: Not doing activities in background...\n", SCRIPT)
        elif opt == "--msgfile":
            MSGFILENM = val
        elif opt == "--syncrepo":
            RECURSE = 1
            WAIT = 1
            VERBOSE = 1
            only_repo = 1
        else:
            complain("Unrecognized option '%s'\n", opt)
            raise SystemExit, 1
    if VERBOSE:
        complain("Initial args: %s '%s'\n",
                 string.join(orig_args[:-1], " "),
                 orig_args[-1])
    # The %{sVv} args are passed in as a single token - have to split them.
    split_args = string.split(args[0])

    repo = split_args[0]
    subjs = map(grok_file, split_args[1:])

    if VERBOSE:
        complain("CWD: %s, Repo: %s, ", os.getcwd(), repo)
        complain("Subjects: %s\n", subjs)

    got = find_entries(repo)

    if not WAIT:
        detach(orig_args)

    if not only_repo:
        do_chmod(subjs)

    for entry in got:
        (path, expr, excludes, addrs, remote) = entry
        if addrs and not only_repo:
                do_mail(path, repo, addrs, subjs)
        if remote:
            print "remote:", remote
            do_sync(path, repo, remote, subjs, excludes, recurse=RECURSE)
    if not got and only_repo:
            print "no remote"
            note_failure("*** --syncrepo invalid - no repository"
                         " for %s in config file.\n",
                         repo)

    if VERBOSE:
        complain("Done.\n")

    if failures:
        handle_failures()

def detach(args):
    """Fork us into the background, with stdout and stderr to OUTPUT_LOG."""
    global MSGFILENM

    doctored_args = [args[0]]
    doctored_args.append("--wait")
    if not MSGFILENM:
        tempfile.mktemp()           # Throw one away, to get initial template.
        tempfile.tempdir = "/tmp"
        tempfile.template = "cvs-log" + tempfile.template
        msgfile = open(tempfile.mktemp(), 'w')
        msgfile.write(sys.stdin.read())
        msgfile.close()
        MSGFILENM = msgfile.name
    doctored_args.append("--msgfile")
    doctored_args.append(MSGFILENM)
    for i in args[1:]:
        doctored_args.append('"%s"' % i)
    cmd = (("( exec 1> %s 2>&1; " + string.join(doctored_args, " ") +  " &)")
           % OUTPUT_LOG)
    
    if VERBOSE:
        complain("Reexecing detached, cmd:\n\t%s\n", cmd)

    os.system(cmd)
    loosen_file(OUTPUT_LOG)

    os._exit(0)

def find_entries(repo):
    """Return all traffic_table entries that trigger for repo."""
    got = []
    for t in traffic_table.table:
        if re.search(t[1], repo):
            got.append(t)
    if VERBOSE > 1:
        complain("Resolved table entry:\n  %s\n", got)
    return got

def do_mail(name, repo, addrs, subjs):
    """Send notice about checkin to addresses dictated by traffic table."""
    if VERBOSE:
        complain("Notice to %s for %s / %s\n", addrs, repo, subjs)
    # The message contents are on stdin, just _yearning_ to be sent...-)
    subject = "CVS checkin: %s -" % name
    for fn, old, new in subjs:
        subject = subject + " %s:%s" % (fn, new)
    cmd = ("%s%s%s %s -s '%s' %s" % ((VERBOSE and "set -x; ") or "",
                                     (DRYRUN and "echo ") or "",
                                     MAIL_CMD,
                                     (VERBOSE and "-v") or "",
                                     subject,
                                     string.join(addrs, ",")))
    if MSGFILENM:
        cmd = cmd + "< %s" % MSGFILENM

    if VERBOSE:
        complain("Doing mail cmd:\n\t%s\n", cmd)
    result = os.system(cmd)
    if result:
        note_failure("*** Mail returned %s...", result)

    if MSGFILENM:
        os.unlink(MSGFILENM)

def do_sync(name, repo, remote, subjs=None, excludes=None, recurse=0):
    """Instigate repository mirror synchronize.

    The repository directory containing the subjects is synced.  (In fact,
    the actual setting of subjs doesn't matter.)  If recurse is set, then
    the recursion extends to full depth below the repo dir (and the
    activity is conducted in the foreground)."""

    RSYNC_EXE = get_command("rsync", RSYNC_EXE_PATH)
    if not RSYNC_EXE:
        note_failure("*** Rsync executable not found, skipping it!")
        return
    SSH_EXE = get_command("ssh", SSH_EXE_PATH)
    if not SSH_EXE:
        note_failure("*** Ssh executable not found, skipping rsync!")
        return

    if VERBOSE:
        fnames = string.join(map(lambda x: x[0], subjs), ",")
        complain("Sync for %s to %s; of %s/ %s / %s\n",
                 name, remote, os.environ["CVSROOT"], repo, fnames)

    ssh_fragment = ('--rsh="%s %s -i %s -l %s"'
                    % (SSH_EXE, (VERBOSE and "-v") or "",
                       IDENTITY_FILE, IDENTITY_ACCT))
    
    if excludes:
        specific_excludes = ' --exclude "%s"' % excludes
    else:
        specific_excludes = ''

    cmd = (RSYNC_EXE
           + " %s " % ssh_fragment
           + " --update"                # Preserve newer files
           + " --recursive"
           + ' --exclude "#cvs.*"'      # Do not dup cvs lock files
           + ' --exclude ".#*"'         # Do not dup cvs backup files
           + specific_excludes          # empty if None specified
           + " --links"                 # preserve soft-links
           + " --hard-links"            #    "     hard-links
           + " --perms"                 #    "     permissions
           + " --times"                 #    "     times
           + " --sparse"                # handle sparse files efficiently
           + " --delete"                # keep remote directory in sync
           #+ " --compress"              # (more compression context than ssh)
           )
    if VERBOSE:
        cmd = cmd + " --verbose"

    if not recurse:
        cmd = cmd + ' --exclude "/*/*"'

    try:
        repodir = remote['repodir'] % name
    except TypeError:
        repodir = remote['repodir']

    cmd = ("%s%s%s %s/%s/ %s:%s/%s/" % ((VERBOSE and "set -x; ") or "",
                                    (DRYRUN and "echo ") or "",
                                    cmd,
                                    os.environ["CVSROOT"], repo,
                                    remote['host'], repodir, repo))
    if VERBOSE:
        complain("Doing rsync cmd:\n\t%s\n", cmd)

    result = os.system(cmd)
    if result:
        note_failure("*** Rsync returned %s...", result)

def do_chmod(subjs):
    fnames = map(lambda x: x[0], subjs)
    if not fnames:
        fnames = ["."]
    cmd = ("%s%schmod g+w %s" % ((VERBOSE and "set -x; ") or "",
                                 (DRYRUN and "echo ") or "",
                                 string.join(fnames, " ")))
    if VERBOSE:
        complain("Reexecing, cmd:\n\t%s\n", cmd)
    result = os.system(cmd)
    if result:
        note_failure("*** Chmod returned %s...", result)

def loosen_file(fname):
    """Relax permissions on (newly created) file so others can use it too."""
    try:
        os.chmod(fname, 0777)
    except os.error, err:
        complain("loosen_file of %s can't: %s", fname, err)

def grok_file(s):
    """Separate "file,old-version,new-version"."""
    m = sVv_re.match(s)
    if not m:
        raise ValueError, "'%s' not in file,old-vers,new-vers format" % s
    return m.groups()

failures = 0
def note_failure(msg, *args):
    """Register a failure for handle_failures to announce at the end."""
    global failures
    failures = 1
    apply(complain, (msg,) + args)

def handle_failures():
    """Do something useful with the session log, if we saw any failures."""
    complain("Adding session log to errors %s\n", `ERROR_LOG`)
    if os.path.isfile(OUTPUT_LOG):
        all = open(OUTPUT_LOG, 'r').read()
    else:
        # Can only do the complaints:
        all = string.join(complaints, "\n")
    loosen_file(OUTPUT_LOG)

    open(ERROR_LOG, 'a').write(all)
    loosen_file(ERROR_LOG)

def usage():
    complain("Usage: %s [options...] ", SCRIPT)
    complain("repo-path file,oldv,newv [f2,o2,n2 ...]\n")

def get_command(cmd, path):
    """Get a valid exe for cmd on path."""
    for d in path:
        maybe = os.path.join(d, cmd)
        if os.path.isfile(maybe):
            return maybe
    note_failure("No usable %s executable found.\n", `cmd`)
    

complaints = []
def complain(msg, *args):
    global complaints
    complaints.append(msg % args)
    sys.stderr.write(msg % args)
    sys.stderr.flush()

if __name__ == "__main__":
    main(sys.argv)

