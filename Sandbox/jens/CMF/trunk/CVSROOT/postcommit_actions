#!/usr/bin/env python

"""Apply actions dictated by traffic_table.py to checkins as they occur.

Normal operation is to fork into the background with stderr and stdout
redirected to append to the file named by the OUTPUT_LOG config var - so
that the user doesn't have to wait for the checkin message to be collected
and sent or for the rsync to complete.  (We can't simply fork into the
background, because clients like emacs VC will hang waiting the close of
sys.stdin, sys.stderr, sys.stdout, etc. - on the order of minutes.)

Options:

 --verbose - operate in verbose mode, with output to OUTPUT_LOG in the
             detached copy, and to stdout before the detach (and forever if 
             --wait specified)

 --recurse - remote repository sync recurses into all subject dirs offspring

 --dryrun - do not actually do any of the activities

 --wait - do not fork into the background (and leave output in stdout/stderr)

 --syncrepo - syncronize the mirror, don't do other activities - good for
              initting the remote copy or rectifying gaps that crept in.
              The rsync will be verbose when doing --syncrepo.

 --syncall - do --syncrepo for all entries in the traffic table.

 --msgfile MSGFILENM - internal - get log message from MSGFILENM (and delete)

We expect to be invoked from loginfo with %{CVSROOT} %{sVv}: CVS expands
the loginfo %{sVv} into a single command-line token (bizarrely enough)
containing multiple, space-delimited parts:

  - The first part is the path of repository directory

  - Then comes a comma-concatenated string for each file being checked in,
    consisting of:

    - The file name,
    - The old version number, then
    - the new one, like so:

      filename,1.52,1.53

\(See the CVS Gnu INFO file for loginfo for more format-string details.)

The actions are configured in traffic_table.py.  The only remaining relevant
one is:

 - email checkin messages to designated recipients

The following two actions are deprecated:

 - do an rsync of the repository to the public repository host.
   - With the separation of the public and private repositories, and the
     ability to checkin directly to the public repository, this is no longer
     necessary.  The setup for it (rsync, identity files, etc) are not
     established in the public repo.
 - do a g+w chmod of the subject files - unset CHMOD_GW to disable this
   - This does not seem to be necessary, and has not worked for a while.

Note that any intervening directories between the CVSROOT and the root of
the repository project directory will not be created on the mirror by the
rsync procedure - they must be created somehow else.  Though this can be
inconvenient, it is beneficial in that it provides a sort of sanity check
on the target directories."""

import sys, os, tempfile, time, pwd
import string
import getopt
import smtplib
import socket, whrandom, getpass

CVSROOT = os.environ.get('CVSROOT', '/cvs-repository')
os.chdir('/tmp')                        # So we have a valid working directory.

#SMTP_SERVER = 'smtp.digicool.com'
#SENDER_ADDR = '"Digicool CVS" <cvs@digicool.com>'
CUSTOM_TRAFFIC_TABLE = "%s/custom_traffic_table.py" % CVSROOT

try:
    import re
    got_re = 1
except ImportError:
    import regex
    got_re = 0

import traffic_table
# Hook up with an outboard file.
if os.path.exists(CUSTOM_TRAFFIC_TABLE):
    execfile(CUSTOM_TRAFFIC_TABLE)

# OUTPUT_LOG must be writable by anyone whose checkins will invoke this
# script in order for their logging to happen.
OUTPUT_LOG = "%s/cvs-postcommit_actions.log" % CVSROOT

# Set CVSMASTER to the email address of someone managing your CVS mirroring.
# Notices about any caught malfunctions will be sent to this address.
CVSMASTER = "klm@digicool.com"

# Zero CHMOD_GW this if you don't want automatic chmod g+w of files that were
# checked in. 
CHMOD_GW = 1
# Set if you don't care about chmod failures (apparently necessary for,
# eg, people doing remote :ext: and :pserver: checkins).
CHMOD_CASUAL = 1

MAIL_CMD = "/usr/lib/sendmail"
MAIL_CMD_FULLNAME_SLOT = "-F'%s'"
SSH_EXE_PATH = RSYNC_EXE_PATH = ["/bin", "/usr/bin", "/usr/local/bin"]

# IDENTITY_FILE must be readable by anyone doing a checkin that uses the
# rsync mechanism.  It's better to have it group readable, and everyone
# that needs in the group - world readable opens up the rsync privilege to
# everyone on the system.
# XXX It may make sense to have a fallback to individual people's identity
#     files when no central one exists.

IDENTITY_ACCT = "dccvs"
IDENTITY_FILE = "%s/cvsidentity" % CVSROOT
KNOWN_HOSTS_FILE = "%s/cvs-known_hosts" % CVSROOT


WAIT = 0                                # Fork unless --wait is requested.
RECURSE = 0                             # '--recurse' option
DRYRUN = 0                              # '--dryrun' option
VERBOSE = 0                             # '--verbose' option
SYNCREPO = 0                            # '--syncrepo' option
SCRIPT = "postcommit_actions"           # Will b set to argv[0], when obtained.

if got_re:
    sVv_re = re.compile("(.*),([^,]+),([^,]+)")
else:
    sVv_re = regex.compile("\\(.*\\),\\([^,]+\\),\\([^,]+\\)")

def main(args):
    """Grok the args and the traffic_table and process accordingly."""

    global SCRIPT, DRYRUN, VERBOSE, RECURSE, WAIT, SYNCREPO

    orig_args = args[:]

    SCRIPT = args[0]
    try:
        opts, args = getopt.getopt(args[1:], "", ["verbose", "dryrun",
                                                  "recurse", "wait",
                                                  "msgfile=", "syncrepo",
                                                  "syncall",
                                                  ])
    except getopt.error, err:
        complain("%s\n", err)
        raise SystemExit, 1

    only_sync = 0
    sync_all = 0
    msgfilenm = ""

    for opt, val in opts:
        if opt == "--verbose":
            VERBOSE = 1
            complain("%s: VERBOSE\n", SCRIPT)
        elif opt == "--dryrun":
            DRYRUN = 1
            complain("%s: DRYRUN\n", SCRIPT)
        elif opt == "--recurse":
            RECURSE = 1
            complain("%s: FULL-DEPTH RECURSE\n", SCRIPT)
        elif opt == "--wait":
            WAIT = 1
            complain("%s: WAIT/Foreground\n", SCRIPT)
        elif opt == "--msgfile":
            # This is internal, for the script to pass itself a file.
            msgfilenm = val
        elif opt == "--syncrepo":
            SYNCREPO = 1
            RECURSE = 1
            WAIT = 1
            only_sync = 1
            complain("%s: SYNCREPO\n", SCRIPT)
        elif opt == "--syncall":
            SYNCREPO = 1
            RECURSE = 1
            WAIT = 1
            only_sync = 1
            sync_all = 1
            complain("%s: SYNCALL\n", SCRIPT)
        else:
            complain("Unrecognized option '%s'\n", opt)
            raise SystemExit, 1
    if VERBOSE:
        complain("Initial args: %s '%s'\n",
                 string.join(orig_args[:-1], " "),
                 orig_args[-1])
        complain("Working dir: %s\n" % safe_getcwd('/tmp'))

    if not sync_all and len(args) != 1:
        usage(); raise SystemExit, 1

    doing_directory = 0
    no_files = 1
    if sync_all:
        entries = all_entries()
        repo = "DEBUG"
        subjs = "<everything>"
    else:
        # The %{sVv} args are passed in as a single token - have to split them.
        split_args = string.split(args[0])
        repo = split_args[0]

        if len(split_args) == 0:
            subjs = ["<no files>", "", ""]
        elif len(split_args) == 1:
            subjs = split_args + ["", ""]
        elif split_args[1] == "-":
            subjs = split_args
            doing_directory = 1
        else:
            no_files = 0
            subjs = map(grok_file, split_args[1:])

        if VERBOSE:
            complain("CWD: %s, Repo: %s, ",
                     safe_getcwd('/tmp'), repo)
            complain("Subjects: %s\n", subjs)

        if not WAIT:
            detach(orig_args)

        entries = find_entries(repo)

##    if CHMOD_GW and not only_sync:
##        if doing_directory:
##            do_chmod(['.'])
##        elif not no_files:
##            do_chmod(subjs)

    for entry in entries:
        wasVerbose = VERBOSE
        VERBOSE = entry.get('verbose', VERBOSE)
        selector_path, addrs = entry['path'], entry['addrs']
        excludes, remote = entry['excludes'], entry['remote']
        if remote:
            receiverid = remote.get('receiverid', IDENTITY_ACCT)
        else:
            receiverid = None

        if addrs and not only_sync:
            do_mail(remote, repo, addrs, subjs, msgfilenm=msgfilenm,
                    doing_directory=doing_directory, no_files=no_files)

        if remote:
            do_sync(selector_path, repo, remote, receiverid, subjs, excludes,
                    recurse=RECURSE, 
                    doing_directory=doing_directory, no_files=no_files)

        VERBOSE = wasVerbose
    if not entries and only_sync:
            note_failure("*** --syncrepo invalid - no repository"
                         " for %s in config file.\n",
                         repo)

    if VERBOSE:
        complain("Done.\n")

    if failures:
        handle_failures(orig_args)

    if msgfilenm:
        os.unlink(msgfilenm)

def detach(args):
    """Fork us into the background, with stdout and stderr to OUTPUT_LOG.

    We have to disconnect std io (in, out, and err) and run the program in
    the background - which we do using some shell wizardry."""

    doctored_args = [args[0]]
    doctored_args.append("--wait")
    tempfile.mktemp()           # Throw one away, to get initial template.
    tempfile.tempdir = "/tmp"
    template = (tempfile.template or
                "@%s.%d" % (os.getpid(), whrandom.randint(1000000, 9999999)))
    tempfile.template = "cvs-log" + template
    msgfile = open(tempfile.mktemp(), 'w')
    msgfile.write(sys.stdin.read())
    msgfile.close()
    msgfilenm = msgfile.name
    doctored_args.append("--msgfile")
    doctored_args.append(msgfilenm)
    for i in args[1:]:
        doctored_args.append('"%s"' % i)
    cmd = (("( exec 1>>%s 2>&1; "
            + ("export CVSROOT=%s; " % CVSROOT)
            + string.join(doctored_args, " ") +  " &)")
           % OUTPUT_LOG)
    
    if VERBOSE:
        complain("Reexecing detached in %s, cmd:\n\t%s\n",
                 safe_getcwd('/tmp'), cmd)

    os.system(cmd)
    loosen_file(OUTPUT_LOG)

    os._exit(0)

def all_entries():
    return find_entries(all=1)

def find_entries(repo=None, all=None):
    """Return dictionary of traffic_table entries qualified by repo regexp.

    all == 1 means return all entries, regardless of repo arg.

    Iff no entries match, we return the catchall entry - the one with path ==
    None."""
    entries = []
    catchall = None
    for t in traffic_table.get_table():
        if t['path'] == None:
            catchall = t
            is_match = 0
        elif all:
            is_match = 1
        elif got_re:
            is_match = re.match(t['path'], repo)
        else:
            is_match = (regex.match(t['path'], repo) != -1)
        if is_match:
            entries.append(t)

    if entries:
        if VERBOSE > 1:
            complain("Resolved table entry:\n  %s\n", entries)
    elif catchall:
        entries.append(catchall)
        if VERBOSE > 1:
            complain("No matches, so using catchall:\n  %s\n", entries)
    elif VERBOSE > 1:
        complain("No matches, no catchall - no actions\n")

    for e in entries:
        if not e.has_key('excludes'): e['excludes'] = []
        if not e.has_key('remote'):
            if hasattr(traffic_table, 'remote'):
                e['remote'] = traffic_table.remote
            else: e['remote'] = None
        if e.has_key('addrs'):
            if type(e['addrs']) == type(""):
                # Be lenient - listify string args.
                e['addrs'] = [e['addrs']]

    return entries

def do_mail(remote, repo, addrs, subjs,
            msgfilenm, doing_directory=0, no_files=0):
    """Send notice about checkin to addresses dictated by traffic table.

    We include a diff."""
    if VERBOSE:
        complain("Notice to %s for %s / %s\n", addrs, repo, subjs)
    # The message contents are on stdin, just _yearning_ to be sent...-)
    subject = "CVS: %s " % repo

    diff_msg = ''

    if remote is not None and remote.has_key('leading_path'):
        l = remote['leading_path']
        if (len(l) > 1) and (l[-1] != '/'): l = l + '/'
        if (len(l) > 1) and (l[0] == '/'): l = l[1:]
        subject = subject + "(" + l + os.path.split(repo)[-1] + ")"

    if doing_directory or no_files:
        subject = subject + string.join(subjs, " ")
        if subjs[2] == 'New':
            new_msg = ('=== Added directory %s ===\n' % repo)
            diff_msg = diff_msg + new_msg + '\n'
    else:
        subject = subject + "-"
        for fn, old, new in subjs:
            subject = subject + " %s:%s" % (fn, new)
            if new == 'NONE':
                new_msg = ('=== Removed file %s/%s ===\n'
                           % (repo, fn))
            else:
                new_msg = "\n" + create_diff(repo, fn, old, new)

            diff_msg = diff_msg + new_msg + '\n'

    mailcmd = MAIL_CMD
    user = getuser()
    if user:
        try: fullname = pwd.getpwnam(user)[4]
        except KeyError: fullname = ''
        if fullname:
            mailcmd = "%s %s" % (MAIL_CMD, MAIL_CMD_FULLNAME_SLOT % fullname)
    else:
        user = "<unknown>"

    cmd = ("%s%s%s %s %s" % ((VERBOSE and "set -x; ") or "",
                                     (DRYRUN and "echo Would do: ") or "",
                                     mailcmd,
                                     (VERBOSE and "-v") or "",
                                     string.join(addrs, ",")))

    # Prepend the subject line and and append the diff:
    mf = open(msgfilenm, 'r')
    oldcontents = mf.read()
    mf.close()
    mf = open(msgfilenm, 'w')
    mf.write("Subject: %s\nTo: %s\n\n%s %s"
             % (subject, string.join(addrs, ","), oldcontents, diff_msg))
    mf.close()
    cmd = cmd + "< %s" % msgfilenm

    if VERBOSE:
        complain("%sDoing mail cmd for user %s:\n\t%s\n",
                 ((DRYRUN and "NOT ") or ""), user, cmd)
    result = os.system(cmd)
    if result:
        note_failure("*** Mail failed with error %s...", result)

def create_diff(repo, file, old, new):
    """ Create a diff comparing old and new versions """
    if old == 'NONE':   # A new file was added
        try:
            # "Checkout" to stdout, so we can collect the lines to return.
            co_stdout_cmd = 'cvs -fn co -p %s/%s' % (repo, file)
            handle = os.popen(co_stdout_cmd)
            lines = handle.readlines()
            handle.close()
            insert_str = ("=== Added File %s/%s ===\n"
                          % (repo, file))
            lines.insert(0, insert_str)
        except IOError, e:
            lines = ['***** ERROR reading new file: ',
                     str(e), '\n***** file: ', file,
                     ' cwd: ', safe_getcwd('/tmp')]

    else:                # A "normal" update happened
        diff_cmd = ('cvs -d %s -f rdiff -kk -u -t %s/%s'
                    % (CVSROOT, repo, file))
        file_handle = os.popen(diff_cmd)
        lines = file_handle.readlines()[6:]
        file_handle.close()
        insert_str = ("=== %s/%s %s => %s ===\n"
                      % (str(repo), str(file), old, new))
        lines.insert(0, insert_str) 

    return string.join(lines, '')

### XXX 'path' is selector_path, not very useful.  I think we should be using
###     'repo'. 
def do_sync(path, repo, remote, receiverid, subjs=None,
            excludes=None, recurse=0, doing_directory=0, no_files=0):
    """Syncronize repository to mirror.

    The repository directory containing the subjects is synced.  (In fact,
    the actual setting of subjs doesn't matter.)  If recurse is set, then
    the recursion extends to full depth below the repo dir (and the
    activity is conducted in the foreground)."""

    RSYNC_EXE = get_command("rsync", RSYNC_EXE_PATH)
    if not RSYNC_EXE:
        note_failure("*** Rsync executable not found, skipping it!")
        return
    SSH_EXE = get_command("ssh", SSH_EXE_PATH)
    if not SSH_EXE:
        note_failure("*** Ssh executable not found, skipping rsync!")
        return

    if VERBOSE:
        if doing_directory:
            fnames = "<.>"
        elif no_files:
            fnames = "<>"
        else:
            fnames = string.join(map(lambda x: x[0], subjs), ",")
        complain("Sync for %s to %s; of %s/ %s / %s\n",
                 path, remote, os.environ["CVSROOT"], repo, fnames)

    ssh_fragment = ('--rsh="%s -o UserKnownHostsFile=%s %s -i %s -l %s -x"'
                    % (SSH_EXE, KNOWN_HOSTS_FILE, (VERBOSE and "-v") or "",
                       IDENTITY_FILE, receiverid))
    
    if excludes:
        specific_excludes = ''
        for i in excludes:
            specific_excludes = (specific_excludes
                                 + ' --exclude "%s"' % i)
    else:
        specific_excludes = ''

    cmd = (RSYNC_EXE
           + " %s " % ssh_fragment
           + " --update"                # Preserve newer files
           + " --recursive"
           + ' --exclude "#cvs.*"'      # Do not dup cvs lock files
           + ' --exclude ".#*"'         # Do not dup cvs backup files
           + specific_excludes          # empty if None specified
           + " --links"                 # preserve soft-links
           + " --hard-links"            #    "     hard-links
           + " --perms"                 #    "     permissions
           + " --times"                 #    "     times
           + " --sparse"                # handle sparse files efficiently
           + " --delete"                # keep remote directory in sync
           #+ " --compress"              # (more compression context than ssh)
           )
    if VERBOSE or SYNCREPO:
        cmd = cmd + " --verbose"

    if not recurse:
        cmd = cmd + ' --exclude "/*/*/*"'

    reposubdir = string.join(string.split(repo, '/')[1:], '/')

    try:
        repodir = remote['repodir'] % path
    except TypeError:
        repodir = remote['repodir']

    # Special case for individual file targets:
    if os.path.isfile("%s/%s,v" % (os.environ["CVSROOT"], path)):
        trailing_slash_or_comma_origin = ",v"
        trailing_slash_or_comma_dest = ",v"
    elif doing_directory or recurse:
        # We must have the slash on the origin dir arg, or it'll be nested
        # in target:
        trailing_slash_or_comma_origin = "/"
        # If we don't have slash on target dir arg, it'll be created if
        # it's not already there:
        trailing_slash_or_comma_dest = ""
    else:
        trailing_slash_or_comma_origin = "/"
        trailing_slash_or_comma_dest = "/"

    if remote.has_key('leading_path'):
        l = remote['leading_path']
        if not l or l[-1] != '/': l = l + '/'
        remotesubpath = ("%s%s%s" % (l, os.path.split(path)[-1],
                                       trailing_slash_or_comma_dest))
    else:
        if path and path[0] != '/':
            remotesubpath = '/' + path
        else:
            remotesubpath = path
    remotepath = ("%s:%s%s" % (remote['host'], remote['repodir'],
                               remotesubpath))

    if VERBOSE:                         # DEBUG
        print "Path:", path, "Repodir:", repodir, "Reposubdir:", reposubdir

    cmd = ("%s%s %s/%s%s %s" % ((VERBOSE and "set -x; ") or "",
                                cmd,
                                os.environ["CVSROOT"], path,
                                trailing_slash_or_comma_origin,
                                remotepath))
    if VERBOSE:
        complain("%sDoing rsync cmd:\n\t%s\n",
                 ((DRYRUN and "NOT ") or ""), cmd)
    elif SYNCREPO:
        complain("%sDoing syncrepo rsync of %s\n  to %s\n", 
                 ((DRYRUN and "NOT ") or ""), path, remotepath)

    if DRYRUN:
        print "Would do:\n\t", cmd
        result = 0
    else:
        result = os.system(cmd)
    if result:
        note_failure("*** Rsync returned %s...", result)

def do_chmod(subjs):
    # DEFUNCT.
    fnames = []
    for i in subjs:
        if len(i) == 3 and i[2] != "NONE":
            fnames.append(i[0])
    if not fnames:
        fnames = ["."]
    cmd = ("%s%schmod g+w %s" % ((VERBOSE and "set -x; ") or "",
                                 (DRYRUN and "echo would do: ") or "",
                                 string.join(fnames, " ")))
    if VERBOSE:
        complain("Reexecing in %s, cmd:\n\t%s\n", safe_getcwd('/tmp'), cmd)
    result = os.system(cmd)
    if result:
        msg = "*** Chmod returned %s..."
        if CHMOD_CASUAL:
            complain(msg, result)
        else:
            note_failure(msg, result)

def loosen_file(fname):
    """Relax permissions on (newly created) file so others can use it too."""
    try:
        os.chmod(fname, 0777)
    except os.error, err:
        pass

def grok_file(s):
    """Separate "file,old-version,new-version"."""
    m = sVv_re.match(s)
    if got_re:
        if not m:
            raise ValueError, "'%s' not in file,old-vers,new-vers format" % s
        return m.groups()
    else:
        # regex instead of re.
        if m == -1:
            raise ValueError, "'%s' not in file,old-vers,new-vers format" % s
        return sVv_re.group(1, 2, 3)

failures = 0
def note_failure(msg, *args):
    """Register a failure for handle_failures to announce at the end."""
    global failures
    failures = 1
    apply(complain, (msg,) + args)

def getuser():
    """Try to get the user's login name."""
    try: return getpass.getuser()
    except: return None

def handle_failures(argstring):
    """On serious failures, send the complaints log to CVSMASTER."""

    if os.environ.has_key('HOSTNAME'):
        host = os.environ['HOSTNAME']
    else:
        host = socket.gethostbyaddr(socket.gethostname())[0]
        if not host:
            host = "nohost.digicool.com"

    user = getuser() or "unidentified"

    if os.path.isfile(OUTPUT_LOG):
        log_file_expr = ("\n\tSee log file for application errors:\n\t\t%s"
                         % OUTPUT_LOG)
    else:
        log_file_expr = ""

    complain("Sending complaints log to CVSMASTER %s\n", CVSMASTER)
    complain("Time stamp: %s\n", time.ctime(time.time()))
    complain("Fatal failures in %s:%s"
             "\n\tCheckin by: %s@%s\n\tInvocation: %s\n\n",
             SCRIPT, log_file_expr, user, host, argstring)

    cmd = ('%s %s -s "CVS errors in %s for %s" %s'
           % (MAIL_CMD, ((VERBOSE and "-v") or ""), SCRIPT, user, CVSMASTER))
    f = os.popen(cmd, 'w')
    f.write("Serious errors encountered during CVS postcommit actions,\n")
    f.write("the log is below with orienting details at the bottom.\n\n")
    f.write(string.join(complaints, ""))
    return f.close()

def usage():
    complain("Usage: %s [options] ", SCRIPT)
    complain('"repopath file,oldv,newv [f2,o2,n2 ...]"\n')
    complain("(Note that repo-path and files must be"
             " quoted so they are a single token.)\n")

def get_command(cmd, path):
    """Get a valid exe for cmd on path."""
    for d in path:
        maybe = os.path.join(d, cmd)
        if os.path.isfile(maybe):
            return maybe
    note_failure("No usable %s executable found.\n", `cmd`)
    

complaints = []
def complain(msg, *args):
    global complaints

    import time
    t = time.strftime("%Y-%m-%d %T - ", time.localtime(time.time()))

    complaints.append(t + (msg % args))
    sys.stderr.write(msg % args)
    sys.stderr.flush()

def safe_getcwd(fallback):
    try:
        return os.getcwd()
    except:
        os.chdir(fallback)
        try:
            return os.getcwd()
        except:
            return "<unknown dir>"

if __name__ == "__main__":
    main(sys.argv)
