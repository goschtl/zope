#!/usr/bin/env python

"""Apply actions dictated by traffic_table.py to checkins as they occur.

An optional leading arg "--verbose" argument says operate verbosely.

We expect to be invoked from loginfo with "%{CVSROOT} %{sVv}".  The %{sVv}
format string is expanded into a single argument passed in, containing
multiple space-delimited parts.  The first part is the path of repository
directory, then a comma-concatenated string for each file being checked in,
consisting of the file name, the old version number, then the new one, like
so: file-name,old-version,new-version.  (See the CVS Gnu INFO file for the
node 'loginfo' for more format-string details.)

Currently the actions are emailing checkin messages and doing an rsync 
to the public repository."""

MAIL_CMD = "/bin/mail"
RSYNC_CMD = "/usr/bin/rsync"

# XXX IDENTITY_FILE must be readable by the process of anyone doing a
#     checkin that uses the rsync mechanism.  Ideally, that would be by
#     virtue of a particular group membership - world readable opens up the 
#     rsync privilege to everyone on the system.
IDENTITY_ACCT = "dccvs"
IDENTITY_FILE = "/home/dccvs/cvsidentity"


RSYNC_IN_BACKGROUND = 1                 # Don't wait...
RECURSE = 0                             # '--recurse' option
DRYRUN = 0                              # '--dryrun' option
VERBOSE = 0                             # '--verbose' option
SCRIPT = "postcommit_actions"           # Changes to args[0], when obtained.

import sys, os
import re, string
import getopt

sVv_re = re.compile("(.*),([^,]+),([^,]+)")

def main(args):
    """Grok the args and the traffic_table and process accordingly."""

    global SCRIPT, DRYRUN, VERBOSE, RECURSE, RSYNC_IN_BACKGROUND

    orig_args = args[:]

    SCRIPT = args[0]
    opts, args = getopt.getopt(args[1:], "",
                               ["verbose", "dryrun", "recurse", "bg", "nobg"])
    if len(args) != 1:
        usage(); raise SystemExit, 1
    for opt, val in opts:
        if opt == "--verbose":
            VERBOSE = 1
            complain("%s: VERBOSE mode...\n", SCRIPT)
        elif opt == "--dryrun":
            DRYRUN = 1
            complain("%s: DRYRUN mode...\n", SCRIPT)
        elif opt == "--recurse":
            RECURSE = 1
            complain("%s: FULL-DEPTH RECURSE mode...\n", SCRIPT)
        elif opt == "--bg":
            RSYNC_IN_BACKGROUND = 1
            complain("%s: Backgrounding rsync mode...\n", SCRIPT)
        elif opt == "--nobg":
            RSYNC_IN_BACKGROUND = 0
            complain("%s: NOT backgrounding-rsync mode...\n", SCRIPT)
        else:
            complain("Unrecognize option '%s'\n", opt)
            raise SystemExit, 1
    if VERBOSE:
        complain("Initial args: %s '%s'\n",
                 string.join(orig_args[:-1], " "),
                 orig_args[-1])
    # The %{sVv} args are passed in as a single token - have to split them.
    split_args = string.split(args[0])

    repo = split_args[0]
    subjs = map(grok_file, split_args[1:])

    if VERBOSE:
        complain("CWD: %s, Repo: %s, ", os.getcwd(), repo)
        complain("Subjects: %s\n", subjs)

    got = find_entries(repo)
    for entry in got:
        (nm, expr, addrs, remote) = entry
        if addrs:
            do_mail(nm, repo, addrs, subjs)
        if remote:
            do_sync(nm, repo, remote, subjs, recurse=RECURSE)

    do_chmod(subjs)

def find_entries(repo):
    """Return all traffic_table entries that trigger for repo."""
    import traffic_table
    got = []
    for t in traffic_table.table:
        if re.search(t[1], repo):
            got.append(t)
    return got

def do_mail(name, repo, addrs, subjs):
    """Send notice about checkin to addresses dictated by traffic table."""
    fnames = string.join(map(lambda x: x[0], subjs), ",")
    if VERBOSE:
        complain("Notice to %s for %s / %s\n", addrs, repo, fnames)
    # The message contents are on stdin, just _yearning_ to be sent...-)
    subject = "CVS checkin: %s %s" % (repo, fnames)
    os.system("%s%s%s %s -s '%s' %s" % ((VERBOSE and "set -x; ") or "",
                                        (DRYRUN and "echo ") or "",
                                        MAIL_CMD,
                                        (VERBOSE and "-v") or "",
                                        subject,
                                        string.join(addrs, ",")))

def do_sync(name, repo, remote, subjs=None, recurse=0):
    """Instigate repository mirror synchronize.

    The repository directory containing the subjects is synced.  (In fact,
    the actual setting of subjs doesn't matter.)  If recurse is set, then
    the recursion extends to full depth below the repo dir (and the
    activity is conducted in the foreground)."""

    if VERBOSE:
        fnames = string.join(map(lambda x: x[0], subjs), ",")
        complain("Sync for %s to %s; of %s/ %s / %s\n",
                 name, remote, os.environ["CVSROOT"], repo, fnames)
    try:
        repodir = remote['repodir'] % name
    except TypeError:
        repodir = remote['repodir']

    ssh_fragment = ('--rsh="/usr/bin/ssh %s -i %s -l %s"'
                    % ((VERBOSE and "-v") or "", IDENTITY_FILE, IDENTITY_ACCT))
    cmd = (RSYNC_CMD
           + " %s " % ssh_fragment
           + " --update"                # Preserve newer files
           + " --recursive"
           + ' --exclude "#cvs.*"'      # Do not dup cvs lock files
           + " --links"                 # preserve soft-links
           + " --hard-links"            #    "     hard-links
           + " --perms"                 #    "     permissions
           + " --times"                 #    "     times
           + " --sparse"                # handle sparse files efficiently
           + " --delete"                # keep remote directory in sync
           + " --compress"              # (more compression context than ssh)
           )
    if VERBOSE:
        cmd = cmd + " --verbose"

    if recurse:
        bg = 0
    else:
        cmd = cmd + ' --exclude "/*/*"'
        bg = RSYNC_IN_BACKGROUND

    os.system("%s%s%s %s/%s/ %s:%s %s"
              % ((VERBOSE and "set -x; ") or "",
                 (DRYRUN and "echo ") or "",
                 cmd,
                 os.environ["CVSROOT"], repo,
                 remote['host'], repodir,
                 (bg and " &") or ""))

def do_chmod(subjs):
    fnames = map(lambda x: x[0], subjs)
    if not fnames:
        fnames = ["."]
    os.system("%s%schmod g+w %s" % ((VERBOSE and "set -x; ") or "",
                                    (DRYRUN and "echo ") or "",
                                    string.join(fnames, " ")))

def grok_file(s):
    """Separate "file,old-version,new-version"."""
    m = sVv_re.match(s)
    if not m:
        raise ValueError, "'%s' not in file,old-vers,new-vers format" % s
    return m.groups()

def usage():
    complain("Usage: %s repository-path file,oldv,newv [f2,o2,n2 ...]\n",
             SCRIPT)

def complain(msg, *args):
    sys.stderr.write(msg % args)

if __name__ == "__main__":
    main(sys.argv)

