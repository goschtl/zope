#!/usr/bin/env python

"""Apply actions dictated by traffic_table.py to checkins as they occur.

Normal operation is to fork into the background with stderr and stdout
redirected to append to the file named by the OUTPUT_LOG config var (or be
the forked version, which is reinvoked with the --wait option).

Options:

 --verbose - operate in verbose mode, with output to stdout.
 --recurse - remote repository sync recurses into all subject dirs offspring
 --dryrun - do not actually do any of the activities
 --wait - do not fork into the background (and leave output in stdout/stderr)

An optional leading arg --verbose argument says operate verbosely.

We expect to be invoked from loginfo with %{CVSROOT} %{sVv}: The %{sVv}
format string is expanded into a single argument passed in, containing
multiple space-delimited parts:

  - The first part is the path of repository directory

  - Then a comma-concatenated string for each file being checked in,
    consisting of:

    - The file name,
    - The old version number, then
    - the new one, like so

    filename,1.1,1.2

(See the CVS Gnu INFO file for loginfo for more format-string details.)

Currently the actions are:

##  - doing a g+w chmod of the subject files
##  - emailing checkin messages to designated recipients
##  - doing an rsync of the repository to the public repository host.

... as dictated in the traffic_table.py module."""

OUTPUT_LOG = "/var/tmp/cvs-postcommit_actions.log"

MAIL_CMD = "/bin/mail"
RSYNC_CMD = "/usr/bin/rsync"

# XXX IDENTITY_FILE must be readable by the process of anyone doing a
#     checkin that uses the rsync mechanism.  Ideally, that would be by
#     virtue of a particular group membership - world readable opens up the 
#     rsync privilege to everyone on the system.
IDENTITY_ACCT = "dccvs"
IDENTITY_FILE = "/home/dccvs/cvsidentity"


WAIT = 0                                # Fork unless waiting is requested.
RECURSE = 0                             # '--recurse' option
DRYRUN = 0                              # '--dryrun' option
VERBOSE = 0                             # '--verbose' option
SCRIPT = "postcommit_actions"           # Changes to args[0], when obtained.

import sys, os
import re, string
import getopt

sVv_re = re.compile("(.*),([^,]+),([^,]+)")

def main(args):
    """Grok the args and the traffic_table and process accordingly."""

    global SCRIPT, DRYRUN, VERBOSE, RECURSE, WAIT

    orig_args = args[:]

    SCRIPT = args[0]
    opts, args = getopt.getopt(args[1:], "",
                               ["verbose", "dryrun", "recurse", "wait"])
    if len(args) != 1:
        usage(); raise SystemExit, 1
    for opt, val in opts:
        if opt == "--verbose":
            VERBOSE = 1
            complain("%s: VERBOSE mode...\n", SCRIPT)
        elif opt == "--dryrun":
            DRYRUN = 1
            complain("%s: DRYRUN mode...\n", SCRIPT)
        elif opt == "--recurse":
            RECURSE = 1
            complain("%s: FULL-DEPTH RECURSE mode...\n", SCRIPT)
        elif opt == "--wait":
            WAIT = 1
            complain("%s: Not doing activities in background...\n", SCRIPT)
        else:
            complain("Unrecognize option '%s'\n", opt)
            raise SystemExit, 1
    if VERBOSE:
        complain("Initial args: %s '%s'\n",
                 string.join(orig_args[:-1], " "),
                 orig_args[-1])
    # The %{sVv} args are passed in as a single token - have to split them.
    split_args = string.split(args[0])

    repo = split_args[0]
    subjs = map(grok_file, split_args[1:])

    if VERBOSE:
        complain("CWD: %s, Repo: %s, ", os.getcwd(), repo)
        complain("Subjects: %s\n", subjs)

    got = find_entries(repo)

    if not WAIT:
        detach(orig_args)

    do_chmod(subjs)

    for entry in got:
        (nm, expr, addrs, remote) = entry
        if addrs:
            do_mail(nm, repo, addrs, subjs)
        if remote:
            do_sync(nm, repo, remote, subjs, recurse=RECURSE)

    if VERBOSE:
        complain("Th th th th that's all folks.")

def detach(args):
    """Fork us into the background, with stdout and stderr to OUTPUT_LOG."""
    doctored_args = [args[0]]
    doctored_args.append("--wait")
    for i in args[1:]:
        doctored_args.append('"%s"' % i)
    cmd = (("( exec 1> %s 2>&1; " + string.join(doctored_args, " ") +  " &)")
           % OUTPUT_LOG)
    print "Am doing:", cmd        # DEBUG
    os.system(cmd)
    os._exit(0)
    
logf = None
def old_detach():
    """Fork us into the background, with stdout and stderr to OUTPUT_LOG."""

    global logf

    if VERBOSE:
        complain("Redirecting stdout and stderr to %s\n", OUTPUT_LOG)
    try:
        logf = open(OUTPUT_LOG, 'a')
    except IOError:
        complain("** Failed to open %s for append!!\n", OUTPUT_LOG)
        complain("** Sticking with regular stdout and stderr!\n")
        logf = None

    sys.stdout = logf
    sys.stderr = logf
## This may not be necessary - keeping for now, in case it turns out to be.
##     if hasattr(sys, "__stdout__"):
##         sys.__stdout__ = logf
##     if hasattr(sys, "__stderr__"):
##         sys.__stderr__ = logf

    if VERBOSE:
        complain("Forking to background...\n")
    if os.fork():
        # In parent - all done with that.
        os._exit(0)
    

def find_entries(repo):
    """Return all traffic_table entries that trigger for repo."""
    import traffic_table
    got = []
    for t in traffic_table.table:
        if re.search(t[1], repo):
            got.append(t)
    return got

def do_mail(name, repo, addrs, subjs):
    """Send notice about checkin to addresses dictated by traffic table."""
    if VERBOSE:
        complain("Notice to %s for %s / %s\n", addrs, repo, subjs)
    # The message contents are on stdin, just _yearning_ to be sent...-)
    subject = "CVS checkin: %s -" % name
    for fn, old, new in subjs:
        subject = subject + " %s:%s" % (fn, new)
    os.system("%s%s%s %s -s '%s' %s" % ((VERBOSE and "set -x; ") or "",
                                              (DRYRUN and "echo ") or "",
                                              MAIL_CMD,
                                              (VERBOSE and "-v") or "",
                                              subject,
                                              string.join(addrs, ",")))

def do_sync(name, repo, remote, subjs=None, recurse=0):
    """Instigate repository mirror synchronize.

    The repository directory containing the subjects is synced.  (In fact,
    the actual setting of subjs doesn't matter.)  If recurse is set, then
    the recursion extends to full depth below the repo dir (and the
    activity is conducted in the foreground)."""

    if VERBOSE:
        fnames = string.join(map(lambda x: x[0], subjs), ",")
        complain("Sync for %s to %s; of %s/ %s / %s\n",
                 name, remote, os.environ["CVSROOT"], repo, fnames)

    ssh_fragment = ('--rsh="/usr/bin/ssh %s -i %s -l %s"'
                    % ((VERBOSE and "-v") or "", IDENTITY_FILE, IDENTITY_ACCT))
    cmd = (RSYNC_CMD
           + " %s " % ssh_fragment
           + " --update"                # Preserve newer files
           + " --recursive"
           + ' --exclude "#cvs.*"'      # Do not dup cvs lock files
           + " --links"                 # preserve soft-links
           + " --hard-links"            #    "     hard-links
           + " --perms"                 #    "     permissions
           + " --times"                 #    "     times
           + " --sparse"                # handle sparse files efficiently
           + " --delete"                # keep remote directory in sync
           #+ " --compress"              # (more compression context than ssh)
           )
    if VERBOSE:
        cmd = cmd + " --verbose"

    if not recurse:
        cmd = cmd + ' --exclude "/*/*"'

    os.system("%s%s%s %s/%s/ %s:%s"
                    % ((VERBOSE and "set -x; ") or "",
                       (DRYRUN and "echo ") or "",
                       cmd,
                       os.environ["CVSROOT"], repo,
                       remote['host'], remote['repodir']))

def do_chmod(subjs):
    fnames = map(lambda x: x[0], subjs)
    if not fnames:
        fnames = ["."]
    os.system("%s%schmod g+w %s" % ((VERBOSE and "set -x; ") or "",
                                          (DRYRUN and "echo ") or "",
                                          string.join(fnames, " ")))

def directed_system(cmd):
    "Like os.system, but we wrap cmd for output redirection as appropriate."
    if logf:
        # Put parens around the command body, and redirect into the logf.
        cmd = ("( exec 1> %s 2>&1; " + cmd +  ")") % logf.name

    os.system(cmd)

def grok_file(s):
    """Separate "file,old-version,new-version"."""
    m = sVv_re.match(s)
    if not m:
        raise ValueError, "'%s' not in file,old-vers,new-vers format" % s
    return m.groups()

def usage():
    complain("Usage: %s repository-path file,oldv,newv [f2,o2,n2 ...]\n",
             SCRIPT)

def complain(msg, *args):
    sys.stderr.write(msg % args)
    sys.stderr.flush()

if __name__ == "__main__":
    main(sys.argv)

