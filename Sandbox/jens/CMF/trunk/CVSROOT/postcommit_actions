#!/usr/bin/env python

"""Apply actions dictated by traffic_table.py to checkins as they occur.

An optional leading arg "--verbose" argument says operate verbosely.

We expect to be invoked from loginfo with "%{CVSROOT} %{sVv}".  The %{sVv}
format string is expanded into a single argument passed in, containing
multiple space-delimited parts.  The first part is the path of repository
directory, then a comma-concatenated string for each file being checked in,
consisting of the file name, the old version number, then the new one, like
so: file-name,old-version,new-version.  (See the CVS Gnu INFO file for the
node 'loginfo' for more format-string details.)

Currently the actions are emailing checkin messages and doing an rsync 
to the public repository."""

MAIL_CMD = "/bin/mail"
RSYNC_CMD = "/usr/bin/rsync"

# XXX IDENTITY_FILE must be readable by the process of anyone doing a
#     checkin that uses the rsync mechanism.  Ideally, that would be by
#     virtue of a particular group membership - world readable opens up the 
#     rsync privilege to everyone on the system.
IDENTITY_ACCT = "dccvs"
IDENTITY_FILE = "/home/dccvs/cvsidentity"


VERBOSE = 1
SCRIPT = "postcommit_actions"           # Changes to args[0], when obtained.

import sys, os
import re, string

sVv_re = re.compile("(.*),([^,]+),([^,]+)")

def main(args):
    """Grok the args and the traffic_table and process accordingly."""

    global VERBOSE, SCRIPT

    if VERBOSE:
        complain("Initial args: %s\n", args)

    if (len(args) < 2
        or (args[1] == "--verbose" and (len(args) != 3))):
        usage(); raise SystemExit, 1

    # Identify all the args - see usage() for expected layout.
    SCRIPT = args[0]; del args[0]
    if args[0] == "--verbose":
        VERBOSE = 1
        del args[0]

    # The %{sVv} args are passed in as a single token - have to split them.
    args = string.split(args[0])

    repo = args[0]; del args[0]
    subjs = map(grok_file, args)

    if VERBOSE:
        complain("CWD: %s, Repo: %s, ", os.getcwd(), repo)
        complain("Subjects: %s\n", subjs)

    got = find_entries(repo)
    for entry in got:
        (nm, expr, addrs, remote) = entry
        if addrs:
            print "Addrs:", addrs
            do_mail(nm, repo, addrs, subjs)
        if remote:
            do_sync(repo, remote, subjs)

    do_chmod(subjs)

def find_entries(repo):
    """Return all traffic_table entries that trigger for repo."""
    import traffic_table
    got = []
    for t in traffic_table.table:
        if re.search(t[1], repo):
            got.append(t)
    return got

def do_mail(name, repo, addrs, subjs):
    """Send notice about checkin to addresses dictated by traffic table."""
    fnames = string.join(map(lambda x: x[0], subjs), ",")
    if VERBOSE:
        complain("Notice to %s for %s / %s\n", addrs, repo, fnames)
    # The message contents are on stdin, just _yearning_ to be sent...-)
    subject = "CVS: %s %s" % (repo, fnames)
    os.system("%s %s -s '%s' %s" % (MAIL_CMD,
                                    (VERBOSE and "-v") or "",
                                    subject,
                                    string.join(addrs, ",")))

def do_sync(repo, remote, subjs=None):
    """Instigate repository mirror synchronize."""
    if VERBOSE:
        fnames = string.join(map(lambda x: x[0], subjs), ",")
        complain("Sync for %s of %s/ %s / %s\n",
                 remote, os.environ["CVSROOT"], repo, fnames)
    ssh_fragment = ('--rsh="/usr/bin/ssh -v -i %s -l %s"'
                    % (IDENTITY_FILE, IDENTITY_ACCT))
    cmd = (RSYNC_CMD
           + " %s " % ssh_fragment
           + " --update"                # Preserve newer files
           + " --recursive"
           + ' --exclude "#cvs.*"'      # Do not dup cvs lock files
           + " --links"                 # preserve soft-links
           + " --hard-links"            #    "     hard-links
           + " --perms"                 #    "     permissions
           + " --times"                 #    "     times
           + " --sparse"                # handle sparse files efficiently
           + " --delete"                # keep remote directory in sync
           + " --compress"              # (more compression context than ssh)
           )
    if subjs != None:
        cmd = basecmd + ' --exclude "/*/*"'

    entire =("echo %s %s %s:%s"
             % (cmd, repo, remote['host'], remote['repodir']))
    print "The whole shebang:", entire

def do_chmod(subjs):
    fnames = map(lambda x: x[0], subjs)
    if VERBOSE:
        complain("Doing chmod on files: %s\n", fnames)
    os.system("echo chmod g+w %s" % string.join(fnames, " "))

def grok_file(s):
    """Separate "file,old-version,new-version"."""
    m = sVv_re.match(s)
    if not m:
        raise ValueError, "'%s' not in file,old-vers,new-vers format" % s
    return m.groups()

def usage():
    complain("Usage: %s repository-path file,oldv,newv [f2,o2,n2 ...]\n",
             SCRIPT)

def complain(msg, *args):
    sys.stderr.write(msg % args)

if __name__ == "__main__":
    main(sys.argv)

