=========
Mars View
=========

z3c packages bring significant clarity and a pattern for forms, view and
templates.

This package uses martian to configure views. The views here defined are
TemplateView and LayoutView, both use adapter lookup to locate the template to
be used (but can class attributes `template` for TemplateView and LayoutView and `layout` for
LayoutView will be used before adapter lookup).

Setting Up
----------

First the usual imports.

  >>> import zope.interface
  >>> import zope.component
  >>> import grok
  >>> import mars.view
  >>> import mars.layer
  >>> import mars.template

  >>> import os, tempfile
  >>> temp_dir = tempfile.mkdtemp()

Let's create a content object that will act as the context to the views.

  >>> class Content(object):
  ...     zope.interface.implements(zope.interface.Interface)
  >>> content = Content()

We also need a fake module info object to pass to the ``grokkers``.

  >>> from martian.interfaces import IModuleInfo
  >>> class ModuleInfo(object):
  ...     zope.interface.implements(IModuleInfo)
  ...     path = ''
  ...     package_dotted_name = ''
  ...     def getAnnotation(self, name, default):
  ...         return default

And a request object for ``viewing`` the views.

  >>> from zope.publisher.browser import TestRequest
  >>> request = TestRequest()

Templates
---------

We need a couple of template files to use for the templates themselves.

  >>> viewTemplate = os.path.join(temp_dir, 'viewTemplate.pt')
  >>> open(viewTemplate, 'w').write('''<div>My view template</div>''')

  >>> layoutTemplate = os.path.join(temp_dir, 'layoutTemplate.pt')
  >>> open(layoutTemplate, 'w').write('''<div>My layout template</div>''')

Template View
-------------

TemplateView provides only a `render` method which returns the rendered
template. This is a good match for the ``template`` directive of z3c.template
and is used most often with mars.template.TemplateFactory as in the following
example.

  >>> class View(mars.view.TemplateView):
  ...     """This is the view class"""
  ...     grok.context(zope.interface.Interface)

  >>> class ViewTemplate(mars.template.TemplateFactory):
  ...     """This is a template"""
  ...     grok.template(viewTemplate)
  ...     grok.context(View)

We need to manually ``grok`` these classes in the doctest. Usually this happens
at start up.

  >>> from mars.view.meta import TemplateViewGrokker
  >>> TemplateViewGrokker().grok('', View, None, ModuleInfo(), None)
  True

  >>> from mars.template.meta import TemplateFactoryGrokker
  >>> TemplateFactoryGrokker().grok('', ViewTemplate, None, ModuleInfo(), None)
  True

We can now look up the view and expect the template to be rendered. We can look
up the view for ``content`` object because the view is registered for Interface
using ``grok.context`` directive. We can lookup using the name ``view`` because
the default name that a view is registered is ``factory.__name__.lower()``.

  >>> view = zope.component.getMultiAdapter((content, request),
  ...                                       name='view')
  >>> print view.render()
  <div>My view template</div>


Layout View
-----------

LayoutView has a `__call__` method that returns the rendered layout template.
This is a good match for the ``layout`` directive of z3c.template and is used
most often with mars.template.LayoutFactory as in the following example.

  >>> class LayoutView(mars.view.LayoutView):
  ...     """This is the view class"""
  ...     grok.context(zope.interface.Interface)

  >>> class LayoutViewTemplate(mars.template.LayoutFactory):
  ...     """This is a template"""
  ...     grok.template(layoutTemplate)
  ...     grok.context(LayoutView)

As before we need to manually ``grok`` the classes.

  >>> from mars.view.meta import LayoutViewGrokker
  >>> LayoutViewGrokker().grok('', LayoutView, None, ModuleInfo(), None)
  True

  >>> from mars.template.meta import LayoutFactoryGrokker
  >>> LayoutFactoryGrokker().grok('', LayoutViewTemplate, None, ModuleInfo(), None)
  True

We can now look up the view and expect the template to be rendered.

  >>> view = zope.component.getMultiAdapter((content, request),
  ...                                       name='layoutview')
  >>> print view()
  <div>My layout template</div>

The code here is almost identical to above, the only difference being that a
layout view is ``called`` and the template view is ``rendered``. In mars.viewlet
viewlets are rendered in the same way as the template view and both are not
available via an url. The layout view however is callable and will be accessible
via a url.


Pagelet View
------------

PageletView provides both a ``render`` method and a ``__call__`` method in the
manner of z3c.pagelet. In effect it combines both of the above views and
duplicates z3c.pagelet.browser.BrowserPagelet.

Here again the code follows the same pattern as the above examples but we will
create a full layout template for the view.

  >>> pageletTemplate = os.path.join(temp_dir, 'pageletTemplate.pt')
  >>> open(pageletTemplate, 'w').write(""" \
  ... <div>My pagelet template</div> \
  ... <div tal:replace="structure view/render">Here insert view template</div>""")

In this template we make a call to the ``render`` method of the view which will
look up the registered template.

  >>> class PageletView(mars.view.PageletView):
  ...     """This is the view class"""
  ...     grok.context(zope.interface.Interface)

  >>> class PageletViewLayout(mars.template.LayoutFactory):
  ...     """This the layout template looked up by the __call__ method of view"""
  ...     grok.template(pageletTemplate)
  ...     grok.context(PageletView)

  >>> class PageletViewTemplate(mars.template.TemplateFactory):
  ...     """This the view template looked up by render method"""
  ...     grok.template(viewTemplate)
  ...     grok.context(PageletView)

As before we need to manually ``grok`` the classes.

  >>> from mars.view.meta import PageletViewGrokker
  >>> PageletViewGrokker().grok('', PageletView, None, ModuleInfo(), None)
  True

  >>> LayoutFactoryGrokker().grok('', PageletViewLayout, None, ModuleInfo(), None)
  True

  >>> TemplateFactoryGrokker().grok('', PageletViewTemplate, None, ModuleInfo(), None)
  True

We can now look up the view and expect the templates to be rendered.

  >>> view = zope.component.getMultiAdapter((content, request),
  ...                                       name='pageletview')

The view has a render method which renders the template

  >>> print view.render()
  <div>My view template</div>

And a __call__ method which renders the layout including the second template
with its render method.

  >>> print view()
  <div>My pagelet template</div> <div>My view template</div>

Named Templates
---------------

Layout templates can be registered as ``named`` templates with the ``grok.name``
directive (here we register to all browser views as an example):

  >>> namedTemplate = os.path.join(temp_dir, 'namedTemplate.pt')
  >>> open(namedTemplate, 'w').write('''<div>My named template</div>''')

  >>> from zope.publisher.interfaces.browser import IBrowserView
  >>> class NamedLayout(mars.template.LayoutFactory):
  ...     grok.template(namedTemplate)
  ...     grok.context(IBrowserView)
  ...     grok.name('named')

By using the directive ``mars.view.layout`` we tell a view to look up a named
template. Here we also define the name by which the view is looked up.

  >>> class NamedLayoutView(mars.view.LayoutView):
  ...     grok.context(zope.interface.Interface)
  ...     grok.name('named.html')
  ...     mars.view.layout('named')

First we'll only grok the view to demonstrate.

  >>> LayoutViewGrokker().grok('', NamedLayoutView, None, ModuleInfo(), None)
  True

  >>> view = zope.component.getMultiAdapter((content, request),
  ...                                       name='named.html')
  >>> view()
  Traceback (most recent call last):
  ...
  ComponentLookupError: ... z3c.template.interfaces.ILayoutTemplate>, 'named')

So we see that the view is indeed looking up a named template. Lets grok the
template now and call the view again.

  >>> LayoutFactoryGrokker().grok('', NamedLayout, None, ModuleInfo(), None)
  True
  >>> print view()
  <div>My named template</div>

