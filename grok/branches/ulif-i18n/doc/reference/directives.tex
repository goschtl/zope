\chapter{Directives}

The \module{grok} module defines a set of directives that allow you to
configure and register your components. Most directives assume a
default, based on the environment of a module. (For example, a view
will be automatically associated with a model if the association can
be made unambigously.)

If no default can be assumed for a value, grok will explicitly tell
you what is missing and how you can provide a default or explicit
assignment for the value in question.


    \section{\function{grok.AutoFields} -- deduce schema fields automatically}

        \begin{funcdesc}{grok.AutoFields}{class_or_interface}
          A class level directive, which can be used inside
          \class{Form} classes to automatically deduce the form fields
          from the schema of the context \var{class_or_interface}.

          Different to most other directives,
          \function{grok.AutoFields} is used more like a function and
          less like a pure declaration.

          The following example makes use of the
          \function{grok.AutoFields} directive, in that one field is
          omitted from the form before rendering:

          \strong{Example:}

          \begin{verbatim}
import grok
from zope import interface, schema

class IMammoth(interface.Interface):
    name = schema.TextLine(title=u"Name")
    size = schema.TextLine(title=u"Size", default=u"Quite normal")

class Mammoth(grok.Model):
    interface.implements(IMammoth)

class Edit(grok.EditForm):
    grok.context(Mammoth)

    form_fields = grok.AutoFields(Mammoth).omit('size')
          \end{verbatim}

          In this example the \code{size} attribute will not show up
          in the resulting edit view.

          \begin{seealso}
            \class{grok.EditForm}, \class{grok.Fields}
          \end{seealso}

        \end{funcdesc}

    \section{\function{grok.adapts} -- declare that a class adapts
      certain objects}

        \begin{funcdesc}{grok.adapts}{*classes_or_interfaces}
          A class-level directive to declare that a class adapts
          objects of the classes or interfaces given in
          \var{*classes_or_interfaces}.

          This directive accepts several arguments.

          It works much like the \module{zope.component}s
          \function{adapts()}, but you do not have to make a ZCML
          entry to register the adapter.

          \strong{Example:}

          \begin{verbatim}
import grok
from zope import interface, schema
from zope.size.interfaces import ISized

class IMammoth(interface.Interface):
    name = schema.TextLine(title=u"Name")
    size = schema.TextLine(title=u"Size", default=u"Quite normal")

class Mammoth(grok.Model):
    interface.implements(IMammoth)

class MammothSize(object):
    grok.implements(ISized)
    grok.adapts(IMammoth)

    def __init__(self, context):
        self.context = context

    def sizeForSorting(self):
        return ('byte', 1000)

    def sizeForDisplay(self):
        return ('1000 bytes')
          \end{verbatim}

          Having \class{MammothSize} available, you can register it as
          an adapter, without a single line of ZCML:

          \begin{verbatim}
>>> manfred = Mammoth()
>>> from zope.component import provideAdapter
>>> provideAdapter(MammothSize)
>>> from zope.size.interfaces import ISized
>>> size = ISized(manfred)
>>> size.sizeForDisplay()
'1000 bytes'
          \end{verbatim}

          \begin{seealso}
            \class{grok.implements}
          \end{seealso}

        \end{funcdesc}

    \section{\function{grok.baseclass} -- declare a class as base}

        \begin{funcdesc}{grok.baseclass}{}
          A class-level directive without argument to mark something
          as a base class. Base classes are are not grokked.

          Another way to indicate that something is a base class, is
          by postfixing the classname with \code{'Base'}.

          The baseclass mark is not inherited by subclasses, so those
          subclasses will be grokked (except they are explicitly
          declared as baseclasses as well).

          \strong{Example:}

          \begin{verbatim}
import grok

class ModelBase(grok.Model):
    pass

class ViewBase(grok.View):
    def render(self):
        return "hello world"

class AnotherView(grok.View):
    grok.baseclass()

    def render(self):
        return "hello world"

class WorkingView(grok.View):
    pass
          \end{verbatim}

          Using this example, only the \class{WorkingView} will serve
          as a view, while calling the \class{ViewBase} or
          \class{AnotherView} will lead to a
          \exception{ComponentLookupError}.


        \end{funcdesc}

    \section{\function{grok.define_permission} -- define a permission}

        \begin{funcdesc}{grok.define_permission}{name}

          A module-level directive to define a permission with name
          \var{name}. Usually permission names are prefixed by a
          component- or application name and a dot to keep them
          unique.

          Because in Grok by default everything is accessible by
          everybody, it is important to define permissions, which
          restrict access to certain principals or roles.

          \strong{Example:}

          \begin{verbatim}
import grok
grok.define_permission('cave.enter')
          \end{verbatim}

          \begin{seealso}
            \function{grok.require()}, \class{grok.Permission},
            \class{grok.Role}
          \end{seealso}

          \versionchanged[replaced by \class{grok.Permission}]{0.11}
          
        \end{funcdesc}



    \section{\function{grok.Fields}}

        \begin{funcdesc}{grok.Fields}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.implements}}

        \begin{funcdesc}{grok.implements}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.context}}

        \begin{funcdesc}{grok.context}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.global_utility}}

        \begin{funcdesc}{grok.global_utility}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.localesdir} -- register a
      locales directory}

        \begin{funcdesc}{grok.localesdir}{directory}
          A module-level directive, which can be used to register
          a locales directory. It is a Python based equivalent to the
          ZCML directive \code{i18n:registerTranslations}.

          If no value is given, the default \code{'locales'} is taken.

          The directory must exist in the path given relative to the
          package wherein the directive was used.

          The directive takes at most one parameter and can be used
          several times per module.

          A \class{GlobalGrokker} is called for every module in a
          grokked package. If a module does not provide a
          \function{grok.localesdir} directive, then
          \code{'locales'} is assumed as default value and tried to be
          registered.

          This means especially, that if you do no explicit call to
          \function{localesdir}, but a local directory with
          name \code{locales} and translations exists, then this
          directory will be registered.

          You can avoid this behaviour by declaring a different
          locales directory in every module of your package(s) which
          also might be empty.

          The following example registers a local \code{locales}
          directory as a source for translations:

          If this code resides in a location \code{/foo/bar.py}, then
          Zope will look for translations in \code{/foo/locales}. The
          example is a short form for the following:

          \begin{verbatim}
import grok
grok.localesdir()
          \end{verbatim}

          If this code resides in a location \code{/foo/bar.py}, then
          Zope will look for translations in \code{/foo/locales}. The
          example is a short form for the following:

          \begin{verbatim}
import grok
grok.localesdir('locales')
          \end{verbatim}

          This is the explicit form of the implicit behaviour, if no
          \function{grok.localesdir} is defined explicitly. Different
          to the default behaviour, grok will complain about a
          non-exisiting \code{locales} directory.

          You can, given that the given directories exist, declare
          several locale-directories, which will all be parsed:

          \begin{verbatim}
import grok
grok.localesdir('savannah')
grok.localesdir('landofoz')
          \end{verbatim}
         

        \end{funcdesc}

    \section{\function{grok.name}}

        \begin{funcdesc}{grok.name}{*arg}
        foobar
        \end{funcdesc}

        Used to associate a component with a name. Typically this directive is
        optional. The default behaviour when no name is given depends on the
        component.

    \section{\function{grok.local_utility}}

        \begin{funcdesc}{grok.local_utility}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.provides}}

        \begin{funcdesc}{grok.provides}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.resourcedir --- XXX Not implemented yet}}

        \begin{funcdesc}{grok.resourcedir}{*arg}
        foobar
        \end{funcdesc}

        Resource directories are used to embed static resources like HTML-,
        JavaScript-, CSS- and other files in your application.

        XXX insert directive description here (first: define the name, second:
        describe the default behaviour if the directive isn't given)

        A resource directory is created when a package contains a directory
        with the name \file{static}. All files from this directory become
        accessible from a browser under the URL
        \file{http://<servername>/++resource++<packagename>/<filename>}.

        \begin{bf}Example:\end{bf} The package \module{a.b.c} is grokked and
        contains a directory \file{static} which contains the file
        \file{example.css}. The stylesheet will be available via
        \file{http://<servername>/++resource++a.b.c/example.css}.

        \begin{notice}
        A package can never have both a \file{static} directory and a Python
        module with the name \file{static.py} at the same time. grok will
        remind you of this conflict when grokking a package by displaying an
        error message.
        \end{notice}

        \subsection{Linking to resources from templates}

            grok provides a convenient way to calculate the URLs to static
            resource using the keyword \keyword{static} in page templates:

            \begin{verbatim}
<link rel="stylesheet" tal:attributes="href static/example.css" type="text/css">
            \end{verbatim}

            The keyword \keyword{static} will be replaced by the reference to
            the resource directory for the package in which the template was
            registered.

    \section{\function{grok.require}}

        \begin{funcdesc}{grok.require}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.site}}

        \begin{funcdesc}{grok.site}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.template}}

        \begin{funcdesc}{grok.template}{*arg}
        foobar
        \end{funcdesc}

    \section{\function{grok.templatedir}}

        \begin{funcdesc}{grok.templatedir}{*arg}
        foobar
        \end{funcdesc}
