==================================
Plugging in new template languages
==================================

:Author: Lennart Regebro

Introduction
------------
Grok uses Zope Page Templates as default templating language, since this is
the default of Zope 3. Of course you can use whatever templating language you
want in Grok, but to get the automatic association between template
objects/files and views you need to do a little bit of extra work.

Inline templates
----------------
"Inline" templates are templates where the template code is written inside the
python class. To get the automatic association to a view class, you need to
write a class that subclasses from grok.components.GrokPageTemplate, so it
will be picked up by the template grokkers. It also needs to implement
grok.interfaces.ITemplateFile. Here is an example:

.. code-block:: python

    class MyPageTemplate(grok.components.GrokPageTemplate):

        def __init__(self, html):
            self._template = MyTemplate(html)
            self.__grok_module__ = martian.util.caller_module()

        def _factory_init(self, factory):
            pass
    
        def default_namespace(self):
            return {}
    
        def render_template(self, view):
            namespace = self.getDefaultVariables()
            namespace.update(view.getTemplateVariables())
            return self._template.render(**namespace)

In the __init__ method of a typical template you pass in what should be
rendered. This is usually HTML, but can equally well be XML or text, or
whatever your template renders. Note the line setting self.__grok_module__.
This is necessary to support inline templates.

The _factory_init method is a call made when setting up views (when the server
starts). Basically, you can here initialize the view in ways needed to your
template language. For example, Zope Page Templates set the macro attribute on
the view class, so that you can access ZPT macros with the standard syntax of
"context/@@viewname/macros/themacro". Most likely your class doesn't need to
do anything here.

The default_namespace method should return a dictionary with variables that
should be included in the namespace that is specific for your template
language. By default 'context', 'view', 'request' and 'static' is made
available by the view. Your language might want to use some more. 

Lastly, the render_template is the method normally used to render a template
attached to a view. Here you do whatever necessary to render your template.
This is usually to call view.default_namespace() and then update the namespace
with the result of the view-specific "extra_namespace", to let the view add
more variables to the namespace, and also override the defaults. The above
example is a reasonable startingpoint for most cases.

With this class finished you can create an inline template, like this:

.. code-block:: python

    class AView(grok.View):
        pass
        
    aview = MyPageTemplate('<html><body>Some text</body></html>')


File templates
--------------
Mostly you want your templates to reside on disk. To do this you need a
file template class. It looks and works as the template class above, except
that it loads the template from a file instead:

.. code-block:: python

    class MyPageTemplateFile(grok.components.GrokPageTemplate):

        def __init__(self, filename, _prefix=None):
            file = open(os.path.join(_prefix, filename)
            self._template = MyTemplate(file.read())
            self.__grok_module__ = martian.util.caller_module()
    
        def render_template(self, view):
            namespace = self.getDefaultVariables()
            namespace.update(view.getTemplateVariables())
            return self._template.render(**namespace)

Here _factory_init and default_namespace is left out, as GrokPaeTemplate
alredy has them as defaults. The __init__ now takes two parameters, filename
and _prefix, which is the directory in which the file resides. Although there
is no requirement that these are the parameters used it is a good idea, since
that makes the next step easier.

Now you can use this filebase template:

.. code-block:: python

    class AView(grok.View):
        pass
        
    aview = MyTemplateFile('lasceuax.html', '.')


Templates in the _templates directory
-------------------------------------

The most common usecase is however to place the templates in the views
template directory. To do that, a global utility that generates
MyPageTemplates from the filenames found is needed. That utility needs to
implement the ITemplateFileFactory interface. The easiest way of doing this is
to let your template file class implement it directly, by having the above
filename and _prefix parameters in the __init__ call and tell the component
architecture that the class provides the interface with a classProvides call.
You also need to tell Grok that the class should be a direct global utility by
subclassing from grok.GlobalUtility, and annotating it with a grok.direct()
annotation. Lastly you need to choose an extension for your template files,
and set the grok.name to that extension:

.. code-block:: python

    class MyPageTemplateFile(grok.components.GrokPageTemplate):
    
        zope.interface.implements(grok.interfaces.ITemplateFile)
        zope.interface.classProvides(grok.interfaces.ITemplateFileFactory)
        grok.name('mtl')
        grok.direct()

        def __init__(self, filename, _prefix=None):
            file = open(os.path.join(_prefix, filename)
            self._template = MyTemplate(file.read())
            self.__grok_module__ = martian.util.caller_module()
    
        def render_template(self, view):
            namespace = self.getDefaultVariables()
            namespace.update(view.getTemplateVariables())
            return self._template.render(**namespace)

When your module gets grokked, Grok will now pick up on the MyPageTemplateFile
class, register it as a global utility for templates with the '.mtl' extension
and you can start creating .mtl files in the template directory for your class.

Have fun!
