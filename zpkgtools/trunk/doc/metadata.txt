=======================================
Metadata Descriptions for Distributions
=======================================

Overview
--------

Distributions will be described using a collection of files that
contain different aspects of the relevant metadata.

`DEPENDENCIES.cfg`
  A list of dependencies for this distributoin.  This is currently
  simply a list of imported Python packages that aren't provided with
  the distribution (listed one per line), but additional features may
  be identified by adding lines that use a prefix to denote the type
  of the dependency.  For example::

    feature:XML parser

  Blank lines and lines starting with ``#`` as the first non-white
  character are ignored.  All other lines are considered a single
  dependency; leading and trailing whitespace will be ignored.
  Dependencies are case-sensitive.

  Note that dependencies are kept separate from the information in the
  `SETUP.cfg` file since that's intended to record information about
  what the distribution contains, while dependencies serve as
  constraints on any software included in the distribution.

`PACKAGE.cfg`
  List of inclusions (and exclusions) that are added/removed from the
  distribution as it's constructed.  See `Package Construction
  Information`_ for details.

`PUBLICATION.cfg`
  General metadata related to a distribution.  This includes
  information such as the name of the component (i.e., "Frobnitz
  Manager"), author and maintainer information, and Trove
  classification.  Version information should not be included; it will
  be ignored if present (perhaps should be an error?).  This is the
  information distutils normally pushes into the generated `PKG-INFO`
  file; this file has the same format as `PKG-INFO`.

  One additional key is defined for this file: ``Installation-type``.
  This header can be set to ``application`` for collection
  distribution to indicate that the distribution is not a normal
  collection that should have a `setup.py` file for distutils, but
  should have a more conventional **configure** / **make** / **make
  install** build process that creates an application-specific
  installation tree (for example, `/usr/local/Zope3`).

`SETUP.cfg`
  This file contains information on building extension modules.
  Information about scripts and documentation files will also be
  included in this file.  See `Embedded Package Definitions`_ for more
  information.

Package Construction Information
--------------------------------

  The `PACKAGE.cfg` file can contain three distinct sections; the
  ``<load>`` section identifies files that need to be loaded from
  other sources, the ``<distribution>`` section is used to include
  files in the distribution root, and the ``<collection>`` section is
  used to include files in the component itself (even if the component
  isn't a collection; this name is used since it usually will be a
  collection).

  The way `PACKAGE.cfg` is processed is straightforward, but warrants
  explanation.  The process has the following steps:

  1. A copy of the component is made that can be written to.  This is
     the *workspace*.

  2. External references are loaded into the workspace.  It is
     possible for this to overwrite portions of the component itself,
     so specify the loads carefully.  This is based on the ``<load>``
     section of `PACKAGE.cfg`; the ``<load>`` section cannot contain
     exclusions.

  3. Files from the workspace are copied into their final locations in
     the component-specific portion of the distribution tree.

     By default, the entire workspace is copied to the
     component-specific portion of the distribution tree, with the
     exception of files and directories associated with various
     revision control systems.  Files named `.cvsignore` and
     directories with names of `CVS`, `RCS`, or `SCCS` are excluded.

     Files in the workspace can be excluded from this copy operation
     using a line of the form

       *files* ``-``

     The hyphen indicates that this is an exclusion.  In this case,
     *files* can contain globbing wildcards; these patterns will be
     matched against the workspace, and can include files loaded as
     part of the component or from external references.

     A copy of a file with a new name can be generated in the
     distribution tree using a line like this in `PACKAGE.cfg`:

       *destination*   *source*

     This causes the file or directory identified by *source* in the
     workspace to be copied to the name *destination* in the
     distribution tree.  This does *not* prevent a file named *source*
     from also being created in the distribution; an exclusion must be
     used to completely rename the file.  For example, to rename a
     file named `README` to `README.txt`, use::

       README.txt  README
       README      -

     The order of the two lines is irrelevant.

     This operation is based on the ``<collection>`` section of the
     `PACKAGE.cfg` file.

  4. If the component being processed is the primary resource being
     packaged, files from the workspace can be copied into the
     distribution root.  This is done using the ``<distribution>``
     section of `PACKAGE.cfg`.  This is most useful for including a
     `README.txt` in the distribution root so people unpacking the
     distribution can read about the package they've just unpacked.

     Including a file in the distribution root is done using a basic
     inclusion line of the form

       *destination*   *source*

     Unlike inclusions in the ``<collection>`` section, the
     *destination* is interpreted relative to the distribution root
     rather than the component-specific portion of the distribution
     tree.

     To move a file from the component into the distribution root, and
     not include it when using the component as part of some other
     distribution, use an inclusion in the ``<distribution>`` section
     and an exclusion in the ``<collection>`` section::

       <collection>
         README       -
       </collection>

       <distribution>
         README.txt   README
       </distribution>

     The ``<distribution>`` section may not contain exclusions.

  As an example, this is the `PACKAGE.cfg` being used for the
  ``ZConfig`` package at the time of this writing::

    # Load the license from an external source, so we don't have to keep a
    # copy of it sitting around:
    <load>
      LICENSE.txt  http://cvs.zope.org/Zope3/ZopePublicLicense.txt?rev=HEAD
    </load>

    # Add a few things to the distribution root.
    <distribution>
      doc          doc
      LICENSE.txt  LICENSE.txt
      NEWS.txt     NEWS.txt
      README.txt   README.txt
    </distribution>

    # and remove the same from the package itself.
    <collection>
      doc          -
      LICENSE.txt  -
      NEWS.txt     -
      README.txt   -

      # We'll remove this too, since it's only of interest to CVS users:
      BRANCHES.txt -
    </collection>

  Note that when excluding files from the collection, wildcards are
  supported using the convention POSIX globbing syntax.  The
  ``<collection>`` section above could have been written as::

    <collection>
      doc          -
      *.txt        -
    </collection>

  This wouldn't have made it as screamingly obvious that we were
  dropping a text file from the finished package that wasn't already
  mentioned, however.  This re-write would not be possible if there
  were other files matching ``*.txt`` that should be copied into the
  installed ``ZConfig`` package.


Embedded Package Definitions
----------------------------

Distribution components can include a `SETUP.cfg` that contains
information about special files in the component (such as
documentation and scripts), and what extensions need to be built.
This file is a ZConfig-like configuration file that can contain the
following settings, repeated as necessary:

**documentation**
  The name of a file or directory containing documentation. This is
  used to support RPM generation.

**script**
  Only files may be identified using this.  These files are included
  in the distribution and will be installed as executable scripts for
  the end user.

For paths, POSIX path separators must be used, and Unix-style glob
expansion is performed.  Path names may not include leading or
trailing whitespace.  Directories named `CVS`, `RCS`, `SCCS`, or
`.svn` are ignored, as are files named `.cvsignore`.

Paths can only refer to descendents of the directory containing
`SETUP.cfg`, never to that directory itself or anything higher up
the filesystem hierarchy.

Support for Compiled Extensions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Compiled extensions are described using **<extension>** sections in
the `SETUP.cfg` file.  The name of the section should be the name of
the extension module within the Python package.  For example, the
extension ``persistent.cPersistence`` would be represented using a
section of the form::

  <extension cPersistence>
    ...
  </extension>

The **<extension>** section can contain the settings described below.
All of these can be repeated with the exception of the **language**
setting.

**define**
  Define additional symbols for the C preprocessor.  Values must be of
  the form ``NAME`` or ``NAME=value``.  For example::

    define NAME

  is equivalent to including the following line at the top of the C
  source::

    #define NAME

  and this::

    define NAME=value

  is equivalent to this line in C::

    #define NAME value

  The ``NAME`` portion must be a valid C identifier.

**depends-on**
  Additional files that the compiled extension depends on.  This is
  used by distutils to determine whether the extension needs to be
  recompiled.  Since the source files are identified by the **source**
  setting, this is normally only needed for header files.

  XXX This is the one place I've seen a need to point outside the
  current package.  In ZODB, the BTrees extension modules need to pick
  up `../persistent/cPersistence.h`.

**language**
  The source language of the extension; this may be needed to control
  compiler selection if unusual extensions are used for the source
  files.  This is not normally needed.

**source**
  Source files for the extension.  Each file is compiled into object
  code, and the individual objects are linked to create the
  extension module.  At least one source file must be listed.

**undefine**
  Specify one or more macros that should not be initially defined by
  preprocessor.  For example, this line::

    undefine NAME ANOTHER

  is equivalent to the source lines::

    #undef NAME
    #undef ANOTHER

  at the top of the compilation unit.
