#! /usr/bin/env python2.3

import optparse
import os
import shutil
import sys
import tempfile

try:
    __file__
except NameError:
    __file__ = sys.argv[0]

script = os.path.realpath(__file__)
here = os.path.dirname(script)

try:
    import zpkgtools
except ImportError:
    # Not installed; running from development copy:
    basedir = os.path.dirname(here)
    sys.path.append(basedir)
    import zpkgtools

from zpkgtools import config
from zpkgtools import cvsloader
from zpkgtools import publication
from zpkgtools import setup
from zpkgtools.include import InclusionProcessor


class Application:

    def __init__(self, options, resource, program):
        self.ip = None
        self.options = options
        self.resource = resource
        # Create a new directory for all temporary files to go in:
        self.tmpdir = tempfile.mkdtemp(prefix=program + "-")
        tempfile.tempdir = self.tmpdir
        self.loader = cvsloader.CvsLoader()
        cf = config.Configuration(options.configfile)
        cf.finalize()
        self.locations = cf.locations

        if resource not in self.locations:
            print >>sys.stderr, "unknown resource:", resource
            sys.exit(1)
        self.resource_url = self.locations[resource]

    def buildDistribution(self):
        # This could be either a package distribution or a collection
        # distribution; it's the former if there's an __init__.py in
        # the source directory.
        if os.path.exists(os.path.join(self.source, "__init__.py")):
            self.buildPackageDistribution()
        else:
            self.buildCollectionDistribution()
        self.generateSetup()

    def buildPackageDistribution(self):
        os.mkdir(self.destination)
        pkgname = self.metadata.name

        self.ip = InclusionProcessor(self.source,
                                     os.path.join(self.destination, pkgname))
        try:
            self.ip.createDistributionTree()
        except cvsloader.CvsLoadingError, e:
            print >>sys.stderr, e
            sys.exit(1)

        self.package_data = {}
        self.package_dir = {pkgname: pkgname}
        self.packages = [pkgname]
        self.scripts = []
        self.scanPackage(pkgname, self.source)

    def scanPackage(self, name, directory):
        files = os.listdir(directory)
        # need to load package-specific data here as well
        for fn in files:
            fnbase, ext = os.path.splitext(fn)
            if ext in (".py", ".pyc", ".pyo", ".so", ".sl", ".pyd"):
                continue
            path = os.path.join(directory, fn)
            if os.path.isdir(path):
                init_py = os.path.join(path, "__init__.py")
                publication_txt = os.path.join(path, "PUBLICATION.txt")
                if (os.path.isfile(init_py)
                    and os.path.exists(publication_txt)):
                    pkgname = "%s.%s" % (name, fn)
                    self.packages.append(pkgname)
                    self.scanPackage(pkgname, path)
                else:
                    # an ordinary directory
                    pass
            else:
                self.addPackageFile(name, fn)

    def scanDirectory(self, pkgname, directory, reldir):
        """Scan a data directory, adding files to package_data."""
        for fn in os.listdir(directory):
            relfn = os.path.join(reldir, fn)
            if os.path.isdir(fn):
                self.scanDirectory(pkgname,
                                   os.path.join(directory, fn),
                                   relfn)
            else:
                fnbase, ext = os.path.splitext(fn)
                if ext in (".pyc", ".pyo", ".so", ".sl", ".pyd"):
                    continue
                self.addPackageFile(pkgname, relfn)

    def addPackageFile(self, pkgname, relfn):
        L = self.package_data.setdefault(pkgname, [])
        L.append(relfn)

    def buildCollectionDistribution(self):
        # Build the destination directory:
        self.ip = InclusionProcessor(self.source,
                                     self.destination)
        try:
            self.ip.createDistributionTree()
        except cvsloader.CvsLoadingError, e:
            print >>sys.stderr, e
            sys.exit(1)

    def loadMetadata(self):
        metadata_file = os.path.join(self.source, "PUBLICATION.txt")
        if not os.path.isfile(metadata_file):
            print >>sys.stderr, \
                  "source-dir does not contain required publication data file"
            sys.exit(1)
        self.metadata = publication.load(open(metadata_file))

    def loadResource(self):
        self.source = self.loader.load(self.resource_url)
        self.loadMetadata()
        self.target_name = "%s-%s" % (self.metadata.name, self.options.version)
        self.target_file = self.target_name + ".tar.bz2"
        self.destination = os.path.join(self.tmpdir, self.target_name)

    def generateSetup(self):
        setup.generate(self.destination,
                       self.metadata,
                       self.options.version)

    def createTarball(self):
        pwd = os.getcwd()
        os.chdir(self.tmpdir)
        try:
            rc = os.spawnlp(os.P_WAIT, "tar",
                            "tar", "cjf", self.target_file, self.target_name)
        finally:
            os.chdir(pwd)
        if rc:
            print >>sys.stderr, "error generating", self.target_file
            sys.exit(1)
        # We have a tarball; clear some space, then copy the tarball
        # to the current directory:
        shutil.rmtree(self.destination)
        shutil.copy(os.path.join(self.tmpdir, self.target_file),
                    self.target_file)

    def cleanup(self):
        shutil.rmtree(self.tmpdir)

    def run(self):
        try:
            self.loadResource()
            self.buildDistribution()
            self.createTarball()
            self.cleanup()
        except:
            print >>sys.stderr, "temporary files are in", self.tmpdir
            raise


def main(argv=None):
    if argv is None:
        argv = sys.argv
    program = os.path.basename(argv[0])
    parser = optparse.OptionParser(
        usage="usage: %prog [options] resource")
    parser.add_option(
        "-C", "--configure", dest="configfile",
        help="path or URL to the configuration file")
    parser.add_option(
        "-r", "--revision-tag", dest="revision_tag",
        help="default CVS tag to use (default: HEAD)",
        default="HEAD")
    parser.add_option(
        "-v", dest="version",
        help="version label for the new distribution",
        default="0.0.0")
    options, args = parser.parse_args(argv[1:])

    # figure out what to read from:
    if len(args) != 1:
        print >>sys.stderr, "wrong number of arguments"
        return 2
    resource = args[0]

    try:
        app = Application(options, resource, program)
        app.run()
    except SystemExit, e:
        return e.code
    except KeyboardInterrupt:
        return 1
    else:
        return 0


if __name__ == "__main__":
    sys.exit(main())
